//*****************************************************************************
//
// Microsoft Windows Media Player
// Copyright (C) Microsoft Corporation, 2001
//
// FileName:            wmp.idl
//
// Abstract:            Interface definitions for all public Windows Media
//                      Player interfaces.
//
//*****************************************************************************
#include <olectl.h>
#include "wmpids.h"

import "oaidl.idl";
import "ocidl.idl";

//////////////////////////////////////////////////////////////////////
//            PUBLIC ENUM TYPES 
//////////////////////////////////////////////////////////////////////

typedef
[
    helpstring( "State of opening process" ),
    public
]
enum WMPOpenState // wmpos
{
    [ helpstring( "Undefined" ) ]                                   wmposUndefined,
    [ helpstring( "New Playlist is about to be loaded" ) ]          wmposPlaylistChanging,
    [ helpstring( "Locating the playlist" ) ]                       wmposPlaylistLocating,
    [ helpstring( "Connecting to the server holding a playlist" ) ] wmposPlaylistConnecting,
    [ helpstring( "Loading a playlist" ) ]                          wmposPlaylistLoading,
    [ helpstring( "Opening a playlist" ) ]                          wmposPlaylistOpening,
    [ helpstring( "Playlist is open" ) ]                            wmposPlaylistOpenNoMedia,
    [ helpstring( "Playlist has changed" ) ]                        wmposPlaylistChanged,
    [ helpstring( "New media is about to be loaded" ) ]             wmposMediaChanging,
    [ helpstring( "Locating the media" ) ]                          wmposMediaLocating,
    [ helpstring( "Connecting to the server holding media" ) ]      wmposMediaConnecting,
    [ helpstring( "Loading media" ) ]                               wmposMediaLoading,
    [ helpstring( "Opening a media" ) ]                             wmposMediaOpening,
    [ helpstring( "Media is open" ) ]                               wmposMediaOpen,
    [ helpstring( "Starting codec acquisition" ) ]                  wmposBeginCodecAcquisition,
    [ helpstring( "End codec acquisition" ) ]                       wmposEndCodecAcquisition,
    [ helpstring( "Starting license acquisition" ) ]                wmposBeginLicenseAcquisition,
    [ helpstring( "End license acquisition" ) ]                     wmposEndLicenseAcquisition,
    [ helpstring( "Starting individualization" ) ]                  wmposBeginIndividualization,
    [ helpstring( "End individualization" ) ]                       wmposEndIndividualization,
    [ helpstring( "Waiting for media" ) ]                           wmposMediaWaiting,    
    [ helpstring( "Opening an URL whose type is not known" ) ]      wmposOpeningUnknownURL,    
} WMPOpenState;

typedef
[
    helpstring( "State of playback" ),
    public
]
enum WMPPlayState
{
    [ helpstring( "State is undefined" ) ]                      wmppsUndefined,
    [ helpstring( "Playback is stopped" ) ]                     wmppsStopped,
    [ helpstring( "Playback is paused" ) ]                      wmppsPaused,
    [ helpstring( "Stream is playing" ) ]                       wmppsPlaying,
    [ helpstring( "Stream is Scanning forward" ) ]              wmppsScanForward,
    [ helpstring( "Stream is Scanning in reverse" ) ]           wmppsScanReverse,
    [ helpstring( "Media is being buffered" ) ]                 wmppsBuffering,
    [ helpstring( "Waiting for streaming data" ) ]              wmppsWaiting,
    [ helpstring( "End of media reached" ) ]                    wmppsMediaEnded,
    [ helpstring( "Preparing new media" ) ]                     wmppsTransitioning,
    [ helpstring( "Ready to begin playing" ) ]                  wmppsReady,
} WMPPlayState;


typedef
[
    helpstring("WMP Playlist Change Event Type"),
    public
]
enum WMPPlaylistChangeEventType
{
    [ helpstring( "Unknown" ) ]     wmplcUnknown = 0,
    [ helpstring( "Clear" ) ]       wmplcClear,
    [ helpstring( "InfoChange" ) ]  wmplcInfoChange,
    [ helpstring( "Move" ) ]        wmplcMove,
    [ helpstring( "Delete" ) ]      wmplcDelete,
    [ helpstring( "Insert" ) ]      wmplcInsert,
    [ helpstring( "Append" ) ]      wmplcAppend,
    [ helpstring( "Private" ) ]     wmplcPrivate,
    [ helpstring( "NameChange" ) ]  wmplcNameChange,
    [ helpstring( "Morph" ) ]       wmplcMorph,
    [ helpstring( "Last" ) ]        wmplcLast
} WMPPlaylistChangeEventType;


//////////////////////////////////////////////////////////////////////
//                  Forward interface declarations
//////////////////////////////////////////////////////////////////////

interface IWMPPlaylist;


//////////////////////////////////////////////////////////////////////
//                   PUBLIC INTERFACES
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
//          Error Interfaces
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(3614C646-3B3B-4de7-A81E-930E3F2127B3),
    dual,
    helpstring("IWMPErrorItem interface"),
    pointer_default(unique)
]
interface IWMPErrorItem : IDispatch
{
    [ id(DISPID_WMPERRORITEM_ERRORCODE), propget, helpstring("Returns the error code") ]
        HRESULT errorCode( [out, retval] long * phr );
    [ id(DISPID_WMPERRORITEM_ERRORDESCRIPTION), propget, helpstring("Returns a description of the error") ]
        HRESULT errorDescription( [out, retval] BSTR * pbstrDescription );
    [ id(DISPID_WMPERRORITEM_ERRORCONTEXT), propget, helpstring("Returns context information for the error") ]
        HRESULT errorContext( [out, retval] VARIANT * pvarContext );
    [ id(DISPID_WMPERRORITEM_REMEDY), propget, helpstring("Returns remedy code for the error") ]
        HRESULT remedy( [out, retval] long * plRemedy );
    [ id(DISPID_WMPERRORITEM_CUSTOMURL), propget, helpstring("Returns a custom url for this error (if avail)") ]
        HRESULT customUrl( [out, retval] BSTR * pbstrCustomUrl );
}

[
    object,
    uuid(A12DCF7D-14AB-4c1b-A8CD-63909F06025B),
    dual,
    helpstring("IWMPError Interface"),
    pointer_default(unique)
]
interface IWMPError : IDispatch
{
    [ id(DISPID_WMPERROR_CLEARERRORQUEUE), helpstring("Clears the error queue") ]
        HRESULT clearErrorQueue();
    [ id(DISPID_WMPERROR_ERRORCOUNT), propget, helpstring("Returns the number of error items") ]
        HRESULT errorCount( [out, retval] DWORD * pdwNumErrors );
    [ id(DISPID_WMPERROR_ITEM), propget, helpstring("Returns an error item object") ]
        HRESULT item( [in] DWORD dwIndex, [out, retval] IWMPErrorItem ** ppErrorItem );
    [ id(DISPID_WMPERROR_WEBHELP), helpstring("Launches WebHelp") ]
        HRESULT webHelp();
}

//////////////////////////////////////////////////////////////////////
//          Media Interfaces
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(94D55E95-3FAC-11d3-B155-00C04F79FAA6),
    dual,
    helpstring("IWMPMedia Interface"),
    pointer_default(unique)
]
interface IWMPMedia : IDispatch
{
    [ id( DISPID_WMPMEDIA_ISIDENTICAL ), propget, helpstring( "Determines if the supplied object is the same as the this one" ) ]
        HRESULT isIdentical([in] IWMPMedia *pIWMPMedia, [out, retval] VARIANT_BOOL *pvbool );
    [ id( DISPID_WMPMEDIA_SOURCEURL ), propget, helpstring( "Returns the media URL" ) ]
        HRESULT sourceURL( [out, retval] BSTR *pbstrSourceURL );
    [ id( DISPID_WMPMEDIA_NAME ), propget, helpstring( "Returns the name of the media" ) ]
        HRESULT name( [out, retval] BSTR *pbstrName);
    [ id( DISPID_WMPMEDIA_NAME ), propput, helpstring( "Sets the name of the media" ) ]
        HRESULT name( [in] BSTR bstrName);
    [ id( DISPID_WMPMEDIA_IMAGESOURCEWIDTH ), propget, helpstring( "Returns the original width of the source images" ) ]
        HRESULT imageSourceWidth( [out, retval] long *pWidth );
    [ id( DISPID_WMPMEDIA_IMAGESOURCEHEIGHT ), propget, helpstring( "Returns the original height of the source images" ) ]
        HRESULT imageSourceHeight( [out, retval] long *pHeight );
    [ id( DISPID_WMPMEDIA_MARKERCOUNT ), propget, helpstring( "Returns the number of markers in the file" ) ]
        HRESULT markerCount( [out, retval] long *pMarkerCount );
    [ id( DISPID_WMPMEDIA_GETMARKERTIME ), helpstring( "Returns the time of a marker" ) ]
        HRESULT getMarkerTime( [in] long MarkerNum, [out, retval] double *pMarkerTime );
    [ id( DISPID_WMPMEDIA_GETMARKERNAME ), helpstring( "Returns the name of a marker" ) ]
        HRESULT getMarkerName( [in] long MarkerNum, [out, retval] BSTR *pbstrMarkerName );
    [ id( DISPID_WMPMEDIA_DURATION ), propget, helpstring( "Returns duration of current media" ) ]
        HRESULT duration( [out, retval] double * pDuration );
    [ id( DISPID_WMPMEDIA_DURATIONSTRING ), propget, helpstring( "Returns duration of current media as a string" ) ]
        HRESULT durationString( [out, retval] BSTR * pbstrDuration );
    [ id( DISPID_WMPMEDIA_ATTRIBUTECOUNT ), propget, helpstring( "Returns the count of the attributes associated with this media" ) ]
        HRESULT attributeCount( [out, retval] long *plCount );
    [ id( DISPID_WMPMEDIA_GETATTRIBUTENAME ), helpstring( "Returns the name of the attribute whose index has been specified" ) ]
        HRESULT getAttributeName( [in] long lIndex, [out, retval] BSTR *pbstrItemName );
    [ id( DISPID_WMPMEDIA_GETITEMINFO ), helpstring( "Returns the value of specified attribute for this media" ) ]
        HRESULT getItemInfo( [in] BSTR bstrItemName, [out, retval] BSTR *pbstrVal );
    [ id( DISPID_WMPMEDIA_SETITEMINFO ), helpstring( "Sets the value of specified attribute for this media" ) ]
        HRESULT setItemInfo( [in] BSTR bstrItemName, [in] BSTR bstrVal );
    [ id( DISPID_WMPMEDIA_GETITEMINFOBYATOM ), helpstring( "Gets an item info by atom" ) ]
        HRESULT getItemInfoByAtom( [in] long lAtom, [out, retval] BSTR* pbstrVal );
    [ id( DISPID_WMPMEDIA_ISMEMBEROF ), helpstring( "Is the media a member of the given playlist" ) ]
        HRESULT isMemberOf( [in] IWMPPlaylist* pPlaylist, [out, retval] VARIANT_BOOL* pvarfIsMemberOf );
    [ id( DISPID_WMPMEDIA_ISREADONLYITEM ), helpstring( "Is the attribute read only" ) ]
        HRESULT isReadOnlyItem( [in] BSTR bstrItemName, [out, retval] VARIANT_BOOL* pvarfIsReadOnly);
}    

[
    object,
    uuid(AB7C88BB-143E-4ea4-ACC3-E4350B2106C3),
    dual,
    helpstring("IWMPMedia2 Interface"),
    pointer_default(unique)
]
interface IWMPMedia2 : IWMPMedia
{
    [ id( DISPID_WMPMEDIA2_ERROR ), propget, helpstring( "Returns an error item pointer for a media specific error" ) ]
        HRESULT error( [out, retval] IWMPErrorItem **ppIWMPErrorItem );
}


//////////////////////////////////////////////////////////////////////
//          Control Interfaces
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(74C09E02-F828-11d2-A74B-00A0C905F36E),
    dual,
    helpstring("IWMPControls Interface"),
    pointer_default(unique)
]
interface IWMPControls : IDispatch
{
    [ id( DISPID_WMPCONTROLS_ISAVAILABLE ), propget, helpstring( "Returns whether or not the specified media functionality is available" ) ]
        HRESULT isAvailable( [in] BSTR bstrItem, [out, retval] VARIANT_BOOL *pIsAvailable );
    [ id( DISPID_WMPCONTROLS_PLAY ),helpstring( "Begins playing media" ) ]
        HRESULT play();
    [ id( DISPID_WMPCONTROLS_STOP ),helpstring( "Stops play of media" ) ]
        HRESULT stop();
    [ id( DISPID_WMPCONTROLS_PAUSE ), helpstring( "Pauses play of media" ) ]
        HRESULT pause();
    [ id( DISPID_WMPCONTROLS_FASTFORWARD ), helpstring( "Fast play of media in forward direction" ) ]
        HRESULT fastForward();
    [ id( DISPID_WMPCONTROLS_FASTREVERSE ),helpstring( "Fast play of media in reverse direction" ) ]
        HRESULT fastReverse();
    [ id( DISPID_WMPCONTROLS_CURRENTPOSITION ), propget, helpstring( "Returns the current position in media" ) ]
        HRESULT currentPosition( [out, retval] double * pdCurrentPosition );
    [ id( DISPID_WMPCONTROLS_CURRENTPOSITION ), propput, helpstring( "sets the current position in media" ) ]
        HRESULT currentPosition( [in] double dCurrentPosition );
    [ id( DISPID_WMPCONTROLS_CURRENTPOSITIONSTRING ), propget, helpstring( "Returns the current position in media as a string" ) ]
        HRESULT currentPositionString( [out, retval] BSTR * pbstrCurrentPosition );
    [ id( DISPID_WMPCONTROLS_NEXT ), helpstring( "Sets the current item to the next item in the playlist" ) ]
        HRESULT next();
    [ id( DISPID_WMPCONTROLS_PREVIOUS ), helpstring( "Sets the current item to the previous item in the playlist" ) ]
        HRESULT previous();
    [ id( DISPID_WMPCONTROLS_CURRENTITEM ), propget, helpstring( "Returns/Sets the play item" ) ]
        HRESULT currentItem( [out, retval] IWMPMedia **ppIWMPMedia);
    [ id( DISPID_WMPCONTROLS_CURRENTITEM ), propput ]
        HRESULT currentItem( [in] IWMPMedia *pIWMPMedia );
    [ id( DISPID_WMPCONTROLS_CURRENTMARKER ), propget, helpstring( "Returns the current marker" ) ]
        HRESULT currentMarker( [out, retval] long *plMarker);
    [ id( DISPID_WMPCONTROLS_CURRENTMARKER ), propput, helpstring( "Sets the current marker" ) ]
        HRESULT currentMarker( [in] long lMarker);
    [ id( DISPID_WMPCONTROLS_PLAYITEM ), helpstring( "Sets the current item and plays it" )]
        HRESULT playItem( [in] IWMPMedia *pIWMPMedia );
}

[
    object,
    uuid(6F030D25-0890-480f-9775-1F7E40AB5B8E),
    dual,
    helpstring("IWMPControls2 Interface"),
    pointer_default(unique)
]
interface IWMPControls2 : IWMPControls
{
    [ id( DISPID_WMPCONTROLS2_STEP ), helpstring( "Advances the video one frame" )]
        HRESULT step([in] long lStep );
}

//////////////////////////////////////////////////////////////////////
//          Settings Interfaces
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(9104D1AB-80C9-4fed-ABF0-2E6417A6DF14),
    dual,
    helpstring("IWMPSettings Interface"),
    pointer_default(unique)
]
interface IWMPSettings : IDispatch
{
    [ id( DISPID_WMPSETTINGS_ISAVAILABLE ), propget, helpstring( "Returns whether or not the specified media functionality is available" ) ]
        HRESULT isAvailable( [in] BSTR bstrItem, [out, retval] VARIANT_BOOL *pIsAvailable );
    [ id( DISPID_WMPSETTINGS_AUTOSTART ), propget, helpstring( "Returns whether media should automatically begin playing" ) ]
        HRESULT autoStart( [out, retval] VARIANT_BOOL *pfAutoStart );
    [ id( DISPID_WMPSETTINGS_AUTOSTART ), propput, helpstring( "Sets whether media should automatically begin playing" ) ]
        HRESULT autoStart( [in] VARIANT_BOOL fAutoStart );

    [ id( DISPID_WMPSETTINGS_BASEURL ), propget, helpstring( "Returns the base URL used for relative path resolution" ) ]
        HRESULT baseURL( [out, retval] BSTR * pbstrBaseURL );
    [ id( DISPID_WMPSETTINGS_BASEURL ), propput, helpstring( "Sets the base URL used for relative path resolution" ) ]
        HRESULT baseURL( [in] BSTR bstrBaseURL );

    [ id( DISPID_WMPSETTINGS_DEFAULTFRAME ), propget, helpstring( "Returns the frame location that changes when a URL flip occurs" ) ]
        HRESULT defaultFrame( [out, retval] BSTR * pbstrDefaultFrame );
    [ id( DISPID_WMPSETTINGS_DEFAULTFRAME ), propput, helpstring( "Sets the frame location that changes when a URL flip occurs" ) ]
        HRESULT defaultFrame( [in] BSTR bstrDefaultFrame );

    [ id( DISPID_WMPSETTINGS_INVOKEURLS ), propget, helpstring( "Returns whether URL events should spawn a browser." ) ]
        HRESULT invokeURLs( [out, retval] VARIANT_BOOL *pfInvokeURLs );
    [ id( DISPID_WMPSETTINGS_INVOKEURLS ), propput, helpstring( "Sets whether URL events should spawn a browser." ) ]
        HRESULT invokeURLs( [in] VARIANT_BOOL fInvokeURLs );

    [ id( DISPID_WMPSETTINGS_MUTE ), propget, helpstring( "Returns whether audio should be muted." ) ]
        HRESULT mute( [out, retval] VARIANT_BOOL *pfMute );
    [ id( DISPID_WMPSETTINGS_MUTE ), propput, helpstring( "Sets audio mute." ) ]
        HRESULT mute( [in] VARIANT_BOOL fMute );

    [ id( DISPID_WMPSETTINGS_PLAYCOUNT ), propget, helpstring( "Returns how many times media should play" ) ]
        HRESULT playCount( [out, retval] long *plCount );
    [ id( DISPID_WMPSETTINGS_PLAYCOUNT ), propput, helpstring( "Sets whether media should automatically begin playing" ) ]
        HRESULT playCount( [in] long lCount );

    [ id( DISPID_WMPSETTINGS_RATE ), propget, helpstring( "Returns current playback rate" ) ]
        HRESULT rate( [out, retval] double * pdRate );
    [ id( DISPID_WMPSETTINGS_RATE ), propput, helpstring( "Sets current playback rate" ) ]
        HRESULT rate( [in] double dRate );

    [ id( DISPID_WMPSETTINGS_BALANCE ), propget, helpstring( "Returns current audio Balance" ) ]
        HRESULT balance( [out, retval] long * plBalance );
    [ id( DISPID_WMPSETTINGS_BALANCE ), propput, helpstring( "Sets audio Balance" ) ]
        HRESULT balance( [in] long lBalance );

    [ id( DISPID_WMPSETTINGS_VOLUME ), propget, helpstring( "Returns current audio volume" ) ]
        HRESULT volume( [out, retval] long * plVolume );
    [ id( DISPID_WMPSETTINGS_VOLUME ), propput, helpstring( "Sets audio volume" ) ]
        HRESULT volume( [in] long lVolume );

    [ id( DISPID_WMPSETTINGS_GETMODE ), helpstring( "Returns the mode of the playlist" ) ]
        HRESULT getMode(  [in] BSTR bstrMode, [out,retval] VARIANT_BOOL *pvarfMode );
    [ id( DISPID_WMPSETTINGS_SETMODE ), helpstring( "Sets the mode of the playlist" )  ]
        HRESULT setMode( [in] BSTR bstrMode, [in] VARIANT_BOOL varfMode );

    [ id( DISPID_WMPSETTINGS_ENABLEERRORDIALOGS ), propget, helpstring( "Returns whether error dialogs are shown by default when embedded" ) ]
        HRESULT enableErrorDialogs( [out, retval] VARIANT_BOOL *pfEnableErrorDialogs );
    [ id( DISPID_WMPSETTINGS_ENABLEERRORDIALOGS ), propput, helpstring( "Returns whether error dialogs are shown by default when embedded" ) ]
        HRESULT enableErrorDialogs( [in] VARIANT_BOOL fEnableErrorDialogs );

}

//////////////////////////////////////////////////////////////////////
//          ClosedCaption Interfaces
//////////////////////////////////////////////////////////////////////
[
    object,
    uuid(4F2DF574-C588-11d3-9ED0-00C04FB6E937),
    dual,
    helpstring("IWMPClosedCaption Interface"),
    pointer_default(unique)
]
interface IWMPClosedCaption : IDispatch
{
    [ id( DISPID_WMPCLOSEDCAPTION_SAMISTYLE ), propget, helpstring( "Returns the previously set SAMI style" ) ]
        HRESULT SAMIStyle( [out, retval] BSTR * pbstrSAMIStyle );
    [ id( DISPID_WMPCLOSEDCAPTION_SAMISTYLE ), propput, helpstring( "Sets the SAMI style" ) ]
        HRESULT SAMIStyle( [in] BSTR  bstrSAMIStyle );

    [ id( DISPID_WMPCLOSEDCAPTION_SAMILANG ), propget, helpstring( "Returns the previously set SAMI language" ) ]
        HRESULT SAMILang( [out, retval] BSTR * pbstrSAMILang );
    [ id( DISPID_WMPCLOSEDCAPTION_SAMILANG ), propput, helpstring( "Sets the SAMI language" ) ]
        HRESULT SAMILang( [in] BSTR  bstrSAMILang );

    [ id( DISPID_WMPCLOSEDCAPTION_SAMIFILENAME ), propget, helpstring( "Returns the previously set SAMI file name" ) ]
        HRESULT SAMIFileName( [out, retval] BSTR * pbstrSAMIFileName );
    [ id( DISPID_WMPCLOSEDCAPTION_SAMIFILENAME ), propput, helpstring( "Sets the SAMI file name" ) ]
        HRESULT SAMIFileName( [in] BSTR  bstrSAMIFileName );

    [ id( DISPID_WMPCLOSEDCAPTION_CAPTIONINGID ), propget, helpstring( "Returns the previously set Captioning ID" ) ]
        HRESULT captioningId( [out, retval] BSTR * pbstrCaptioningID );
    [ id( DISPID_WMPCLOSEDCAPTION_CAPTIONINGID ), propput, helpstring( "Sets the Captioning ID" ) ]
        HRESULT captioningId( [in] BSTR  bstrCaptioningID );

}

//////////////////////////////////////////////////////////////////////
//          Playlist Interfaces
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(D5F0F4F1-130C-11d3-B14E-00C04F79FAA6),
    dual,
    helpstring("IWMPPlaylist Interface"),
    pointer_default(unique)
]
interface IWMPPlaylist : IDispatch
{
    // properties
    [ id( DISPID_WMPPLAYLIST_COUNT ), propget, helpstring( "Returns the number of items in the playlist" ) ]
        HRESULT count( [out, retval] long *plCount );
    [ id( DISPID_WMPPLAYLIST_NAME ), propget, helpstring( "Returns the name of the playlist" ) ]
        HRESULT name( [out, retval] BSTR *pbstrName);
    [ id( DISPID_WMPPLAYLIST_NAME ), propput, helpstring( "Sets the name of the playlist" ) ]
        HRESULT name( [in] BSTR bstrName);
    [ id( DISPID_WMPPLAYLIST_ATTRIBUTECOUNT ), propget, helpstring( "Returns the number of attributes associated with the playlist" ) ]
        HRESULT attributeCount( [out, retval] long *plCount);
    [ id( DISPID_WMPPLAYLIST_ATTRIBUTENAME ), propget, helpstring( "Returns the name of an attribute specified by an index") ]
        HRESULT attributeName( [in] long lIndex, [out, retval] BSTR *pbstrAttributeName);
    [ id( DISPID_WMPPLAYLIST_ITEM ), propget, helpstring( "Returns the item at the specified index" ) ]
        HRESULT item( long lIndex, [out, retval] IWMPMedia **ppIWMPMedia );
    [ id( DISPID_WMPPLAYLIST_GETITEMINFO ), helpstring( "Returns the value of a playlist attribute" ) ]
        HRESULT getItemInfo( BSTR bstrName, [out, retval] BSTR *pbstrVal );
    [ id( DISPID_WMPPLAYLIST_SETITEMINFO ), helpstring( "Sets the value of a playlist attribute" ) ]
        HRESULT setItemInfo( [in] BSTR bstrName, [in] BSTR bstrValue );

    // methods
    [ id( DISPID_WMPPLAYLIST_ISIDENTICAL ), propget, helpstring( "Determines if the supplied object is the same as the this one" ) ]
        HRESULT isIdentical([in] IWMPPlaylist *pIWMPPlaylist, [out, retval] VARIANT_BOOL *pvbool );
    [ id( DISPID_WMPPLAYLIST_CLEAR ), helpstring( "Removes all items from the playlist" ) ]
        HRESULT clear();
    [ id( DISPID_WMPPLAYLIST_INSERTITEM ), helpstring( "Inserts an item into the playlist at the specified location" ) ]
        HRESULT insertItem( [in] long lIndex, [in] IWMPMedia *pIWMPMedia );
    [ id( DISPID_WMPPLAYLIST_APPENDITEM ), helpstring( "Adds an item to the end of the playlist" ) ]
        HRESULT appendItem( [in] IWMPMedia *pIWMPMedia );
    [ id( DISPID_WMPPLAYLIST_REMOVEITEM ), helpstring( "Removes the specified item from the playlist" ) ]
        HRESULT removeItem([in] IWMPMedia *pIWMPMedia );
    [ id( DISPID_WMPPLAYLIST_MOVEITEM ), helpstring( "Changes the location of an item in the playlist" ) ]
        HRESULT moveItem(long lIndexOld, long lIndexNew );

}

   
//////////////////////////////////////////////////////////////////////
//          CDROM Interfaces
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(cfab6e98-8730-11d3-b388-00c04f68574b),
    dual,
    helpstring("IWMPCdrom Interface"),
    pointer_default(unique)
]
interface IWMPCdrom : IDispatch
{
    // properties
    [ id( DISPID_WMPCDROM_DRIVESPECIFIER ), propget, helpstring( "Returns the CDROM drive specifier" ) ]
        HRESULT driveSpecifier ([out, retval] BSTR* pbstrDrive);

    [ id( DISPID_WMPCDROM_PLAYLIST ), propget, helpstring( "Returns the playlist of tracks currently in the CDROM drive" ) ]
        HRESULT playlist ([out, retval] IWMPPlaylist** ppPlaylist);

    [ id( DISPID_WMPCDROM_BUSY ), propget, helpstring( "Returns whether the CDROM is being used for playback or copying" ) ]
        HRESULT busy ([out, retval] BOOL *pfBusy);

    // methods
    [ id( DISPID_WMPCDROM_EJECT ), helpstring( "Eject the CD in the CDROM drive" ) ]
        HRESULT eject ();
}

[
    object,
    uuid(EE4C8FE2-34B2-11d3-A3BF-006097C9B344),
    dual,
    helpstring("IWMPCdromCollection Interface"),
    pointer_default(unique)
]
interface IWMPCdromCollection : IDispatch
{
    // properties
    [ id( DISPID_WMPCDROMCOLLECTION_COUNT ), propget, helpstring( "Returns the number of items in the cdrom collection" ) ]
        HRESULT count( [out, retval] long *plCount );

    // methods
    [ id( DISPID_WMPCDROMCOLLECTION_ITEM ), helpstring( "Returns the CDROM object at the given index" ) ]
        HRESULT item( [in] long lIndex, [out, retval] IWMPCdrom **ppItem );

    [ id( DISPID_WMPCDROMCOLLECTION_GETBYDRIVESPECIFIER ), helpstring( "Returns the CDROM object associated with a particular drive specifier, e.g. F:" ) ]
        HRESULT getByDriveSpecifier( [in] BSTR bstrDriveSpecifier, [out, retval] IWMPCdrom** ppCdrom );
}
 
//////////////////////////////////////////////////////////////////////
//          MediaCollection Interfaces
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(4a976298-8c0d-11d3-b389-00c04f68574b),
    dual,
    helpstring("IWMPStringCollection Interface"),
    pointer_default(unique)
]
interface IWMPStringCollection : IDispatch
{
    // properties
    [ id( DISPID_WMPSTRINGCOLLECTION_COUNT ), propget, helpstring( "Returns the number of items in the string collection" ) ]
        HRESULT count( [out, retval] long* plCount );
    
    // methods
    [ id( DISPID_WMPSTRINGCOLLECTION_ITEM ), helpstring( "Returns the string at the given index" ) ]
        HRESULT item( [in] long lIndex, [out, retval] BSTR* pbstrString );
}

[
    object,
    uuid(8363BC22-B4B4-4b19-989D-1CD765749DD1),
    dual,
    helpstring("IWMPMediaCollection Interface"),
    pointer_default(unique)
]
interface IWMPMediaCollection : IDispatch
{
    // methods
    [ id( DISPID_WMPMEDIACOLLECTION_ADD ), helpstring( "Creates a new media object" ) ]
        HRESULT add( [in] BSTR bstrURL, [out, retval] IWMPMedia **ppItem );
    [ id( DISPID_WMPMEDIACOLLECTION_GETALL ), helpstring( "Returns a collection of all the items" ) ]
        HRESULT getAll( [out, retval] IWMPPlaylist** ppMediaItems );
    [ id( DISPID_WMPMEDIACOLLECTION_GETBYNAME ), helpstring( "Returns a collection of items with the given name" ) ]
        HRESULT getByName( [in] BSTR bstrName, [out, retval] IWMPPlaylist **ppMediaItems );
    [ id( DISPID_WMPMEDIACOLLECTION_GETBYGENRE ), helpstring( "Returns a collection of items with the given genre" ) ]
        HRESULT getByGenre( [in] BSTR bstrGenre, [out, retval] IWMPPlaylist **ppMediaItems );
    [ id( DISPID_WMPMEDIACOLLECTION_GETBYAUTHOR ), helpstring( "Returns a collection of items by a given author" ) ]
        HRESULT getByAuthor( [in] BSTR bstrAuthor, [out, retval] IWMPPlaylist **ppMediaItems );
    [ id( DISPID_WMPMEDIACOLLECTION_GETBYALBUM ), helpstring( "Returns a collection of items from the given album" ) ]
        HRESULT getByAlbum( [in] BSTR bstrAlbum, [out, retval] IWMPPlaylist **ppMediaItems );
    [ id( DISPID_WMPMEDIACOLLECTION_GETBYATTRIBUTE ), helpstring( "Returns a collection of items with the given attribute" ) ]
        HRESULT getByAttribute( [in] BSTR bstrAttribute, [in] BSTR bstrValue, [out, retval] IWMPPlaylist **ppMediaItems );
    [ id( DISPID_WMPMEDIACOLLECTION_REMOVE ), helpstring( "Removes an item from the media collection" ) ]
        HRESULT remove( [in] IWMPMedia *pItem, [in] VARIANT_BOOL varfDeleteFile );
    [ id( DISPID_WMPMEDIACOLLECTION_GETATTRIBUTESTRINGCOLLECTION ), helpstring( "Returns the string collection associated with an attribute" ) ]
        HRESULT getAttributeStringCollection( [in] BSTR bstrAttribute, [in] BSTR bstrMediaType, [out, retval] IWMPStringCollection** ppStringCollection );
    [ id( DISPID_WMPMEDIACOLLECTION_GETMEDIAATOM ), helpstring( "Gets an atom associated with an item name which can be requested from an IWMPMedia out of this collection via getItemInfoByAtom" ) ]
        HRESULT getMediaAtom( [in] BSTR bstrItemName, [out, retval] long* plAtom);
    [ id( DISPID_WMPMEDIACOLLECTION_SETDELETED ), helpstring( "Sets the deleted flag on a media object" ) ]
        HRESULT setDeleted( [in] IWMPMedia* pItem, [in] VARIANT_BOOL varfIsDeleted );
    [ id( DISPID_WMPMEDIACOLLECTION_ISDELETED ), helpstring( "Gets the deleted flag on a media object" ) ]
        HRESULT isDeleted( [in] IWMPMedia* pItem, [out, retval] VARIANT_BOOL* pvarfIsDeleted );
}

//////////////////////////////////////////////////////////////////////
//          PlaylistCollection Interfaces
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(679409c0-99f7-11d3-9fb7-00105aa620bb),
    dual,
    helpstring("IWMPPlaylistArray Interface"),
    pointer_default(unique)
]
interface IWMPPlaylistArray : IDispatch
{
    // properties
    [ id( DISPID_WMPPLAYLISTARRAY_COUNT ), propget, helpstring( "Returns the number of items in the playlist array" ) ]
        HRESULT count( [out, retval] long *plCount );

    // methods
    [ id( DISPID_WMPPLAYLISTARRAY_ITEM ), helpstring( "Returns the playlist object at the given index" ) ]
        HRESULT item( [in] long lIndex, [out, retval] IWMPPlaylist **ppItem );
}

[
    object,
    uuid(10A13217-23A7-439b-B1C0-D847C79B7774),
    dual,
    helpstring("IWMPPlaylistCollection Interface"),
    pointer_default(unique)
]
interface IWMPPlaylistCollection : IDispatch
{
    // methods
    [ id( DISPID_WMPPLAYLISTCOLLECTION_NEWPLAYLIST ), helpstring( "Creates a new playlist object" ) ]
        HRESULT newPlaylist( [in] BSTR bstrName, [out, retval] IWMPPlaylist **ppItem );
    [ id( DISPID_WMPPLAYLISTCOLLECTION_GETALL ), helpstring( "Returns a playlist array with all the playlists" ) ]
        HRESULT getAll( [out, retval] IWMPPlaylistArray **ppPlaylistArray );
    [ id( DISPID_WMPPLAYLISTCOLLECTION_GETBYNAME ), helpstring( "Returns a playlist array with playlists matching the given name" ) ]
        HRESULT getByName( [in] BSTR bstrName, [out, retval] IWMPPlaylistArray **ppPlaylistArray );
    [ id( DISPID_WMPPLAYLISTCOLLECTION_REMOVE ), helpstring( "Removes an item from the playlist collection" ) ]
        HRESULT remove( [in] IWMPPlaylist *pItem );
    [ id( DISPID_WMPPLAYLISTCOLLECTION_SETDELETED ), helpstring( "Sets the deleted flag on a playlist object" ) ]
        HRESULT setDeleted( [in] IWMPPlaylist* pItem, [in] VARIANT_BOOL varfIsDeleted );
    [ id( DISPID_WMPPLAYLISTCOLLECTION_ISDELETED ), helpstring( "Gets the deleted flag on a playlist object" ) ]
        HRESULT isDeleted( [in] IWMPPlaylist* pItem, [out, retval] VARIANT_BOOL* pvarfIsDeleted );
    [ id( DISPID_WMPPLAYLISTCOLLECTION_IMPORTPLAYLIST ), helpstring( "Imports a playlist object into the library" ) ]
        HRESULT importPlaylist( [in] IWMPPlaylist* pItem, [out, retval] IWMPPlaylist** ppImportedItem );
}

//////////////////////////////////////////////////////////////////////
//          Network Interfaces
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(EC21B779-EDEF-462d-BBA4-AD9DDE2B29A7),
    dual,
    helpstring("IWMPNetwork Interface"),
    pointer_default(unique)
]
interface IWMPNetwork : IDispatch
{
    // properties
    [ id( DISPID_WMPNETWORK_BANDWIDTH ), propget, helpstring( "Returns the current bandwidth of the clip." ) ]
        HRESULT bandWidth( [out, retval] long *plBandwidth );
    [ id( DISPID_WMPNETWORK_RECOVEREDPACKETS ), propget, helpstring( "Returns the number of recovered packets" ) ]
        HRESULT recoveredPackets( [out, retval] long *plRecoveredPackets );
    [ id( DISPID_WMPNETWORK_SOURCEPROTOCOL ), propget, helpstring( "Returns the source protocol used to receive data." ) ]
        HRESULT sourceProtocol( [out, retval] BSTR *pbstrSourceProtocol );
    [ id( DISPID_WMPNETWORK_RECEIVEDPACKETS ), propget, helpstring( "Returns the number of packets received." ) ]
        HRESULT receivedPackets( [out, retval] long *plReceivedPackets );
    [ id( DISPID_WMPNETWORK_LOSTPACKETS ), propget, helpstring( "Returns the number of packets lost." ) ]
        HRESULT lostPackets( [out, retval] long *plLostPackets );
    [ id( DISPID_WMPNETWORK_RECEPTIONQUALITY ), propget, helpstring( "Returns the percentage of packets received in the last 15 seconds." ) ]
        HRESULT receptionQuality( [out, retval] long *plReceptionQuality );
    [ id( DISPID_WMPNETWORK_BUFFERINGCOUNT ), propget, helpstring( "Returns the number of times buffering occurred during clip playback." ) ]
        HRESULT bufferingCount( [out, retval] long *plBufferingCount );
    [ id( DISPID_WMPNETWORK_BUFFERINGPROGRESS ), propget, helpstring( "Returns the percentage of buffering completed." ) ]
        HRESULT bufferingProgress( [out, retval] long *plBufferingProgress );
    [ id( DISPID_WMPNETWORK_BUFFERINGTIME ), propget, helpstring( "Returns the number of seconds allocated for buffering for this media type." ) ]
        HRESULT bufferingTime( [out, retval] long *plBufferingTime );
    [ id( DISPID_WMPNETWORK_BUFFERINGTIME ), propput, helpstring( "Sets the amount of time in milliseconds that the player allocates for buffering incoming data." ) ]
        HRESULT bufferingTime( [in] long lBufferingTime );
    [ id( DISPID_WMPNETWORK_FRAMERATE ), propget, helpstring( "Current video frame rate in frames/second" ) ]
        HRESULT frameRate( [out, retval] long *plFrameRate );
    [ id( DISPID_WMPNETWORK_MAXBITRATE ), propget, helpstring( "Maximum possible video bit rate" ) ]
        HRESULT maxBitRate( [out, retval] long *plBitRate );
    [ id( DISPID_WMPNETWORK_BITRATE ), propget, helpstring( "Current video bit rate" ) ]
        HRESULT bitRate( [out, retval] long *plBitRate );
    [ id( DISPID_WMPNETWORK_GETPROXYSETTINGS ), helpstring( "Returns the proxy settings for the specified protocol" ) ]
        HRESULT getProxySettings( [in] BSTR bstrProtocol, [out, retval] long *plProxySetting );
    [ id( DISPID_WMPNETWORK_SETPROXYSETTINGS ), helpstring( "Sets the proxy settings for the specified protocol" ) ]
        HRESULT setProxySettings( [in] BSTR bstrProtocol, [in] long lProxySetting );
    [ id( DISPID_WMPNETWORK_GETPROXYNAME ), helpstring( "Returns the proxy name for the specified protocol" ) ]
        HRESULT getProxyName( [in] BSTR bstrProtocol, [out, retval] BSTR *pbstrProxyName );
    [ id( DISPID_WMPNETWORK_SETPROXYNAME ), helpstring( "Sets the proxy name for the specified protocol" ) ]
        HRESULT setProxyName( [in] BSTR bstrProtocol, [in] BSTR bstrProxyName );
    [ id( DISPID_WMPNETWORK_GETPROXYPORT ), helpstring( "Returns the proxy port for the specified protocol" ) ]
        HRESULT getProxyPort( [in] BSTR bstrProtocol, [out, retval] long * lProxyPort );
    [ id( DISPID_WMPNETWORK_SETPROXYPORT ), helpstring( "Sets the proxy port for the specified protocol" ) ]
        HRESULT setProxyPort( [in] BSTR bstrProtocol, [in] long lProxyPort );
    [ id( DISPID_WMPNETWORK_GETPROXYEXCEPTIONLIST ), helpstring( "Returns the proxy exception list for the specified protocol" ) ]
        HRESULT getProxyExceptionList( [in] BSTR bstrProtocol, [out, retval] BSTR *pbstrExceptionList );
    [ id( DISPID_WMPNETWORK_SETPROXYEXCEPTIONLIST ), helpstring( "Sets the proxy exception list for the specified protocol" ) ]
        HRESULT setProxyExceptionList( [in] BSTR bstrProtocol, [in] BSTR pbstrExceptionList );
    [ id( DISPID_WMPNETWORK_GETPROXYBYPASSFORLOCAL ), helpstring( "Returns whether or not to bypass the proxy for local addresses" ) ]
        HRESULT getProxyBypassForLocal( [in] BSTR bstrProtocol, [out, retval] VARIANT_BOOL *pfBypassForLocal );
    [ id( DISPID_WMPNETWORK_SETPROXYBYPASSFORLOCAL ), helpstring( "Sets whether or not to by pass the proxy for local addresses" ) ]
        HRESULT setProxyBypassForLocal( [in] BSTR bstrProtocol, [in] VARIANT_BOOL fBypassForLocal );
    [ id( DISPID_WMPNETWORK_MAXBANDWIDTH ), propget, helpstring( "Returns or sets maximum allowed bandwidth" ) ]
        HRESULT maxBandwidth( [out, retval] long * lMaxBandwidth );
    [ id( DISPID_WMPNETWORK_MAXBANDWIDTH ), propput ]
        HRESULT maxBandwidth( [in] long lMaxBandwidth );
    [ id( DISPID_WMPNETWORK_DOWNLOADPROGRESS ), propget, helpstring( "Returns the percentage of download completed." ) ]
        HRESULT downloadProgress( [out, retval] long *plDownloadProgress );
    [ id( DISPID_WMPNETWORK_ENCODEDFRAMERATE ), propget, helpstring( "Returns the video frame rate, in frames/second, that the file was encoded in" ) ]
        HRESULT encodedFrameRate( [out, retval] long *plFrameRate );
    [ id( DISPID_WMPNETWORK_FRAMESSKIPPED ), propget, helpstring( "Returns the number of skipped frames" ) ]
        HRESULT framesSkipped( [out, retval] long *plFrames );
}
 
//////////////////////////////////////////////////////////////////////
//          DVD Interfaces
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(8DA61686-4668-4a5c-AE5D-803193293DBE),
    dual,
    helpstring("IWMPDVD Interface"),
    pointer_default(unique)
]
interface IWMPDVD : IDispatch
{
    [ id( DISPID_WMPDVD_ISAVAILABLE ), propget, helpstring( "Returns whether or not the specified DVD functionality is available" ) ]
        HRESULT isAvailable( [in] BSTR bstrItem, [out, retval] VARIANT_BOOL *pIsAvailable );
    [ id( DISPID_WMPDVD_DOMAIN ), propget, helpstring( "Returns the current DVD domain" ) ]
        HRESULT domain( [out, retval] BSTR * strDomain );
    [ id( DISPID_WMPDVD_TOPMENU ), helpstring( "Displays the top menu of the DVD" ) ]
        HRESULT topMenu();
    [ id( DISPID_WMPDVD_TITLEMENU ), helpstring( "Displays the title menu of the current DVD title" ) ]
        HRESULT titleMenu();
    [ id( DISPID_WMPDVD_BACK ), helpstring( "Navigates back one menu" ) ]
        HRESULT back();
    [ id( DISPID_WMPDVD_RESUME ), helpstring( "Removes the menu from the screen and returns to playing the DVD" ) ]
        HRESULT resume();
}

//////////////////////////////////////////////////////////////////////
//          Core Interfaces
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(D84CCA99-CCE2-11d2-9ECC-0000F8085981),
    dual,
    helpstring("IWMPCore Interface"),
    pointer_default(unique)
]
interface IWMPCore : IDispatch
{
    // methods

    [ id(DISPID_WMPCORE_CLOSE), helpstring("Closes the media") ]
        HRESULT close();

    // properties

    [ id( DISPID_WMPCORE_URL ), propget, helpstring( "Returns or sets the URL" ) ]
        HRESULT URL( [out, retval] BSTR *pbstrURL );
    [ id( DISPID_WMPCORE_URL ), propput ]
        HRESULT URL( [in] BSTR bstrURL );
    [ id( DISPID_WMPCORE_OPENSTATE ), propget, helpstring( "Returns the open state of the player" ) ]
        HRESULT openState( [out, retval] WMPOpenState *pwmpos );
    [ id( DISPID_WMPCORE_PLAYSTATE ), propget, helpstring( "Returns the play state of the player" ) ]
        HRESULT playState( [out, retval] WMPPlayState *pwmpps );
    [ id(DISPID_WMPCORE_CONTROLS), propget, helpstring("Returns the control handler")]
        HRESULT controls([out, retval] IWMPControls **ppControl);
    [ id(DISPID_WMPCORE_SETTINGS), propget, helpstring("Returns the settings handler")]
        HRESULT settings([out, retval] IWMPSettings **ppSettings);
    [ id(DISPID_WMPCORE_CURRENTMEDIA), propget, helpstring("Returns or sets the current media object")]
        HRESULT currentMedia([out, retval] IWMPMedia **ppMedia);
    [ id(DISPID_WMPCORE_CURRENTMEDIA), propput]
        HRESULT currentMedia([in] IWMPMedia *pMedia);
    [ id(DISPID_WMPCORE_MEDIACOLLECTION), propget, helpstring("Returns the media collection handler")]
        HRESULT mediaCollection([out, retval] IWMPMediaCollection **ppMediaCollection);
    [ id(DISPID_WMPCORE_PLAYLISTCOLLECTION), propget, helpstring("Returns the playlist collection handler")]
        HRESULT playlistCollection([out, retval] IWMPPlaylistCollection **ppPlaylistCollection);
    [ id( DISPID_WMPCORE_VERSIONINFO ), propget, helpstring( "Returns the version information for the player" ) ]
        HRESULT versionInfo( [out, retval] BSTR * pbstrVersionInfo );

    [id ( DISPID_WMPCORE_LAUNCHURL)]
        HRESULT launchURL(BSTR bstrURL);

    [propget, id(DISPID_WMPCORE_NETWORK), helpstring("Returns the network information handler")]
        HRESULT network([out, retval] IWMPNetwork **ppQNI);
    [ id( DISPID_WMPCORE_CURRENTPLAYLIST), propget, helpstring( "Returns/sets the current playlist" ) ]
        HRESULT currentPlaylist( [out, retval] IWMPPlaylist **ppPL );
    [ id( DISPID_WMPCORE_CURRENTPLAYLIST), propput, helpstring( "Returns the playlist handler" ) ]
        HRESULT currentPlaylist( [in] IWMPPlaylist *pPL );
    [ id( DISPID_WMPCORE_CDROMCOLLECTION ), propget, helpstring("Get the CDROM drive collection") ]
        HRESULT cdromCollection ([out, retval] IWMPCdromCollection** ppCdromCollection);
    [ id(DISPID_WMPCORE_CLOSEDCAPTION), propget, helpstring("Returns the closed caption handler")]
        HRESULT closedCaption([out, retval] IWMPClosedCaption **ppClosedCaption);
    [ id(DISPID_WMPCORE_ISONLINE), propget, helpstring( "Returns whether the machine is online." ) ]
        HRESULT isOnline( [out, retval] VARIANT_BOOL *pfOnline );
    [ id(DISPID_WMPCORE_ERROR), propget, helpstring("Returns the error object")]
        HRESULT error([out, retval] IWMPError **ppError);
    [ id(DISPID_WMPCORE_STATUS), propget, helpstring("Returns status string")]
        HRESULT status([out, retval] BSTR *pbstrStatus);
}

[
    object,
    uuid(BC17E5B7-7561-4c18-BB90-17D485775659),
    dual,
    helpstring("IWMPCore2 Interface"),
    pointer_default(unique)
]
interface IWMPCore2 : IWMPCore
{
    [ id(DISPID_WMPCORE2_DVD), propget, helpstring("Returns the DVD handler")]
        HRESULT dvd([out, retval] IWMPDVD ** ppDVD);
}


//////////////////////////////////////////////////////////////////////
//          Player Interfaces
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(6BF52A4F-394A-11d3-B153-00C04F79FAA6),
    dual,
    helpstring("IWMPPlayer Interface"),
    pointer_default(unique)
]
interface IWMPPlayer : IWMPCore
{
    [ id(DISPID_WMPOCX_ENABLED), propget, helpstring("Returns a boolen value specifying whether or not the control is enabled")]
        HRESULT enabled([out, retval] VARIANT_BOOL *pbEnabled);
    [ id(DISPID_WMPOCX_ENABLED), propput, helpstring("Sets a boolean value specifying whether or not the control is enabled")]
        HRESULT enabled([in] VARIANT_BOOL bEnabled);
    [ id(DISPID_WMPOCX_FULLSCREEN), propget, helpstring("Returns a boolean value specifying whether or not the control is in full screen mode")]
        HRESULT fullScreen([out, retval] VARIANT_BOOL *pbFullScreen);
    [ id(DISPID_WMPOCX_FULLSCREEN), propput, helpstring("Sets a boolean value specifying whether or not the control is in full screen mode")]
        HRESULT fullScreen(VARIANT_BOOL bFullScreen);
    [ id(DISPID_WMPOCX_ENABLECONTEXTMENU), propget, helpstring("Returns a boolean value specifying whether or not the context menu is enabled on the control")]
        HRESULT enableContextMenu([out, retval] VARIANT_BOOL *pbEnableContextMenu);
    [ id(DISPID_WMPOCX_ENABLECONTEXTMENU), propput, helpstring("Sets a boolean value specifying whether or not the context menu is enabled on the control")]
        HRESULT enableContextMenu(VARIANT_BOOL bEnableContextMenu);
    [ id(DISPID_WMPOCX_UIMODE), propput, helpstring("Specifies the ui mode to select")]
        HRESULT uiMode([in] BSTR bstrMode);
    [ id(DISPID_WMPOCX_UIMODE), propget, helpstring("Returns the currently selected ui mode")]
        HRESULT uiMode([out, retval] BSTR *pbstrMode);
}

[
    object,
    uuid(4F6F41BA-E776-433b-B409-C63D16382D26),
    dual,
    helpstring("IWMPPlayer2 Interface"),
    pointer_default(unique)
]
interface IWMPPlayer2 : IWMPCore2
{
    [ id(DISPID_WMPOCX_ENABLED), propget, helpstring("Returns a boolen value specifying whether or not the control is enabled")]
        HRESULT enabled([out, retval] VARIANT_BOOL *pbEnabled);
    [ id(DISPID_WMPOCX_ENABLED), propput, helpstring("Sets a boolean value specifying whether or not the control is enabled")]
        HRESULT enabled([in] VARIANT_BOOL bEnabled);
    [ id(DISPID_WMPOCX_FULLSCREEN), propget, helpstring("Returns a boolean value specifying whether or not the control is in full screen mode")]
        HRESULT fullScreen([out, retval] VARIANT_BOOL *pbFullScreen);
    [ id(DISPID_WMPOCX_FULLSCREEN), propput, helpstring("Sets a boolean value specifying whether or not the control is in full screen mode")]
        HRESULT fullScreen(VARIANT_BOOL bFullScreen);
    [ id(DISPID_WMPOCX_ENABLECONTEXTMENU), propget, helpstring("Returns a boolean value specifying whether or not the context menu is enabled on the control")]
        HRESULT enableContextMenu([out, retval] VARIANT_BOOL *pbEnableContextMenu);
    [ id(DISPID_WMPOCX_ENABLECONTEXTMENU), propput, helpstring("Sets a boolean value specifying whether or not the context menu is enabled on the control")]
        HRESULT enableContextMenu(VARIANT_BOOL bEnableContextMenu);
    [ id(DISPID_WMPOCX_UIMODE), propput, helpstring("Specifies the ui mode to select")]
        HRESULT uiMode([in] BSTR bstrMode);
    [ id(DISPID_WMPOCX_UIMODE), propget, helpstring("Returns the currently selected ui mode")]
        HRESULT uiMode([out, retval] BSTR *pbstrMode);
    [ id(DISPID_WMPOCX2_STRETCHTOFIT), propget, helpstring("Returns a boolen value specifying whether or not video is stretched")]
        HRESULT stretchToFit([out, retval] VARIANT_BOOL *pbEnabled);
    [ id(DISPID_WMPOCX2_STRETCHTOFIT), propput, helpstring("Sets a boolean value specifying whether or not video is stretched")]
        HRESULT stretchToFit([in] VARIANT_BOOL bEnabled);
    [ id(DISPID_WMPOCX2_WINDOWLESSVIDEO), propget, helpstring("Returns a boolen value specifying whether or not video is windowless")]
        HRESULT windowlessVideo([out, retval] VARIANT_BOOL *pbEnabled);
    [ id(DISPID_WMPOCX2_WINDOWLESSVIDEO), propput, helpstring("Sets a boolean value specifying whether or not video is windowless")]
        HRESULT windowlessVideo([in] VARIANT_BOOL bEnabled);
}

[
    object,
    uuid(632FB7B5-4A7B-432d-AC3A-ABE771D600B2),
    helpstring("IWMPLaunch Interface"),
    pointer_default(unique)
]
interface IWMPLaunch : IUnknown
{
    [helpstring("Launches Windows Media Player to play the currently playing content")]
    HRESULT launchPlayer();
}


//////////////////////////////////////////////////////////////////////
//          WMP OCX Object
//////////////////////////////////////////////////////////////////////

[
    uuid(6BF52A50-394A-11d3-B153-00C04F79FAA6),
    version(1.0),
    helpstring("Windows Media Player OCX")
]
library WMPOCX
{
    importlib("stdole32.tlb");
    importlib("stdole2.tlb");

    [
        uuid(6BF52A51-394A-11d3-B153-00C04F79FAA6),
        helpstring("Event interface for Windows Media Player OCX"),
        hidden
    ]
    dispinterface _WMPOCXEvents
    {
        properties:
        methods:

        //////////////////////////////////////////////////////////////////////
        //      Events
        //////////////////////////////////////////////////////////////////////

        // Graph creation
        [ id( DISPID_WMPCOREEVENT_OPENSTATECHANGE ), helpstring( "Sent when the control changes OpenState" ) ]
            void OpenStateChange( [in] long NewState );

        // control
        [ id( DISPID_WMPCOREEVENT_PLAYSTATECHANGE ), helpstring( "Sent when the control changes PlayState" ) ]
            void PlayStateChange( [in] long NewState );

        // content
        [ id( DISPID_WMPCOREEVENT_SCRIPTCOMMAND ), helpstring( "Sent when a synchronized command or URL is received" ) ]
            void ScriptCommand( [in] BSTR scType, [in] BSTR Param );

        // network
        [ id( DISPID_WMPCOREEVENT_NEWSTREAM ), helpstring( "Sent when a new stream is started in a channel" ) ]
            void NewStream();
        [ id( DISPID_WMPCOREEVENT_DISCONNECT ), helpstring( "Sent when the control is disconnected from the server" ) ]
            void Disconnect( [in] long Result );

        [ id( DISPID_WMPCOREEVENT_BUFFERING ), helpstring( "Sent when the control begins or ends buffering" ) ]
            void Buffering( [in] VARIANT_BOOL Start );

        // error
        [ id( DISPID_WMPCOREEVENT_ERROR ), helpstring( "Sent when the control has an error condition" ) ]
            void Error();

        [ id( DISPID_WMPCOREEVENT_MEDIAERROR ), helpstring( "Sent when the media object has an error condition" ) ]
            void MediaError( [in] IDispatch * pMediaObject);

        // warning
        [ id( DISPID_WMPCOREEVENT_WARNING ), helpstring( "Sent when the control encounters a problem" ) ]
            void Warning( [in] long WarningType, [in] long Param, [in] BSTR Description );


        // seek
        [ id( DISPID_WMPCOREEVENT_ENDOFSTREAM ), helpstring( "Sent when the end of file is reached" ) ]
            void EndOfStream( [in] long Result );
        [id(DISPID_WMPCOREEVENT_POSITIONCHANGE), helpstring("Indicates that the current position of the movie has changed")]
            void PositionChange([in] double oldPosition, [in] double newPosition);

        [ id( DISPID_WMPCOREEVENT_MARKERHIT ), helpstring( "Sent when a marker is reached" ) ]
            void MarkerHit( [in] long MarkerNum );

        [id(DISPID_WMPCOREEVENT_DURATIONUNITCHANGE), helpstring("Indicates that the unit used to express duration and position has changed")]
            void DurationUnitChange(long NewDurationUnit);

        // cdrom
        [id(DISPID_WMPCOREEVENT_CDROMMEDIACHANGE), helpstring("Indicates that the CD ROM media has changed") ]
                void CdromMediaChange( [in] long CdromNum );

        // playlist
        [id(DISPID_WMPCOREEVENT_PLAYLISTCHANGE), helpstring("Sent when a playlist changes") ]
                void PlaylistChange( [in] IDispatch * Playlist, [in] WMPPlaylistChangeEventType change );
                
        [id(DISPID_WMPCOREEVENT_CURRENTPLAYLISTCHANGE), helpstring("Sent when the current playlist changes") ]
                void CurrentPlaylistChange( [in] WMPPlaylistChangeEventType change );
        [id(DISPID_WMPCOREEVENT_CURRENTPLAYLISTITEMAVAILABLE), helpstring("Sent when a current playlist item becomes available") ]
                void CurrentPlaylistItemAvailable(BSTR bstrItemName);
        [id(DISPID_WMPCOREEVENT_MEDIACHANGE), helpstring("Sent when a media object changes") ]
                void MediaChange( [in] IDispatch * Item);
        [id(DISPID_WMPCOREEVENT_CURRENTMEDIAITEMAVAILABLE), helpstring("Sent when a current media item becomes available") ]
                void CurrentMediaItemAvailable(BSTR bstrItemName);
        [id(DISPID_WMPCOREEVENT_CURRENTITEMCHANGE), helpstring("Sent when the item selection on the current playlist changes") ]
                void CurrentItemChange( [in] IDispatch *pdispMedia);
        [id(DISPID_WMPCOREEVENT_MEDIACOLLECTIONCHANGE), helpstring("Sent when the media collection needs to be requeried") ]
                void MediaCollectionChange();
        [id(DISPID_WMPCOREEVENT_MEDIACOLLECTIONATTRIBUTESTRINGADDED), helpstring("Sent when an attribute string is added in the media collection") ]
                void MediaCollectionAttributeStringAdded(BSTR bstrAttribName, BSTR bstrAttribVal);
        [id(DISPID_WMPCOREEVENT_MEDIACOLLECTIONATTRIBUTESTRINGREMOVED), helpstring("Sent when an attribute string is removed from the media collection") ]
                void MediaCollectionAttributeStringRemoved(BSTR bstrAttribName, BSTR bstrAttribVal);
        [id(DISPID_WMPCOREEVENT_PLAYLISTCOLLECTIONCHANGE), helpstring("Sent when playlist collection needs to be requeried") ]
                void PlaylistCollectionChange();
        [id(DISPID_WMPCOREEVENT_PLAYLISTCOLLECTIONPLAYLISTADDED), helpstring("Sent when a playlist is added to the playlist collection") ]
                void PlaylistCollectionPlaylistAdded([in] BSTR bstrPlaylistName);
        [id(DISPID_WMPCOREEVENT_PLAYLISTCOLLECTIONPLAYLISTREMOVED), helpstring("Sent when a playlist is removed from the playlist collection") ]
                void PlaylistCollectionPlaylistRemoved([in] BSTR bstrPlaylistName);
        [id(DISPID_WMPCOREEVENT_PLAYLISTCOLLECTIONPLAYLISTSETASDELETED), helpstring("Sent when a playlist has been set or reset as deleted")]
                void PlaylistCollectionPlaylistSetAsDeleted([in] BSTR bstrPlaylistName, [in] VARIANT_BOOL varfIsDeleted);
        [id(DISPID_WMPCOREEVENT_MODECHANGE), helpstring("Playlist playback mode has changed")]
                void ModeChange([in] BSTR ModeName, [in] VARIANT_BOOL NewValue);
        [id(DISPID_WMPCOREEVENT_OPENPLAYLISTSWITCH), helpstring("Current playlist switch with no open state change") ]
                void OpenPlaylistSwitch( [in] IDispatch *pItem );

        // dvd
        [ id( DISPID_WMPCOREEVENT_DOMAINCHANGE ), helpstring( "Send a current domain" ) ]
                void DomainChange([in] BSTR strDomain);                

    }; 

    [
        uuid(6BF52A52-394A-11d3-B153-00C04F79FAA6),
        helpstring("Windows Media Player OCX")
    ]
    coclass WMPOCX
    {
        [default] interface IWMPPlayer;
        interface IWMPPlayer2;
        interface IWMPControls;
        interface IWMPSettings;
        interface IWMPPlaylist;
        interface IWMPMedia;
        interface IWMPMediaCollection;
        interface IWMPPlaylistCollection;
        interface IWMPCdromCollection;
        interface IWMPError;
        interface IWMPErrorItem;
        interface IWMPClosedCaption;
        interface IWMPDVD;
        interface IWMPControls2;
        interface IWMPMedia2;
        [default, source] dispinterface _WMPOCXEvents;

    };

};

//*****************************************************************************
//
//  End of File
//
//*****************************************************************************

