//+---------------------------------------------------------------------
//
//   File:      element.cxx
//
//  Contents:   Element class
//
//  Classes:    CElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ASSOC_HXX_
#define X_ASSOC_HXX_
#include "assoc.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_CGUID_H_
#define X_CGUID_H_
#include "cguid.h"
#endif

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_SCRIPT_HXX_
#define X_SCRIPT_HXX_
#include "script.hxx"
#endif

#ifndef X_CFPF_HXX_
#define X_CFPF_HXX_
#include "cfpf.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_HTMTAGS_HXX_
#define X_HTMTAGS_HXX_
#include "htmtags.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X__DOC_H_
#define X__DOC_H_
#include "_doc.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_EANCHOR_HXX_
#define X_EANCHOR_HXX_
#include "eanchor.hxx"
#endif

#ifndef X_ELABEL_HXX_
#define X_ELABEL_HXX_
#include "elabel.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_DISPEX_H_
#define X_DISPEX_H_
#include "dispex.h"
#endif

#ifndef X_EVENTOBJ_HXX_
#define X_EVENTOBJ_HXX_
#include "eventobj.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif


#ifndef X_EBODY_HXX_
#define X_EBODY_HXX_
#include "ebody.hxx"    // for body's dispids
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_MISCPROT_H_
#define X_MISCPROT_H_
#include "miscprot.h"
#endif

#ifndef X_FILTCOL_HXX_
#define X_FILTCOL_HXX_
#include "filtcol.hxx"
#endif

#ifndef X_OCIDL_H_
#define X_OCIDL_H_
#include <ocidl.h>
#endif

#ifndef X_SAFETY_HXX_
#define X_SAFETY_HXX_
#include "safety.hxx"
#endif

#ifndef X_SHOLDER_HXX_
#define X_SHOLDER_HXX_
#include "sholder.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_PEERMGR_HXX_
#define X_PEERMGR_HXX_
#include "peermgr.hxx"
#endif

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif

#ifndef X_HTC_HXX_
#define X_HTC_HXX_
#include "htc.hxx"
#endif

#ifndef X_SHAPE_HXX_
#define X_SHAPE_HXX_
#include "shape.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_GENERIC_HXX_
#define X_GENERIC_HXX_
#include "generic.hxx"
#endif

#ifndef X_EXTDL_HXX_
#define X_EXTDL_HXX_
#include "extdl.hxx"
#endif

// Note - The enums in types are defined in this file

#ifndef X_STRING_H_
#define X_STRING_H_
#include "string.h"
#endif

#ifndef X_HTMTAGS_HXX_
#define X_HTMTAGS_HXX_
#include "htmtags.hxx"
#endif

#if defined(_M_ALPHA)
#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif
#endif

#ifndef X_MSHTMDID_H_
#define X_MSHTMDID_H_
#include "mshtmdid.h"
#endif

#ifndef X_IEXTAG_HXX_
#define X_IEXTAG_HXX_
#include "iextag.h"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_DMEMBMGR_HXX_
#define X_DMEMBMGR_HXX_
#include <dmembmgr.hxx>       // for CDataMemberMgr
#endif

#ifndef X_ACCHDRS_HXX_
#define X_ACCHDRS_HXX_
#include "acchdrs.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_EFORM_HXX_
#define X_EFORM_HXX_
#include "eform.hxx"
#endif

#ifndef X_EOBJECT_HXX_
#define X_EOBJECT_HXX_
#include "eobject.hxx"
#endif

#ifndef X_XMLNS_HXX_
#define X_XMLNS_HXX_
#include "xmlns.hxx"
#endif

#ifndef X_AVUNDO_HXX_
#define X_AVUNDO_HXX_
#include "avundo.hxx"
#endif

#ifndef X_DXTRANS_H_
#define X_DXTRANS_H_
#include "dxtrans.h"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_COMMENT_HXX
#define X_COMMENT_HXX
#include "comment.hxx"
#endif

#ifdef UNIX
#include "mainwin.h"
extern "C" HANDLE MwGetPrimarySelectionData();
#include "quxcopy.hxx"
#endif

#ifndef X_LOGMGR_HXX_
#define X_LOGMGR_HXX_
#include "logmgr.hxx"
#endif

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

BEGIN_TEAROFF_TABLE(CElement, IProvideMultipleClassInfo)
    TEAROFF_METHOD(super, GetClassInfo, getclassinfo, (ITypeInfo ** ppTI))
    TEAROFF_METHOD(super, GetGUID, getguid, (DWORD dwGuidKind, GUID * pGUID))
    TEAROFF_METHOD(CElement, GetMultiTypeInfoCount, getmultitypeinfocount, (ULONG *pcti))
    TEAROFF_METHOD(CElement, GetInfoOfIndex, getinfoofindex, (ULONG iti, DWORD dwFlags, ITypeInfo** pptiCoClass, DWORD* pdwTIFlags, ULONG* pcdispidReserved, IID* piidPrimary, IID* piidSource))
END_TEAROFF_TABLE()

MtDefine(Elements, Mem, "Elements")
MtDefine(CElementCLock, Locals, "CElement::CLock")
MtDefine(CElementHitTestPoint_aryRects_pv, Locals, "CElement::HitTestPoint aryRects::_pv")
MtDefine(CElementHitTestPoint_aryElements_pv, Locals, "CElement::HitTestPoint aryElements::_pv")
MtDefine(CElementGetElementRc_aryRects_pv, Locals, "CElement::GetElementRc aryRects::_pv")

MtDefine(CMessage, Locals, "CMessage")

MtDefine(CLayoutAry_aryLE_pv, Layout, "CLayoutAry::_aryLE::_pv")

#define _cxx_
#include "types.hdl"

#define _cxx_
#include "element.hdl"

DeclareTag(tagNotifyZChange,       "Notify: ZChange", "Trace ELEMENT_ZCHANGE notification");
DeclareTagOther(tagFormatTooltips, "Format", "Show format indices with tooltips");
ExternTag(tagDisableLockAR);

ExternTag(tagHtmSrcTest);

class CAnchorElement;

// Each property which has a url image has an associated internal property
// which holds the cookie for the image stored in the cache.

static const struct {
    DISPID propID;          // url image property
    DISPID cacheID;         // internal cookie property
}

// make sure that DeleteImageCtx is modified, if any dispid's
// are added to this array
s_aryImgDispID[] = {
    { DISPID_A_BACKGROUNDIMAGE, DISPID_A_BGURLIMGCTXCACHEINDEX },
    { DISPID_A_LISTSTYLEIMAGE,  DISPID_A_LIURLIMGCTXCACHEINDEX },
    { DISPID_A_BACKGROUNDIMAGE, DISPID_A_BGURLIMGCTXCACHEINDEX_FLINE },
    { DISPID_A_BACKGROUNDIMAGE, DISPID_A_BGURLIMGCTXCACHEINDEX_FLETTER }
};

extern "C" const IID IID_DataSource;

BEGIN_TEAROFF_TABLE_(CElement, IServiceProvider)
        TEAROFF_METHOD(CElement, QueryService, queryservice, (REFGUID guidService, REFIID riid, void **ppvObject))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_(CElement, IRecalcProperty)
    TEAROFF_METHOD(CElement, GetCanonicalProperty, getcanonicalproperty, (DISPID dispid, IUnknown **ppUnk, DISPID *pdispid))
END_TEAROFF_TABLE()

//  Default property page list for elements that don't have their own.
//  This gives them the allpage by default.

#ifndef NO_PROPERTY_PAGE
const CLSID * const CElement::s_apclsidPages[] =
{
    // Browse-time pages
    NULL,
    // Edit-time pages
#if DBG==1
    &CLSID_CCDGenericPropertyPage,
    &CLSID_CInlineStylePropertyPage,
#endif // DBG==1
    NULL
};
#endif // NO_PROPERTY_PAGE

class CControlledFormatter
{
public:
    CControlledFormatter(CElement *pElement, DISPID dispid, DWORD dwFlags);
    ~CControlledFormatter();
    BOOL Init(HRESULT *phr);

    CLayout *GetUpdatedNearestLayout() const { ok(); return _pNearestLayout; }
    CLayoutInfo *GetUpdatedNearestLayoutInfo() const { ok(); return _pNearestLayoutInfo;}
    BOOL HadLayoutBeforeFormatsChange() const { return _fHadLayoutBeforeFormatsChange; }
    BOOL HasLayoutAfterFormatsChange() const { ok(); return _fHasLayoutAfterFormatsChange; }
    BOOL ShouldComputeFormats() { Assert(_fInited); return _fShouldComputeFormatsForDISPID; }
    
private:
    BOOL ShouldComputeFormatsForDISPID();
    HRESULT SetupToComputeFormats();
    BOOL SendZNotification();
    
#if DBG==1
    VOID ok() const
    {
        AssertSz(_fInited, "Not initialized yet!");
        AssertSz(_fShouldComputeFormatsForDISPID, "Calling compute formats during OPP incorrectly");
    }
#else
    VOID ok() const {}
#endif
    
private:
    CElement  *_pElement;
    CTreeNode *_pNode;
    DISPID     _dispid;
    DWORD      _dwFlags;
    
    WHEN_DBG(BOOL      _fInited;)

    // Following not valid before we call Init
    BOOL         _fHadLayoutBeforeFormatsChange;
    BOOL         _fShouldComputeFormatsForDISPID;
    BOOL         _fHasLayoutAfterFormatsChange;
    CLayoutInfo *_pNearestLayoutInfo;
    CLayout     *_pNearestLayout;
};

typedef void (CALLBACK* NOTIFYWINEVENTPROC)(UINT, HWND, LONG, LONG);
extern NOTIFYWINEVENTPROC g_pfnNotifyWinEvent;
extern CAccBase * GetAccObjOfElement( CElement* pElem );

//+------------------------------------------------------------------------
//
//  Class:     CMessage
//
//-------------------------------------------------------------------------

DWORD
FormsGetKeyState()
{
    static int vk[] =
    {
        VK_LBUTTON,     // MK_LBUTTON = 0x0001
        VK_RBUTTON,     // MK_RBUTTON = 0x0002
        VK_SHIFT,       // MK_SHIFT   = 0x0004
        VK_CONTROL,     // MK_CONTROL = 0x0008
        VK_MBUTTON,     // MK_MBUTTON = 0x0010
        VK_MENU,        // MK_ALT     = 0x0020
    };

    DWORD dwKeyState = 0;

    for (int i = 0; i < ARRAY_SIZE(vk); i++)
    {
        if (GetKeyState(vk[i]) & 0x8000)
        {
            dwKeyState |= (1 << i);
        }
    }

    return dwKeyState;
}

void
CMessage::CommonCtor()
{
    memset(this, 0, sizeof(*this));
    dwKeyState = FormsGetKeyState();
    resultsHitTest._cpHit = -1;
    pLayoutContext = GUL_USEFIRSTLAYOUT;
}

CMessage::CMessage(const MSG * pmsg)
{
    CommonCtor();
    if (pmsg)
    {
        memcpy(this, pmsg, sizeof(MSG));
        htc = HTC_YES;
    }
}


CMessage::CMessage(
    HWND hwndIn,
    UINT msg,
    WPARAM wParamIn,
    LPARAM lParamIn)
{
    CommonCtor();
    hwnd      = hwndIn;
    message   = msg;
    wParam    = wParamIn;
    lParam    = lParamIn;
    htc       = HTC_YES;
    time      = GetMessageTime();
    DWORD  dw = GetMessagePos();
    MSG::pt.x = (short)LOWORD(dw);
    MSG::pt.y = (short)HIWORD(dw);

    Assert(!fEventsFired);
    Assert(!fSelectionHMCalled);
}

CMessage::~CMessage()
{
    // NEWTREE: same subref note here
    Verify( !CTreeNode::ReplacePtr(&pNodeHit, NULL) );
}

//+---------------------------------------------------------------------------
//
// Member : CMessage : SetNodeHit
//
//  Synopsis : things like the tracker cache the message and then access it
//  on a timer callback. inorder to ensure that the elements that are in the
//  message are still there, we need to sub(?) addref the element.
//
//----------------------------------------------------------------------------

HRESULT
CMessage::SetNodeHit( CTreeNode * pNodeHitIn )
{
    // NEWTREE: same subref note here
    RRETURN( CTreeNode::ReplacePtr( &pNodeHit, pNodeHitIn ) );
}

//+-----------------------------------------------------------------------------
//
//  Member : CMessage::SetElementClk
//
//  Synopsis : consolidating the click firing code requires a helper function
//      to set the click element member of the message structure.
//              this function should only be called from handling a mouse buttonup
//      event message which could fire off a click (i.e. LButton only)
//
//------------------------------------------------------------------------------
void
CMessage::SetNodeClk( CTreeNode * pNodeClkIn )
{
    CTreeNode * pNodeDown = NULL;

    Assert(pNodeClkIn && !pNodeClk || pNodeClkIn == pNodeClk);

    // get the element that this message is related to or if there
    // isn't one use the pointer passed in
    pNodeClk = (pNodeHit) ? pNodeHit : pNodeClkIn;

    Assert( pNodeClk );

    // if this is not a LButtonUP just return, using the value
    // set (i.e. we do not need to look for a common ancester)
    if ( message != WM_LBUTTONUP)
    {
        return;
    }

    // now go get the _pEltGotButtonDown from the doc and look for
    // the first common ancester between the two. this is the lowest
    // element that the mouse went down and up over.
    pNodeDown = pNodeClk->Element()->Doc()->_pNodeGotButtonDown;

    if (!pNodeDown)
    {
        // Button down was not on this doc, or cleared due to capture.
        // so this is not a click
        pNodeClk = NULL;
    }
    else
    {
        // Convert both nodes from from slave to master before comparison
        if (pNodeDown->Element()->HasMasterPtr())
        {
            pNodeDown = pNodeDown->Element()->GetMasterPtr()->GetFirstBranch();
        }
        if (pNodeClk->Element()->HasMasterPtr())
        {
            pNodeClk = pNodeClk->Element()->GetMasterPtr()->GetFirstBranch();
        }

        if (!pNodeDown)
            pNodeClk = NULL;
        if (!pNodeClk)
            return;

        if (pNodeDown != pNodeClk)
        {
            if (!pNodeDown->Element()->TestClassFlag(CElement::ELEMENTDESC_NOANCESTORCLICK))
            {
                // The mouse up is on a different element than us.  This
                // can only happen if someone got capture and
                // forwarded the message to us.  Now we find the first
                // common anscestor and fire the click event from
                // there.
                pNodeClk = pNodeDown->GetFirstCommonAncestor(pNodeClk, NULL);
            }
            else
                pNodeClk = NULL;
        }
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::CElement
//
//-------------------------------------------------------------------------

CElement::CElement (ELEMENT_TAG etag, CDoc *pDoc)
#if DBG == 1 || defined(DUMPTREE)
    : _nSerialNumber( CTreeNode::s_NextSerialNumber++ )
#endif
{
    _pDoc = pDoc;
    WHEN_DBG( _pDocDbg = pDoc );
    pDoc->SubAddRef();

    Assert( pDoc && pDoc->AreLookasidesClear( this, LOOKASIDE_ELEMENT_NUMBER ) );
    Assert( pDoc->AreLookasides2Clear( this, LOOKASIDE2_ELEMENT_NUMBER ) );

    IncrementObjectCount(&_dwObjCnt);

     _etag = etag;
     WHEN_DBG( _etagDbg = etag );
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::~CElement
//
//-------------------------------------------------------------------------

CElement::~CElement()
{
    // NOTE:  Please cleanup in Passivate() if at all possible.
    //        Thread local storage can be deleted by the time this runs.
    Assert(!IsInMarkup());
}


//+------------------------------------------------------------------------
//
//  Member:     CElement::CLock::CLock
//
//  Synopsis:   Lock resources in CElement object.
//
//-------------------------------------------------------------------------

CElement::CLock::CLock(CElement *pElement, ELEMENTLOCK_FLAG enumLockFlags)
{
    Assert(enumLockFlags < (1 <<(sizeof(_wLockFlags)*8) ));//USHRT_MAX);

#if DBG==1
    extern BOOL g_fDisableBaseTrace;
    g_fDisableBaseTrace = TRUE;
#endif

    _pElement = pElement;
    if (_pElement)
    {
        _wLockFlags = pElement->_wLockFlags;
        pElement->_wLockFlags |= (WORD) enumLockFlags;
#if DBG==1
        if (!IsTagEnabled(tagDisableLockAR))
#endif
        {
            pElement->PrivateAddRef();
        }
    }

#if DBG==1
    g_fDisableBaseTrace = FALSE;
#endif

}


//+------------------------------------------------------------------------
//
//  Member:     CElement::CLock::~CLock
//
//  Synopsis:   Unlock resources in CElement object.
//
//-------------------------------------------------------------------------

CElement::CLock::~CLock()
{
#if DBG==1
    extern BOOL g_fDisableBaseTrace;
    g_fDisableBaseTrace = TRUE;
#endif

    if (_pElement)
    {
        _pElement->_wLockFlags = _wLockFlags;
#if DBG==1
        if (!IsTagEnabled(tagDisableLockAR))
#endif
        {
            _pElement->PrivateRelease();
        }
    }

#if DBG==1
    g_fDisableBaseTrace = FALSE;
#endif

}

//+------------------------------------------------------------------------
//
//  Member:     Passivate
//
//-------------------------------------------------------------------------

void
CElement::Passivate()
{
    CDoc * pDoc = Doc();

    // If we are in a tree, the tree will keep us alive
    Assert(!IsInMarkup());

    // Make sure we aren't on some delay release list somewhere
    Assert(!_fDelayRelease);

    // If we are passivating the current element (can only be the root), set it to NULL
    if (this == pDoc->_pElemCurrent)
    {
        Assert(Tag() == ETAG_ROOT);   // needed because ROOT doesn't get ExitTree
        pDoc->_pElemCurrent = NULL;
    }

    // Make sure we don't have any pending event tasks on the view
    if (_fHasPendingEvent)
    {
        pDoc->GetView()->RemoveEventTasks(this);
    }

    Assert(!HasMasterPtr());

    // Destroy slave markup, if any
    if (HasSlavePtr())
    {
        CElement * pElemSlave = DelSlavePtr();

        pElemSlave->DelMasterPtr();
        pElemSlave->Release();
    }

    if (HasPeerHolder())
    {
#if DBG == 1
        if (HasIdentityPeerHolder())
        {
            Assert (GetIdentityPeerHolder()->_ulRefs == 1);
        }
#endif
        // delete peer holder ptr and release the peer holder
        DelPeerHolder()->PrivateRelease();
    }

    if (HasPeerMgr())
    {
        CPeerMgr::EnsureDeletePeerMgr(this, /* fForce = */ TRUE);
    }

    if( HasWindowedMarkupContextPtr() )
    {
        CMarkup *pMakup = DelWindowedMarkupContextPtr();
        if (pMakup)
            pMakup->SubRelease();
    }

#ifndef NO_DATABINDING
    if (HasDataBindPtr())
    {
        DetachDataBindings();
    }
#endif // ndef NO_DATABINDING

    TakeCapture(FALSE);

    GWKillMethodCall (this, NULL, 0);

    if (_fHasImage)
    {
        ReleaseImageCtxts();
    }

    // Release layout engines if any.
    // Usual case is that we have at most one layout (HasLayoutPtr() == TRUE)
    if ( HasLayoutPtr() )
    {
        CLayout * pLayout = DelLayoutPtr();

        pLayout->Detach();
        pLayout->Release();
    }
    // We may have multiple layouts!
    else if ( HasLayoutAry() )
    {
        DelLayoutAry(); // will take care of detaching/releasing its layouts
    }

    //delete the related accessible object if there is one
    if ( HasAccObjPtr() )
    {
        delete DelAccObjPtr();
    }

    if (_fHasPendingFilterTask)
        Doc()->RemoveFilterTask(this);

    if (_fHasPendingRecalcTask)
        Doc()->RemoveExpressionTask(this);

    if (_pAA)
    {
        // clear up the FiltersCollection

        if( _fHasFilterSitePtr )
        {
            GetFilterSitePtr()->Release();
        }

        // Kill the cached style pointer if present.  super::passivate
        // will delete the attribute array holding it.
        if (_pAA->IsStylePtrCachePossible())
        {
            delete GetInLineStylePtr();
            delete GetRuntimeStylePtr();
        }
#if DBG==1
        else
            Assert( !GetInLineStylePtr() && !GetRuntimeStylePtr() );
#endif
    }

    super::Passivate();

    // Ensure Lookaside cleanup.  Go directly to document to avoid bogus flags
    Assert(Doc()->GetLookasidePtr((DWORD *) this + LOOKASIDE_DATABIND) == NULL);
    Assert(Doc()->GetLookasidePtr((DWORD *) this + LOOKASIDE_PEER) == NULL);
    Assert(Doc()->GetLookasidePtr((DWORD *) this + LOOKASIDE_PEERMGR) == NULL);
    Assert(Doc()->GetLookasidePtr((DWORD *) this + LOOKASIDE_ACCESSIBLE) == NULL);
    Assert(Doc()->GetLookasidePtr((DWORD *) this + LOOKASIDE_SLAVE) == NULL);
    Assert(Doc()->GetLookasidePtr2((DWORD *) this + LOOKASIDE2_MASTER) == NULL);
    Assert(Doc()->GetLookasidePtr2((DWORD *) this + LOOKASIDE2_WINDOWEDMARKUP) == NULL);

    pDoc->SubRelease();

    DecrementObjectCount(&_dwObjCnt);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT hr;

    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IProvideMultipleClassInfo, NULL)
        QI_TEAROFF2(this, IProvideClassInfo, IProvideMultipleClassInfo, NULL)
        QI_TEAROFF2(this, IProvideClassInfo2, IProvideMultipleClassInfo, NULL)
        QI_TEAROFF((CBase *)this, ISpecifyPropertyPages, NULL)
        QI_TEAROFF((CBase *)this, IPerPropertyBrowsing, NULL)
        QI_TEAROFF(this, ISupportErrorInfo, NULL)
        QI_HTML_TEAROFF(this, IHTMLElement, NULL)
        QI_HTML_TEAROFF(this, IHTMLElement2, NULL)
        QI_HTML_TEAROFF(this, IHTMLElement3, NULL)
        QI_HTML_TEAROFF(this, IHTMLElement4, NULL)
        QI_TEAROFF(this, IHTMLUniqueName, NULL);
        QI_TEAROFF(this, IHTMLDOMNode, NULL);
        QI_TEAROFF(this, IHTMLDOMNode2, NULL)
        QI_TEAROFF(this, IHTMLElementRender, NULL);
        QI_TEAROFF(this, IObjectIdentity, NULL);
        QI_TEAROFF(this, IServiceProvider, NULL);
        QI_TEAROFF(this, IRecalcProperty, NULL);
        QI_CASE(IConnectionPointContainer)
        {
            *((IConnectionPointContainer **)ppv) =
                    new CConnectionPointContainer(this, NULL);

            if (!*ppv)
                RRETURN(E_OUTOFMEMORY);

            SetEventsShouldFire();
            break;
        }
#ifndef NO_DATABINDING
        QI_CASE(IHTMLDatabinding)
        {
            if (GetDBindMethods() == NULL)
                RRETURN(E_NOINTERFACE);

            hr = THR(CreateTearOffThunk(this, s_apfnIHTMLDatabinding, NULL, ppv));
            if (hr)
                RRETURN(hr);
            break;
        }
#endif // ndef NO_DATABINDING

        default:
        {
            const CLASSDESC *pclassdesc = ElementDesc();

            if (iid == CLSID_CElement)
            {
                *ppv = this;    // Weak ref
                return S_OK;
            }
            
            // If QI for IMarshal do not delegate to the behavior
            // because Trident does not support free-threaded calls in the case 
            // where the behavior supports custom marshaling
            if (iid == IID_IMarshal)
            {
                hr = E_NOINTERFACE;
                RRETURN (hr);
            }

            // Primary default interface, or the non dual
            // dispinterface return the same object -- the primary interface
            // tearoff.
            if (pclassdesc &&
                pclassdesc->_apfnTearOff &&
                pclassdesc->_classdescBase._piidDispinterface &&
                (iid == *pclassdesc->_classdescBase._piidDispinterface ||
                 DispNonDualDIID(iid)))
            {
#ifndef WIN16
                hr = THR(CreateTearOffThunk(this, pclassdesc->_apfnTearOff, NULL, ppv, (void *)pclassdesc->_classdescBase._apHdlDesc->ppVtblPropDescs));
#else
                BYTE *pThis = ((BYTE *) (void *) ((CBase *) this)) - m_baseOffset;
                hr = THR(CreateTearOffThunk(pThis, (void *)(pclassdesc->_apfnTearOff), NULL, ppv));
#endif
                if (hr)
                    RRETURN(hr);

                break;
            }

            if (HasIdentityPeerHolder())
            {
                CPeerHolder *   pPeerHolder = GetIdentityPeerHolder();
                IUnknown *      pUnk;

                //
                // delegate to identity behavior;
                // thunk the interface pointers to element identity -
                // use element's IUnknown for subsequent QIs
                //
                hr = THR_NOTRACE(pPeerHolder->QueryPeerInterface(iid, (void**)&pUnk));
                if (S_OK == hr)
                {
                    hr = THR(::CreateTearOffThunk(
                        pUnk,
                        *(void **)pUnk,
                        NULL,
                        ppv,
                        (IPrivateUnknown*)this,
                        *(void **)(IPrivateUnknown*)this,
                        QI_MASK,
                        NULL));
                    ReleaseInterface(pUnk);
                }

                break;
            }

            hr = E_NOINTERFACE;
            RRETURN (hr);
            break;
        }
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    (*(IUnknown **)ppv)->AddRef();

    DbgTrackItf(iid, "CElement", FALSE, ppv);

    return S_OK;
}


#if DBG == 1
BOOL        g_fDisableMarkupTrace;
CMarkup *   g_pMarkupTrace;
int         g_nSNMarkupTrace;
#endif

//+------------------------------------------------------------------------
//
//  Member:     CElement::PrivateAddRef, IUnknown
//
//  Synopsis:   Private unknown AddRef.
//
//-------------------------------------------------------------------------
ULONG
CElement::PrivateAddRef()
{
    if( _ulRefs == 1 && IsInMarkup() )
    {
        Assert( GetMarkupPtr() );
        GetMarkupPtr()->AddRef();

#if DBG==1
        if (g_pMarkupTrace && !g_fDisableMarkupTrace &&
            (g_nSNMarkupTrace == 0 || g_nSNMarkupTrace == SN()) &&
            g_pMarkupTrace == GetMarkupPtr())
        {
            TraceTag((0, "markup %x AR from %ls %d", g_pMarkupTrace, TagName(), SN()));
            TraceCallers(0, 0, 12);
        }
#endif

    }

    return super::PrivateAddRef();
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::PrivateRelease, IUnknown
//
//  Synopsis:   Private unknown Release.
//
//-------------------------------------------------------------------------
ULONG
CElement::PrivateRelease()
{
    CMarkup * pMarkup = NULL;

    if( _ulRefs == 2 && IsInMarkup() )
    {
        Assert( GetMarkupPtr() );
        pMarkup = GetMarkupPtr();

#if DBG==1
        if (g_pMarkupTrace && !g_fDisableMarkupTrace &&
            (g_nSNMarkupTrace == 0 || g_nSNMarkupTrace == SN()) &&
            g_pMarkupTrace == pMarkup)
        {
            TraceTag((0, "markup %x Rel from  %ls %d", g_pMarkupTrace, TagName(), SN()));
            TraceCallers(0, 0, 12);
        }
#endif

    }

    ULONG ret =  super::PrivateRelease();

    if( pMarkup )
    {
        pMarkup->Release();
    }

    return ret;
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::PrivateEnterTree
//
//  Synopsis:   Ref counting fixup as tree entered.
//
//-------------------------------------------------------------------------
void
CElement::PrivateEnterTree()
{
    Assert( IsInMarkup() );
    super::PrivateAddRef();
    GetMarkupPtr()->AddRef();
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::PrivateExitTree
//
//  Synopsis:   Ref counting fixup as tree exited.
//
//-------------------------------------------------------------------------
void
CElement::PrivateExitTree( CMarkup * pMarkupOld)
{
    BOOL fReleaseMarkup = _ulRefs > 1;

    Assert( ! IsInMarkup() );
    Assert( pMarkupOld );

    // If we sent the EXITTREE_PASSIVATEPENDING bit then we
    // must also passivate right here.
    AssertSz( !_fPassivatePending || _ulRefs == 1, 
        "EXITTREE_PASSIVATEPENDING set and element did not passivate.  Talk to JBeda." );

    super::PrivateRelease();

    if ( fReleaseMarkup )
    {
        pMarkupOld->Release();
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     contains
//
//  Synopsis:   IHTMLElement method. returns a boolean  if PIelement is within
//              the scope of this
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CElement::contains(IHTMLElement * pIElement, VARIANT_BOOL *pfResult)
{
    CTreeNode     *pNode = NULL;
    HRESULT hr = S_OK;

    Assert ( pfResult );

    if ( !pfResult )
        goto Cleanup;

    *pfResult = VB_FALSE;
    if ( !pIElement )
        goto Cleanup;

    // get a CTreeNode pointer
    hr = THR(pIElement->QueryInterface(CLSID_CTreeNode, (void **)&pNode) );
    if ( hr == E_NOINTERFACE )
    {
        CElement *pElement;
        hr = THR(pIElement->QueryInterface(CLSID_CElement, (void **)&pElement) );
        if( hr )
            goto Cleanup;

        pNode = pElement->GetFirstBranch();
    }
    else if( hr )
        goto Cleanup;

    while (pNode &&
           DifferentScope(pNode, this))
    {
        // stop after the HTML tag
        if (pNode->Tag() == ETAG_ROOT)
            pNode = NULL;
        else
            pNode = pNode->Parent();
    }

    if ( pNode )
        *pfResult = VB_TRUE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::ClearRunCaches(DWORD dwFlags)
{
    CMarkup * pMarkup = GetMarkup();

    if (pMarkup)
    {
        pMarkup->ClearRunCaches(dwFlags, this);
    }

    RRETURN(S_OK);
}

BOOL
CElement::IsFormatCacheValid()
{
    CTreeNode * pNode;
    
    pNode = GetFirstBranch();
    while (pNode)
    {
        if (!pNode->IsFancyFormatValid() ||
            !pNode->IsCharFormatValid() ||
            !pNode->IsParaFormatValid())
            return FALSE;
        pNode = pNode->NextBranch();
    }

    return TRUE;
}


HRESULT
CElement::EnsureFormatCacheChange ( DWORD dwFlags)
{
    HRESULT hr = S_OK;

    //
    // If we're not in the tree, it really isn't
    // very safe to do what we do.  Since putting
    // the element in the tree will call us again,
    // simply returning should be safe
    //
    if (GetFirstBranch() == 0)
        goto Cleanup;

    if ( dwFlags & (ELEMCHNG_CLEARCACHES | ELEMCHNG_CLEARFF) )
    {
        hr = THR(ClearRunCaches(dwFlags));
        if(hr)
            goto Cleanup;
    }

Cleanup:

    RRETURN( hr );
}

HRESULT
CElement::FireAccessibilityEvents(DISPID dispidEvent)
{
    HRESULT     hr = S_OK;
    CDoc *      pDoc = Doc();

    if (pDoc)
    {
        // fire accesibility state change event.
        hr = THR(pDoc->FireAccessibilityEvents( dispidEvent, (CBase *)this, FALSE));
    }

    RRETURN(hr);
}

DeclareTag(tagPropChange, "Property changes", "OnPropertyChange");

//+------------------------------------------------------------------------
//
//  Member:     CElement::OnPropertyChange
//
//
//-------------------------------------------------------------------------

HRESULT
CElement::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT             hr = S_OK;
    CControlledFormatter cfo(this, dispid, dwFlags);
    BOOL                fYieldCurrency = FALSE;
    CTreeNode *         pNode = GetFirstBranch();
    CDoc *              pDoc = Doc();
    CCollectionCache *  pCollectionCache;
    CElement *          pElemCurrent = pDoc->_pElemCurrent;
    
    Assert( !ppropdesc || ppropdesc->GetDispid() == dispid );
    //Assert( !ppropdesc || ppropdesc->GetdwFlags() == dwFlags );


    TraceTag((tagPropChange, "Property changed, flags:%ld", dwFlags));

    // if this is an event property that has just been hooked up then we need to 
    // start firing events for this element. we want to do this event if this 
    // element is not yet in the tree (i.e. no pNode) so that when it IS put into
    // the tree we can fire events.
    //
    // NOTE: a good alternative implementation is to have this flag on the AttrArray.
    // then with dword stored, we could have event level granularity and control.
    // to support this all we need to do is change the implementation fo SetEventsShouldFire()
    // and ShouldEventsFire() to use the AA.
    if (dispid >= DISPID_EVENTS && dispid < DISPID_EVENTS + DISPID_EVPROPS_COUNT)
    {
        SetEventsShouldFire();

        // don't expose this to the outside.
        if ( dispid == DISPID_EVPROP_ONATTACHEVENT)
            goto Cleanup;
    }

    if (DISPID_A_BEHAVIOR == dispid || DISPID_CElement_className == dispid || DISPID_UNKNOWN == dispid)
    {
        if (DISPID_A_BEHAVIOR == dispid)
        {
            pDoc->SetCssPeersPossible();
        }

        hr = THR(ProcessPeerTask(PEERTASK_RECOMPUTEBEHAVIORS));
        if (hr)
            goto Cleanup;
    }

    // NOTE (alexz) a lot of stuff below this check is supposed to work when the element is not in a markup
    if(!IsInMarkup() || !pNode)
        goto Cleanup;

    Verify(OpenView());

    // some changes invalidate collections
    if ( dwFlags & ELEMCHNG_UPDATECOLLECTION )
    {
        // TODO rgardner, for now Inval all the collections, whether they are filtered on property values
        // or not. We should tweak the PDL code to indicate which collections should be invaled, or do
        // this intelligently through some other mechanism, we should tweak this
        // when we remove the all collection.
        Assert(IsInMarkup());

        pCollectionCache = GetMarkup()->CollectionCache();
        if (pCollectionCache)
            pCollectionCache->InvalidateAllSmartCollections();

        // Clear this flag: exclusive or
        dwFlags ^= ELEMCHNG_UPDATECOLLECTION;
    }

    switch(dispid)
    {
    case DISPID_A_BACKGROUNDIMAGE:
    case DISPID_A_LISTSTYLEIMAGE:
        // Release any dispid's which hold image contexts
        DeleteImageCtx(dispid);
        break;
    }

    if (!cfo.Init(&hr))
        goto Cleanup;
    
    switch (dispid)
    {
    case DISPID_A_CURSOR:
        // Do a lazy cursor update
        pDoc->DeferSetCursor();
        break;
    case DISPID_A_HIDEFOCUS:
        if (this == pDoc->_pElemCurrent)
        {
            //Refresh the focus rect
            pDoc->GetView()->SetFocus(this, pDoc->_lSubCurrent);
        }
        break;
    case DISPID_A_POSITION:
        if (IsInMarkup())
        {
            pCollectionCache = GetMarkup()->CollectionCache();
            if (pCollectionCache)
                pCollectionCache->InvalidateItem(CMarkup::REGION_COLLECTION);

            SendNotification(NTYPE_ZPARENT_CHANGE);
        }
        break;

    case STDPROPID_XOBJ_LEFT:
    case STDPROPID_XOBJ_RIGHT:
        {
            CTreeNode * pNode = GetFirstBranch();
            const CFancyFormat * pFF = pNode->GetFancyFormat();
            const CCharFormat  * pCF = pNode->GetCharFormat();
            BOOL fElementVertical = pCF->HasVerticalLayoutFlow();
            BOOL fWritingModeUsed = pCF->_fWritingModeUsed;

            if (pFF->IsPositioned())
            {
                //
                // If positioned absolute and width is auto, left & right control the width
                // of the element, so fire a resize instead of reposition.
                // Relatively positioned elements reposition, not resize.
                // Also, We do not resize absolute positioned table cells, so reposition. (bug 77275)
                //
                if(   pFF->IsAbsolute() 
                   && pFF->GetLogicalWidth(fElementVertical, fWritingModeUsed).IsNullOrEnum() 
                   && !IsTablePart())
                {
                    dwFlags |= ELEMCHNG_SIZECHANGED;
                }               
                else
                {
                    RepositionElement();
                }
            }

            if (dispid == STDPROPID_XOBJ_LEFT)
            {
                IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE_PIXELLEFT));
                IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE_POSLEFT));
            }
            else
            {
                IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE2_PIXELRIGHT));
                IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE2_POSRIGHT));
            }
        }
        break;

    case STDPROPID_XOBJ_TOP:
    case STDPROPID_XOBJ_BOTTOM:
        {
            CTreeNode * pNode = GetFirstBranch();
            const CFancyFormat * pFF = pNode->GetFancyFormat();
            const CCharFormat  * pCF = pNode->GetCharFormat();
            BOOL fElementVertical = pCF->HasVerticalLayoutFlow();
            BOOL fWritingModeUsed = pCF->_fWritingModeUsed;

            //
            // if height is auto, and the bottom is not auto then the size
            // of the element if absolute can change based on it's top & bottom.
            // So, fire a resize instead of reposition. If bottom is auto,
            // then the element is sized to content.
            //
            if (    pFF->IsAbsolute()
                &&  pFF->GetLogicalHeight(fElementVertical, fWritingModeUsed).IsNullOrEnum()
                &&  (dispid != STDPROPID_XOBJ_TOP || !pFF->GetLogicalPosition(SIDE_BOTTOM, fElementVertical, fWritingModeUsed).IsNullOrEnum()))
            {
                dwFlags |= ELEMCHNG_SIZECHANGED;
            }
            else if (!pFF->IsPositionStatic())
            {
                RepositionElement();
            }

            if (dispid == STDPROPID_XOBJ_TOP)
            {
                IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE_PIXELTOP));
                IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE_POSTOP));
            }
            else
            {
                IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE2_PIXELBOTTOM));
                IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE2_POSBOTTOM));
            }
        }
        break;

    case STDPROPID_XOBJ_WIDTH:
        IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE_PIXELWIDTH));
        IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE_POSWIDTH));
        break;

    case STDPROPID_XOBJ_HEIGHT:
        IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE_PIXELHEIGHT));
        IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE_POSHEIGHT));
        break;

    case DISPID_A_ZINDEX:
        if (!IsPositionStatic())
        {
            ZChangeElement();
        }

        pDoc->FixZOrder();
        break;

    case DISPID_CElement_tabIndex:
        hr = OnTabIndexChange();
        break;
    
    case DISPID_CElement_disabled:
        // if (fHasLayout)
        {
            BOOL        fEnabled    = !GetAAdisabled();
            CElement *  pNewDefault = 0;
            CElement *  pOldDefault = 0;
            CElement *  pSavDefault = 0;

            // we should not be the default button before becoming enabled
            Assert(!(fEnabled && _fDefault));

            if (!_fDefault && fEnabled)
            {
                // this is not the previous default button
                // look for it
                pOldDefault = FindDefaultElem(TRUE);
            }

            if (pDoc->_pElemCurrent == this && !fEnabled)
            {
                // this is the case where the button disables itself
                pOldDefault = this;
            }

            // if this element act like a button
            // becomes disabled or enabled
            // we need to make sure this is recorded in the cached
            // default element of the doc or form
            if (TestClassFlag(CElement::ELEMENTDESC_DEFAULT))
            {
                // try to find a new default
                // set _fDefault to FALSE in order to avoid
                // FindDefaultLayout returning this site again.
                // because FindDefaultLayout will use _fDefault
                _fDefault = FALSE;
                pSavDefault = FindDefaultElem(TRUE, TRUE);
                if (pSavDefault == this || !fEnabled)
                {
                    CFormElement    *pForm = GetParentForm(); 
                    if (pSavDefault)
                    {
                        pSavDefault->_fDefault = TRUE;
                    }
                    if (pForm)
                        pForm->_pElemDefault = pSavDefault;
                    else
                        pDoc->_pElemDefault = pSavDefault;
                }
            }
            if (!pDoc->_pElemCurrent->_fActsLikeButton || _fDefault)
            {
                _fDefault = FALSE;
                pNewDefault = pSavDefault ? pSavDefault : FindDefaultElem(TRUE, TRUE);
            }

            // if this was the default, and now becoming disabled
            _fDefault = FALSE;

            if (pNewDefault != pOldDefault)
            {
                if (pOldDefault)
                {
                    CNotification   nf;

                    nf.AmbientPropChange(pOldDefault, (void *)DISPID_AMBIENT_DISPLAYASDEFAULT);

                    // refresh the old button
                    pOldDefault->_fDefault = FALSE;
                    pOldDefault->Notify(&nf);
                    pOldDefault->Invalidate();
                }

                if (pNewDefault)
                {
                    CNotification   nf;

                    Assert(pNewDefault->_fActsLikeButton);
                    nf.AmbientPropChange(pNewDefault, (void *)DISPID_AMBIENT_DISPLAYASDEFAULT);
                    pNewDefault->_fDefault = TRUE;
                    pNewDefault->Notify(&nf);
                    pNewDefault->Invalidate();
                }
            }
        }
        break;

    case DISPID_A_VISIBILITY:
        {
            //
            //  Notify element and all descendents of the change
            //

            SendNotification(NTYPE_VISIBILITY_CHANGE);

            //
            //  If the element is being hidden, ensure it and any descendent which inherits visibility are the current element
            //  (Do this by, within this routine, pretending that this element is the current element)
            //

            fYieldCurrency = !!pNode->GetCharFormat()->IsVisibilityHidden();

            CTreeNode *pMasterCurrent = pDoc->_pElemCurrent->GetFirstBranch()->GetNodeInMarkup( GetMarkupPtr() );

            if (    fYieldCurrency
                &&  pElemCurrent
                &&  ( pMasterCurrent && pMasterCurrent->SearchBranchToRootForScope(this) )
                &&  pElemCurrent->GetFirstBranch()->GetCharFormat()->IsVisibilityHidden())
            {
                pElemCurrent = this;
            }
        }
        break;

    case DISPID_A_DISPLAY:
        //
        //  If the element is being hidden, ensure it and none of its descendents are the current element
        //  (Do this by, within this routine, pretending that this element is the current element)
        //

        if (pNode->GetCharFormat()->IsDisplayNone())
        {
            fYieldCurrency = TRUE;

            if (pElemCurrent && pElemCurrent->GetFirstBranch()->SearchBranchToRootForScope(this))
            {
                pElemCurrent = this;
            }
        }
#ifdef NEVER
        else
        {
            dwFlags |= ELEMCHNG_REMEASUREALLCONTENTS;
        }
#endif
        break;

    case DISPID_A_ROTATE:
    case DISPID_A_ZOOM:
        // Explicit tranformation forces us to have a layout
        // Change of layoutness will be handled by common code below.
        
        // If layoutness doesn't change, the element doesn't need to
        // be remeasured, but parents need to be resized because of change 
        // in aparent bounds of this element.
        if (   cfo.HasLayoutAfterFormatsChange()
            && cfo.HadLayoutBeforeFormatsChange()
           )
        {
            dwFlags |= ELEMCHNG_REMEASUREINPARENT;
        }
        break;

    case DISPID_A_MARGINTOP:
    case DISPID_A_MARGINLEFT:
    case DISPID_A_MARGINRIGHT:
    case DISPID_A_MARGINBOTTOM:
        // BackCompat: Margins act like padding on the BODY
        // StrictCSS1: Margins act normally.
        if (    (   Tag() == ETAG_FRAMESET
                 || Tag() == ETAG_BODY     )
            &&  !GetMarkup()->IsHtmlLayout() )
        {
            dwFlags |= ELEMCHNG_REMEASURECONTENTS;
            dwFlags &= ~(ELEMCHNG_SIZECHANGED | ELEMCHNG_REMEASUREINPARENT);
        }
        break;
    case DISPID_A_CLIP:
    case DISPID_A_CLIPRECTTOP:
    case DISPID_A_CLIPRECTRIGHT:
    case DISPID_A_CLIPRECTBOTTOM:
    case DISPID_A_CLIPRECTLEFT:
        // NOTE (KTam): If element providing pNearestLayout has multi layouts, we need
        // to figure out how to apply clip rects to all of them.  Fix this later, for now
        // we'll just get the nearest layout.
        if (cfo.HasLayoutAfterFormatsChange())
        {
            CDispNode* pDispNode = cfo.GetUpdatedNearestLayout()->GetElementDispNode(this);
            if (pDispNode)
            {
                if (pDispNode->HasUserClip())
                {
                    CSize size;

                    cfo.GetUpdatedNearestLayout()->GetSize(&size);
                    cfo.GetUpdatedNearestLayout()->SizeDispNodeUserClip(pDoc->GetView()->GetMeasuringDevice(mediaTypeNotSet), size);
                }

                // we need to create a display node that can have user
                // clip information, and ResizeElement will force this
                // node to be created.  Someday, we might be able to morph
                // the existing display node for greater efficiency.
                else
                {
                    ResizeElement();
                }
            }
        }
        break;
    }

    if(cfo.ShouldComputeFormats())
    {
        //
        // Notify the layout of the property change, layout fixes up
        // its display node to handle visibility/background changes.
        //
        if (cfo.HasLayoutAfterFormatsChange())
        {
            cfo.GetUpdatedNearestLayoutInfo()->OnPropertyChange(dispid, dwFlags);
        }
    
        if(     (cfo.HadLayoutBeforeFormatsChange() && !cfo.HasLayoutAfterFormatsChange())
            ||  (!cfo.HadLayoutBeforeFormatsChange() && cfo.HasLayoutAfterFormatsChange()))
        {
            if(this == pDoc->_pElemCurrent)
            {
                cfo.GetUpdatedNearestLayoutInfo()->ElementOwner()->BecomeCurrent(pDoc->_lSubCurrent);
            }

            dwFlags |= ELEMCHNG_REMEASUREINPARENT;
            dwFlags &= ~ELEMCHNG_SIZECHANGED;
        }
    }
    
    if (dwFlags & (ELEMCHNG_REMEASUREINPARENT | ELEMCHNG_SIZECHANGED))
    {
        MinMaxElement();
    }

    // TODO (dmitryt, 8/22/00) I need to cleanup this code.
    // 1. Some ELEMCHNG_ bits come from PDL files, like style.pdl, while others are 
    //      calculated here. This should be in one single place - in the code.
    // 2. I need to eliminate "RemeasureElement" and "RemeasureAndResize" 
    //      and "RemeasureInParentContext" and replace them all with "ResizeElement"
    //      There is no difference between them except layered bugs.
    //      RESIZE starts recalc from the element in question and if its size changes as a result
    //      of recalc - then cp range in parent is invalidated. Remeasure starts recalc right 
    //      at the cp range in parent. The only case when we need a remeasure is when 
    //      size of child doesn't change but we need action in parent (to hook the child's 
    //      dispnode, like in case when child is getting display:block back)
    // 3. Invalidate the whole text of element in this combined notification (as in
    //    code below where CharsResize+ResizeElement are called)
    
    if(dispid == DISPID_A_DISPLAY)
    {
        CNotification   nf;
        nf.CharsResize(0, GetElementCch(), pNode);
        GetMarkup()->Notify(nf);

        RemeasureInParentContext();
    }
    else if(dispid == DISPID_A_ZOOM)
    {
        ResizeElement(NFLAGS_FORCE);
    }
    else if (dwFlags & ELEMCHNG_REMEASUREINPARENT)
    {
        //(dmitryt) should be ResizeElement
        RemeasureInParentContext();
    }
    else if (   dwFlags & ELEMCHNG_SIZECHANGED
             || (   (dwFlags & ELEMCHNG_RESIZENONSITESONLY)
                 && !cfo.HasLayoutAfterFormatsChange()
                )
            )
    {
        ResizeElement();
    }

    if (dwFlags & (ELEMCHNG_REMEASURECONTENTS | ELEMCHNG_REMEASUREALLCONTENTS))
    {
        RemeasureElement( dwFlags & ELEMCHNG_REMEASUREALLCONTENTS
                            ? NFLAGS_FORCE
                            : 0);
    }

    // we need to send the display change notification after sending
    // the RemeasureInParent notification. RemeasureInParent marks the
    // ancestors dirty, therefore any ZParentChange notifications fired
    // from DisplayChange are queued up until the ZParent is calced.
    if (    dispid == DISPID_A_DISPLAY
        ||  dispid == DISPID_CElement_className
        ||  dispid == DISPID_UNKNOWN)
    {
        CNotification   nf;

        nf.DisplayChange(this);

        SendNotification(&nf);
    }


    if (this == pElemCurrent)
    {

        
        if (    !IsEnabled()
            ||  fYieldCurrency)
        {         
            CElement* pElemPrev = pDoc->_pElemCurrent;
            
            IGNORE_HR(pNode->Parent()->Element()->BubbleBecomeCurrent(0));

            if ( pDoc->_pCaret &&               
                 pDoc->_pCaret->IsInsideElement( pElemPrev ) == S_OK )
            {
                pDoc->_pCaret->Hide();
            }                   
        }

        else if (   dispid == DISPID_A_VISIBILITY
                ||  dispid == DISPID_A_DISPLAY)
        {
            pDoc->GetView()->SetFocus(pDoc->_pElemCurrent, pDoc->_lSubCurrent);
        }
    }

    if (!(dwFlags & ELEMCHNG_DONTFIREEVENTS))
    {
    
        // once we start firing events, the pLayout Old is not reliable since script can
        // change the page.


        IGNORE_HR(FireOnChanged(dispid));

        pDoc->OnDataChange();

        // fire the onpropertychange script event, but only if it is possible
        //   that someone is actually listeing. otherwise, don't waste the time.
        //
        if (ShouldFireEvents() && DISPID_UNKNOWN != dispid)
        {
            hr = THR(Fire_PropertyChangeHelper(dispid, dwFlags, ppropdesc));
            if ( hr )
                goto Cleanup;
        }

        // Accessibility state change check and event firing
        if (   (   (    (ppropdesc 
                    && ((dwFlags | ppropdesc->GetdwFlags()) & ELEMCHNG_ACCESSIBILITY) )
                || (dwFlags & ELEMCHNG_ACCESSIBILITY) ))
            && (HasAccObjPtr() || IsSupportedElement(this)))
        {
            hr = THR(FireAccessibilityEvents(NULL));
        }        
    }

    dwFlags &= ~(ELEMCHNG_CLEARCACHES | ELEMCHNG_CLEARFF);

    if ( dispid == DISPID_A_EDITABLE )
    {
        IUnknown* pUnknown = NULL;
        IGNORE_HR( this->QueryInterface( IID_IUnknown, ( void**) & pUnknown ));
        IGNORE_HR( pDoc->NotifySelection( EDITOR_NOTIFY_EDITABLE_CHANGE, pUnknown ));
        ReleaseInterface( pUnknown );
    }

Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Member:     OpenView
//
//  Synopsis:   Open the view associated with the element - That view is the one
//              associated with the CDoc (the only view there is right now!)
//
//  Returns:    TRUE if the view was successfully opened, FALSE if we're in the
//              middle of rendering
//
//-----------------------------------------------------------------------------
BOOL
CElement::OpenView()
{
    // So far there's only 1 view, so just get it from the doc.  Multiple views
    // will obviously change this.

    return Doc()->OpenView();
}


//+----------------------------------------------------------------------------
//
//  Member:     MinMaxElement
//              ResizeElement
//              RemeasureElement
//              RemeasureInParentContext
//              RepositionElement
//              ZChangeElement
//
//  Synopsis:   Notfication send helpers
//
//  Arguments:  grfFlags - NFLAGS_xxxx flags
//
//-----------------------------------------------------------------------------

// NOTE (KTam): There may be an issue here wrt elements with
// multiple layouts sending notifications to layouts which haven't
// been expecting them.  E.g. consider MinMaxElement called on an
// element w/ 2 layouts, one of which is _fMinMaxValid and one which
// isn't.  Currently, because at least one is _fMinMaxValid, the
// notification will be sent, and the generic broadcast mechanism
// in CMarkup::NotifyElement() will send it to all its layouts,
// even the one for which _fMinMaxValid == FALSE (and hence, if it
// were the only layout, would not have gotten this notification).
// The same situation arises with ResizeElement() CMarkup::NotifyElement() will send it to all its layouts,
// even the one for which _fMinMaxValid == FALSE (and hence, if it
// were the only layout, would not have gotten this notification).
// The same situation arises with ResizeElement().  The approach I've
// taken is that it's safer to fire more notifications than fewer,
// and if we discover we can optimize (say, by unifying checking with
// sending for multiple layouts such that "check and send" for
// each layout int he array) later, then we can do so.
void
CElement::MinMaxElement(DWORD grfFlags)
{

    CLayout * pLayout;
    if ( !HasLayoutAry() )
    {
        // Element has at most 1 layout.  GetLayoutPtr() will ret.
        // NULL if it doesn't have a layout (we have never created
        // layouts in this fn, and so don't want to call GetUpdatedLayout)
        // It probably doesn't make sense to create layouts here anyways,
        // because they would get created w/ _fMinMaxValid == FALSE, and
        // hence the notification still wouldn't fire (i.e. the only
        // effect of this fn would be to create a layout, which should
        // not be an intentional sideeffect).

        pLayout = GetLayoutPtr();


        if (    pLayout
            &&  (   pLayout->_fMinMaxValid 
                //  Table row does it on behalf of table cells
                ||  Tag() == ETAG_TR)
            )
        {
            SendNotification(NTYPE_ELEMENT_MINMAX, grfFlags);
        }
    }
    else
    {
        if ( EnsureLayoutAry()->WantsMinMaxNotification() )
            SendNotification(NTYPE_ELEMENT_MINMAX, grfFlags);
    }
}

void
CElement::ResizeElement(DWORD grfFlags)
{
    //
    //  Resize notifications are only fired when:
    //    a) The element does not have a layout (and must always notify its container) or
    //    b) It has a layout, but it's currently "clean" and
    //        The element is not presently being sized by its container
    //

    CLayout * pLayout;
    CLayout * pParentLayout = NULL;
    CElement * pParentElement = NULL;

    if ( !HasLayoutAry() )
    {
        // Element has at most 1 layout.  GetLayoutPtr() will ret.
        // NULL if it doesn't have a layout (we have never created
        // layouts in this fn, and so don't want to call GetUpdatedLayout)
        pLayout = GetLayoutPtr();

        // TODO: IsCalcingSize() tells us whether we are being calc'ed,
        // but not whether our parent is calcing us (since we can be in
        // CalcSize() either due to our parent calling us, or due to
        // a DoLayout() on us).  So in order to meet condition b, we need
        // to check out Parent->IsCalcingSize().

        // THIS CHANGE IS NOT REFLECTED IN CLayoutAry::WantsResizeNotification()
        // since it's not an interesting scenario for IE5.5 RTM.  Revisit for
        // live view templates.

        pParentElement = GetUpdatedParentLayoutElement();
        if ( pParentElement )
            pParentLayout = pParentElement->HasLayoutPtr() ? pParentElement->GetLayoutPtr() : NULL;

        //don't send notification if (pLayout && pParentLayout && pParentLayout->IsCalcingSize())

        if (    !pLayout
            ||  !pParentLayout 
            ||  !pParentLayout->IsCalcingSize())
        {
            SendNotification(NTYPE_ELEMENT_RESIZE, grfFlags);
        }
    }
    else
    {
        if ( EnsureLayoutAry()->WantsResizeNotification() )
            SendNotification(NTYPE_ELEMENT_RESIZE, grfFlags);
    }
}

void
CElement::RemeasureInParentContext(DWORD grfFlags)
{
    SendNotification(NTYPE_ELEMENT_RESIZEANDREMEASURE, grfFlags);
}

void
CElement::RemeasureElement(DWORD grfFlags)
{
    SendNotification(NTYPE_ELEMENT_REMEASURE, grfFlags);
}

void
CElement::RepositionElement(DWORD grfFlags, CPoint *ppt, CLayoutContext *pLayoutContext FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    CNotification   nf;
    Assert(!IsPositionStatic(FCPARAM) || GetFirstBranch()->GetCharFormat(FCPARAM)->_fRelative);

    nf.Initialize(NTYPE_ELEMENT_REPOSITION, this, GetFirstBranch(), NULL, grfFlags);
    if (ppt)
        nf.SetData(*ppt);

    nf.SetLayoutContext(pLayoutContext);

    SendNotification(&nf);
}

void
CElement::ZChangeElement(DWORD grfFlags, CPoint * ppt, CLayoutContext *pLayoutContext FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    // NOTE (KTam): Another way to create this notification is via the generated
    // ElementZChange fn -- currently not in use.
    
    CMarkup *       pMarkup = GetMarkup();
    CNotification   nf;

    Assert(!IsPositionStatic(FCPARAM) || GetFirstBranch()->GetCharFormat(FCPARAM)->_fRelative);
    Assert(pMarkup);

    nf.Initialize(NTYPE_ELEMENT_ZCHANGE, this, GetFirstBranch(), NULL, grfFlags);
    if (ppt)
        nf.SetData(*ppt);

    nf.SetLayoutContext(pLayoutContext);

    TraceTagEx((tagNotifyZChange, TAG_NONAME|TAG_INDENT, "(ZChangeElement: e=0x%x,%s pt(%d,%d)",
                this, TagName(), ppt ? ppt->x : 0, ppt ? ppt->y : 0 ));
    TraceCallers(tagNotifyZChange, 1, 1);

    pMarkup->Notify(nf);

    TraceTagEx((tagNotifyZChange, TAG_NONAME|TAG_OUTDENT, ")ZChangeElement"));
}


//+----------------------------------------------------------------------------
//
//  Member:     SendNotification
//
//  Synopsis:   Send a notification associated with this element
//
//-----------------------------------------------------------------------------

void
CElement::SendNotification(CNotification *pNF)
{
    CMarkup * pMarkup = GetMarkup();

    if (pMarkup)
    {
        pMarkup->Notify(pNF);
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     SendNotification
//
//  Synopsis:   Send a notification associated with this element
//
//  Arguments:  ntype    - NTYPE_xxxxx flag
//              grfFlags - NFLAGS_xxxx flags
//
//-----------------------------------------------------------------------------
void
CElement::SendNotification(
    NOTIFYTYPE  ntype,
    DWORD       grfFlags,
    void *      pvData)
{
    CMarkup *   pMarkup = GetMarkup();

    if ( pMarkup )
    {
        CNotification   nf;

        Assert( GetFirstBranch() );

        nf.Initialize(ntype, this, GetFirstBranch(), pvData, grfFlags);

        pMarkup->Notify(nf);
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     DirtyLayout
//
//  Synopsis:   Dirty the layout engine associated with an element
//
//-----------------------------------------------------------------------------
void
CElement::DirtyLayout(
    DWORD   grfLayout)
{
    if (ShouldHaveLayout())
    {
        GetUpdatedLayoutInfo()->Dirty( grfLayout );
    }
}

#ifdef WIN16
#pragma code_seg ("ELEMENT_2_TEXT")
#endif

//+---------------------------------------------------------------------------
//
//  Member:     CElement::HitTestPoint, public
//
//  Synopsis:   Determines if this element is hit by the given point
//
//  Arguments:  [pt]        -- Point to check against.
//              [ppSite]    -- If there's a hit, the site that was hit.
//              [ppElement] -- If there's a hit, the element that was hit.
//              [dwFlags]   -- HitTest flags.
//
//  Returns:    HTC
//
//  Notes:      Only ever returns a hit if this element is a relatively
//              positioned element.
//
//----------------------------------------------------------------------------

HTC
CElement::HitTestPoint(CMessage*    pMessage,
                       CTreeNode ** ppNodeElement,
                       DWORD        dwFlags)
{
    // TODO (KTam): I suspect we don't even need to get a layout here; the only
    // apparent reason for its retrieval is to get the view.  However, there may
    // be issues with this call creating the layout in question?
    CLayout *   pLayout = GetUpdatedNearestLayout( GUL_USEFIRSTLAYOUT );
    HTC         htc     = HTC_NO;
    CLayoutContext * pLayoutContext = NULL;

    if (pLayout)
    {
        CDispNode * pDispNodeOut = NULL;
        COORDINATE_SYSTEM cs = COORDSYS_GLOBAL;
        CView *     pView        = pLayout->GetView();
        POINT       ptContent;

        if (pView)
        {
            *ppNodeElement = GetFirstBranch();

            htc = pLayout->GetView()->HitTestPoint(
                                                pMessage->pt,
                                                &cs,
                                                this,
                                                dwFlags,
                                                &pMessage->resultsHitTest,
                                                ppNodeElement,
                                                ptContent,
                                                &pDispNodeOut,
                                                &pLayoutContext);
        }
    }

    return htc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetRange
//
//  Synopsis:   Returns the range of char's under this element including the
//              end nodes
//
//----------------------------------------------------------------------------

HRESULT
CElement::GetRange(long * pcpStart, long * pcch)
{
    CTreePos *ptpStart, *ptpEnd;

    Assert(GetFirstBranch());

    GetTreeExtent(&ptpStart, &ptpEnd);

    //
    // The range returned include the WCH_NODE characters for the element
    //
    *pcpStart = ptpStart->GetCp();
    *pcch = ptpEnd->GetCp() - *pcpStart + 1;
    return(S_OK);
}


//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetFocusShape
//
//  Synopsis:   Returns the shape of the focus outline that needs to be drawn
//              when this element has focus. This function creates a new
//              CShape-derived object. It is the caller's responsibility to
//              release it.
//
//  Notes:      This default implementation assumes that the element encloses
//              a text range (e.g. anchor, label). Other elements (buttons,
//              body, image, checkbox, radio button, input file, image map
//              area) must override this function to supply the correct shape.
//
//  $$ktam:     Think about what is the desired behaviour for focus shapes in
//              multilayout scenarios; consider an element broken across two
//              containers -- we may need to return a collection of shapes.
//              Right now we just return the shape corresponding to the first
//              layout.
//
//----------------------------------------------------------------------------

HRESULT
CElement::GetFocusShape(long lSubDivision, CDocInfo * pdci, CShape ** ppShape)
{
    HRESULT hr = S_FALSE;

    Assert(ppShape);

    *ppShape = NULL;

    if (GetAAhideFocus())
    {
        hr = S_OK;
        goto Cleanup;
    }

    // First check if the identity behavior wants to supply a focus rect
    if (HasIdentityPeerHolder())
    {
        IElementBehaviorFocus * pIFocus = NULL;

        if (S_OK == GetIdentityPeerHolder()->QueryPeerInterface(
                                            IID_IElementBehaviorFocus,
                                            (void**)&pIFocus))
        {
            RECT rect = g_Zero.rc;

            if (S_OK == pIFocus->GetFocusRect(&rect))
            {
                CRectShape *pShape = new CRectShape;
                if (!pShape)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    pShape->_rect = rect;
                    *ppShape = pShape;
                    hr = S_OK;
                }
            }
            ReleaseInterface(pIFocus);
            goto Cleanup;
        }
    }

    // By default, provide focus shape only for 
    // 1) elements that had focus shape in IE4 (compat)
    // 2) elements that have a tab index specified (#40434)
    //
    // In IE6, we will introduce a CSS style that lets elements override this
    // this behavior to turn on/off focus shapes.

    if (GetAAtabIndex() < 0)
    {
        switch (Tag())
        {
        case ETAG_A:
        case ETAG_LABEL:
        case ETAG_IMG:
            break;
        default:
            {
                CDefaults * pDefaults = GetDefaults();

                // Draw the focus rect if defaults.tabStop is set.
                if (pDefaults && pDefaults->GetAAtabStop())
                    break;
            }
            goto Cleanup;
        }
    }

    if (ShouldHaveLayout())
    {
        CRect       rc;
        CLayout *   pLayout = GetUpdatedLayout( GUL_USEFIRSTLAYOUT );

        if (!pLayout)
            goto Cleanup;

        pLayout->GetClientRect(&rc);
        if (rc.IsEmpty())
            goto Cleanup;

        CRectShape *pShape = new CRectShape;
        if (!pShape)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        if (_fEditable && GetFirstBranch()->GetFancyFormat()->_fContentEditable)
            rc.InflateRect(1, 1);

        pShape->_rect = rc;
        *ppShape = pShape;

        hr = S_OK;
    }
    else
    {
        long            cpStart, cch;
        CFlowLayout *   pFlowLayout     = GetFlowLayout( GUL_USEFIRSTLAYOUT );

        if (!pFlowLayout)
            goto Cleanup;

        cch = GetFirstAndLastCp( &cpStart, NULL );
        // GetFirstAndLast gets a cpStart + 1. We need the element's real cpStart
        // Also, the cch is less than the real cch by 2. We need to add this back
        // in so RegionFromElement can get the correct width of this element.
        hr = THR(pFlowLayout->GetWigglyFromRange(pdci, cpStart - 1, cch + 2, ppShape));
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+------------------------------------------------------------------------
//
//  CElement::GetImageUrlCookie
//
//  Returns a Adds the specified URL to the url image cache on the doc
//
//-------------------------------------------------------------------------

HRESULT
CElement::GetImageUrlCookie(LPCTSTR lpszURL, LONG *plCtxCookie, BOOL fForceReload)
{
    HRESULT         hr = S_OK;
    CDoc *          pDoc = Doc();
    LONG            lNewCookie = 0;

    // Element better be in the tree when this function is called
    Assert (pDoc);

    if (lpszURL && *lpszURL)
    {
        hr = pDoc->AddRefUrlImgCtx(lpszURL, this, &lNewCookie, fForceReload);
        if(hr)
            goto Cleanup;
    }

Cleanup:
    *plCtxCookie = lNewCookie;

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  CElement::AddImgCtx
//
//  Adds the info specified in ImgCtxInfo on the attr array, releasing
//  the current value if there is one.
//
//-------------------------------------------------------------------------

HRESULT
CElement::AddImgCtx(DISPID dispID, LONG lCookie)
{
    HRESULT hr = S_OK;
    CDoc    * pDoc = Doc();
    AAINDEX iCookieIndex;

    iCookieIndex = FindAAIndex(dispID, CAttrValue::AA_Internal);

    if (iCookieIndex != AA_IDX_UNKNOWN)
    {
        // Remove the current entry
        DWORD dwCookieOld = 0;

        if (GetSimpleAt(iCookieIndex, &dwCookieOld) == S_OK)
        {
            pDoc->ReleaseUrlImgCtx(LONG(dwCookieOld), this);
        }
    }

    _fHasImage = TRUE;

    hr = THR(AddSimple(dispID, DWORD(lCookie), CAttrValue::AA_Internal));

    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Function:   ReleaseImageCtxts
//
//  Synopsis:   Finds any image contexts associated with this element,
//              and frees them up.  Cookies can be held for LI bullets
//              and for background images.
//
//-----------------------------------------------------------------------------

void
CElement::ReleaseImageCtxts()
{
    CDoc * pDoc = Doc();
    AAINDEX iCookieIndex;
    DWORD   dwCookieOld = 0;
    int     n;

    if (!_fHasImage)
        return;         // nothing to do, bail

    for (n = 0; n < ARRAY_SIZE(s_aryImgDispID); ++n)
    {
        // Check for a bg url image cookie in the standard attr array
        iCookieIndex = FindAAIndex(s_aryImgDispID[n].cacheID,
                                   CAttrValue::AA_Internal);

        if (iCookieIndex != AA_IDX_UNKNOWN &&
            GetSimpleAt(iCookieIndex, &dwCookieOld) == S_OK)
        {
            pDoc->ReleaseUrlImgCtx((LONG)dwCookieOld, this);
        }
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   DeleteImageCtx
//
//  Synopsis:   Finds any image contexts associated with this element,
//              corresponding to the dispid and free it up.  Cookies
//              can be held for LI bullets and for background images.
//
//-----------------------------------------------------------------------------

void
CElement::DeleteImageCtx(DISPID dispid)
{
    CDoc *      pDoc = Doc();
    CAttrArray* pAA;

    if (_fHasImage && (pAA = *GetAttrArray()) != NULL)
    {
        int n;
        for (n = 0; n < ARRAY_SIZE(s_aryImgDispID); ++n)
        {
            if (dispid == s_aryImgDispID[n].propID)
            {
                long lCookie;

                if ( pAA->FindSimpleInt4AndDelete(s_aryImgDispID[n].cacheID,
                                               (DWORD *)&lCookie) )
                {
                    // Release UrlImgCtxCacheEntry
                    pDoc->ReleaseUrlImgCtx(lCookie, this);
                }
                break;
            }
        }
    }
}

//+------------------------------------------------------------------------
//
//  Member:     GetSourceIndex
//
//-------------------------------------------------------------------------


long
CElement::GetSourceIndex ()
{
    CTreeNode * pNodeCurr;

    if ( Tag() == ETAG_ROOT )
        return -1;

    pNodeCurr = GetFirstBranch();
    if ( !pNodeCurr )
        return -1;
    else
    {
        Assert( !pNodeCurr->GetBeginPos()->IsUninit() );
        return pNodeCurr->GetBeginPos()->SourceIndex()-1; // subtract one because of ETAG_ROOT
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CompareZOrder
//
//  Synopsis:   Compare the z-order of two elements
//
//  Arguments:  pElement - The CElement to compare against
//
//  Returns:    Greater than zero if this element is greater
//              Less than zero if this element is less
//              Zero if they are equal
//
//----------------------------------------------------------------------------

MtDefine( ZCompares, Metrics, "Calls to CElement::CompareZOrder" )

long
CElement::CompareZOrder(
    CElement *  pElement)
{
    long    lCompare;

    MtAdd( Mt(ZCompares), +1, 0 );

    lCompare = GetFirstBranch()->GetCascadedzIndex() - pElement->GetFirstBranch()->GetCascadedzIndex();

    if (!lCompare)
    {
        lCompare = GetSourceIndex() - pElement->GetSourceIndex();
    }

    return lCompare;
}


//+------------------------------------------------------------------------
//
//  Member:     GetTreeExtent
//
//  Synopsis:   Return the edge node pos' for this element.  Pretty
//              much just walks the context chain and gets the first
//              and last node pos'.
//
//-------------------------------------------------------------------------
void
CElement::GetTreeExtent(
    CTreePos ** pptpStart,
    CTreePos ** pptpEnd )
{
    CTreeNode * pNodeCurr = GetFirstBranch();

    if (pptpStart)
        *pptpStart = NULL;

    if (pptpEnd)
        *pptpEnd = NULL;

    if (!pNodeCurr)
        goto Cleanup;

    Assert(     ! pNodeCurr->GetBeginPos()->IsUninit()
            &&  ! pNodeCurr->GetEndPos()->IsUninit() );

    if (pptpStart)
    {
        *pptpStart = pNodeCurr->GetBeginPos();

        Assert( *pptpStart );
        Assert( (*pptpStart)->IsBeginNode() && (*pptpStart)->IsEdgeScope() );
        Assert( (*pptpStart)->Branch() == pNodeCurr );
    }

    if (pptpEnd)
    {
        while( pNodeCurr->NextBranch() )
            pNodeCurr = pNodeCurr->NextBranch();

        Assert( pNodeCurr );

        *pptpEnd = pNodeCurr->GetEndPos();

        Assert( *pptpEnd );
        Assert( (*pptpEnd)->IsEndNode() && (*pptpEnd)->IsEdgeScope() );
        Assert( (*pptpEnd)->Branch() == pNodeCurr );
    }

Cleanup:
    return;
}

//+------------------------------------------------------------------------
//
//  Member:     GetLastBranch
//
//  Synopsis:   Like GetFirstBranch, but gives the last one.
//
//-------------------------------------------------------------------------
CTreeNode *
CElement::GetLastBranch()
{
    CTreeNode *pNode = GetFirstBranch();
    CTreeNode *pNodeLast = pNode;

    while (pNode)
    {
        pNodeLast = pNode;
        pNode = pNode->NextBranch();
    }

    return pNodeLast;
}

//+------------------------------------------------------------------------
//
//  Member:     ParanoidGetLastBranch
//
//  Synopsis:   Like GetFirstBranch, but gives the last one.  More resistent to
//              corrupt data structures.
//
//-------------------------------------------------------------------------
CTreeNode *
CElement::ParanoidGetLastBranch()
{
    CTreeNode *pNode = GetFirstBranch();
    CTreeNode *pNodeLast = pNode;

    while (pNode)
    {
        pNodeLast = pNode;
        pNode = pNode->ParanoidNextBranch();
    }

    return pNodeLast;
}

//+------------------------------------------------------------------------
//
//  Static Member:  CElement::ReplacePtr, CElement::ClearPtr
//
//  Synopsis:   Do a CElement* assignment, but worry about refcounts
//
//-------------------------------------------------------------------------

void
CElement::ReplacePtr ( CElement * * pplhs, CElement * prhs )
{
    if (pplhs)
    {
        CElement * plhsLocal = *pplhs;
        if (prhs)
        {
            prhs->AddRef();
        }
        *pplhs = prhs;
        if (plhsLocal)
        {
            plhsLocal->Release();
        }
    }
}

//+------------------------------------------------------------------------
//
//  Static Member:  CElement::ReplacePtrSub, CElement::ClearPtr
//
//  Synopsis:   Do a CElement* assignment, but worry about weak refcounts
//
//-------------------------------------------------------------------------

void
CElement::ReplacePtrSub ( CElement * * pplhs, CElement * prhs )
{
    if (pplhs)
    {
        if (prhs)
        {
            prhs->SubAddRef();
        }
        if (*pplhs)
        {
            (*pplhs)->SubRelease();
        }
        *pplhs = prhs;
    }
}

void
CElement::SetPtr ( CElement ** pplhs, CElement * prhs )
{
    if (pplhs)
    {
        if (prhs)
        {
            prhs->AddRef();
        }
        *pplhs = prhs;
    }
}

void
CElement::StealPtrSet ( CElement ** pplhs, CElement * prhs )
{
    SetPtr( pplhs, prhs );

    if (pplhs && *pplhs)
        (*pplhs)->Release();
}

void
CElement::StealPtrReplace ( CElement ** pplhs, CElement * prhs )
{
    ReplacePtr( pplhs, prhs );

    if (pplhs && *pplhs)
        (*pplhs)->Release();
}

void
CElement::ClearPtr ( CElement * * pplhs )
{
    if (pplhs && * pplhs)
    {
        CElement * pElement = *pplhs;
        *pplhs = NULL;
        pElement->Release();
    }
}

void
CElement::ReleasePtr ( CElement * pElement )
{
    if (pElement)
    {
        pElement->Release();
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CElement::IsBlockElement
//
//  Synopsis:   Describes whether or not this node is a block element
//
//  Returns:    BOOL indicating a block element
//
//-----------------------------------------------------------------------------

BOOL
CElement::IsBlockElement ( FORMAT_CONTEXT FCPARAM )
{
    CTreeNode * pTreeNode = GetFirstBranch();

    if (pTreeNode->_iFF == -1)
        pTreeNode->GetFancyFormat(FCPARAM);

    return BOOL( pTreeNode->_fBlockNess );
}

HRESULT
CElement::get_canHaveHTML(VARIANT_BOOL *pfCanHaveHTML)
{
    HRESULT hr = S_OK;
    CDefaults *pDefaults;
    
    if (!pfCanHaveHTML)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (IsNoScope() ||
        Tag() == ETAG_PLAINTEXT ||
        Tag() == ETAG_SELECT ||
        Tag() == ETAG_XMP)
    {
        *pfCanHaveHTML = VARIANT_FALSE;
        goto Cleanup;
    }

    // see if behaviour set default canHaveHTML
    pDefaults = GetDefaults();
    if (pDefaults && pDefaults->GetAAcanHaveHTML(pfCanHaveHTML))
        goto Cleanup;
    else if (IsInMarkup())
    {
        CTreeNode *pNode = GetFirstBranch();
        Assert(pNode);
        if (!pNode->Parent() || pNode->Parent()->Tag() != ETAG_ROOT || pNode->Tag() == ETAG_HTML)
        {
            CElement *pContainer = pNode->GetContainer();
            *pfCanHaveHTML = (pContainer && pContainer->HasFlag(TAGDESC_ACCEPTHTML)) ? VARIANT_TRUE : VARIANT_FALSE;
            goto Cleanup;
        }
    }

    // if we are here, this element is in ether or is directly parented to the root and is not an <HTML> Element
    *pfCanHaveHTML = HasFlag(TAGDESC_CONTAINER) && !HasFlag(TAGDESC_ACCEPTHTML) ? VARIANT_FALSE : VARIANT_TRUE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT 
CElement::get_isMultiLine(VARIANT_BOOL *pfMultiLine) 
{
    HRESULT hr = S_OK;
    CDefaults *pDefaults;

    if (!pfMultiLine)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pfMultiLine = VARIANT_TRUE;

    // see if behaviour set default isMultiLine
    pDefaults = GetDefaults();
    if (pDefaults)
    {
        *pfMultiLine = pDefaults->GetAAisMultiLine();
        goto Cleanup;
    }

    if (Tag() == ETAG_INPUT)
        *pfMultiLine = IsTypeMultiline(DYNCAST(CInput, this)->GetType()) ? VARIANT_TRUE : VARIANT_FALSE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::get_inflateBlock(VARIANT_BOOL *pfInflate)
{
    HRESULT hr = S_OK;
    
    if (!pfInflate)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pfInflate = _fBreakOnEmpty ? VARIANT_TRUE : VARIANT_FALSE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::put_inflateBlock(VARIANT_BOOL fInflate)
{
    HRESULT hr = S_OK;
    
    if (_fBreakOnEmpty ^ !!fInflate)
    {
        CNotification nf;
        CMarkup      *pMarkupNotify;

        _fBreakOnEmpty  = fInflate;

        pMarkupNotify = GetMarkup();
        if (!pMarkupNotify)
            goto Cleanup;

        nf.ElementResize(this, 0);
        pMarkupNotify->Notify(&nf);
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::get_isContentEditable(VARIANT_BOOL *pfEditable)
{
    HRESULT hr = S_OK;
    
    if (!pfEditable)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pfEditable = IsEditable(/*fCheckContainerOnly*/FALSE) ? VARIANT_TRUE : VARIANT_FALSE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CElement::get_isDisabled(VARIANT_BOOL *pfDisabled)
{
    HRESULT hr = S_OK;
    
    if (!pfDisabled)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pfDisabled = IsEnabled() ? VARIANT_FALSE : VARIANT_TRUE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
//  Member:     CElement::IsOwnLineElement
//
//  Synopsis:   Tells us if the element is a ownline element
//
//  Returns:    BOOL indicating an ownline element
//
//-----------------------------------------------------------------------------
BOOL
CElement::IsOwnLineElement(CFlowLayout *pFlowLayoutContext)
{
    BOOL fRet;
    
    if (   (   HasFlag(TAGDESC_OWNLINE)
            || pFlowLayoutContext->IsElementBlockInContext(this)
           )
        && IsInlinedElement(LC_TO_FC(pFlowLayoutContext->LayoutContext()))
       )
    {
        fRet = TRUE;
    }
    else
        fRet = FALSE;
    
    return fRet;
}

//+----------------------------------------------------------------------------
//
//  Member:     CElement::IsBlockTag
//
//  Synopsis:   Describes whether or not this element is a block tag
//              This should rarely be used - it returns the same value no
//              matter what the display: style setting on the element is.
//              To determine if you should break lines before and after the
//              element use IsBlockElement().
//
//  Returns:    BOOL indicating a block tag
//
//-----------------------------------------------------------------------------

BOOL
CElement::IsBlockTag ( void )
{
    return HasFlag(TAGDESC_BLOCKELEMENT) || Tag() == ETAG_OBJECT;
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::BreaksLine
//
//  Synopsis:   Describes whether or not this node starts a new line
//
//  Returns:    BOOL indicating start of new line
//
//-------------------------------------------------------------------------

BOOL
CElement::BreaksLine ( void )
{
    return (IsBlockElement() &&
                !HasFlag(TAGDESC_WONTBREAKLINE));
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::HasFlag
//
//  Synopsis:   Checks if the element has an given tag
//
//  Returns:    TRUE if it has an end tag else FALSE
//
//-------------------------------------------------------------------------

BOOL
CElement::HasFlag(TAGDESC_FLAGS flag) const
{
    const CTagDesc *ptd = TagDescFromEtag(Tag());
    return ptd ? (ptd->_dwTagDescFlags & flag) ? TRUE : ptd->HasFlag(flag)
               : FALSE;
}


//+------------------------------------------------------------------------
//
//  Member:     CElement::TagName
//
//  Synopsis:   Chases the proxy and the returns the tag name of
//
//  Returns:    const TCHAR *
//
//-------------------------------------------------------------------------

const TCHAR *
CElement::TagName ()
{
    CExtendedTagDesc * pTagDesc = GetExtendedTagDesc();
    if (!pTagDesc)
    {
        return NameFromEtag(Tag());
    }
    else
    {
        Assert (pTagDesc->TagName());
        return pTagDesc->TagName();
    }
}

const TCHAR *
CElement::Namespace( )
{
    CExtendedTagDesc * pTagDesc = GetExtendedTagDesc();
    if (!pTagDesc)
    {
        return NULL;
    }
    else
    {
        Assert (pTagDesc->Namespace());
        return pTagDesc->Namespace();
    }
}

const TCHAR *
CElement::NamespaceHtml()
{
    LPCTSTR  pchNamespace = Namespace();

    return pchNamespace ? pchNamespace : _T("HTML");
}

BOOL
SameScope ( CTreeNode * pNode1, const CElement * pElement2 )
{
    // Both NULL
    if(!pNode1 && !pElement2)
        return TRUE;

    return pNode1 && pElement2
        ? pNode1->Element() == pElement2
        : FALSE;
}

BOOL
SameScope ( const CElement * pElement1, CTreeNode * pNode2 )
{
    // Both NULL
    if(!pElement1 && !pNode2)
        return TRUE;

    return pElement1 && pNode2
        ? pElement1 == pNode2->Element()
        : FALSE;
}

BOOL
SameScope ( CTreeNode * pNode1, CTreeNode * pNode2 )
{
    if (pNode1 == pNode2)
        return TRUE;

    return pNode1 && pNode2
        ? pNode1->Element() == pNode2->Element()
        : FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::NameOrIDOfParentForm
//
//  Synopsis:   Return the name or id of a parent form if one exists.
//              NULL if not.
//
//-------------------------------------------------------------------------

LPCTSTR
CElement::NameOrIDOfParentForm()
{
    CElement *  pElementForm;
    LPCTSTR     pchName = NULL;

    pElementForm = GetFirstBranch()->SearchBranchToRootForTag( ETAG_FORM )->SafeElement();

    if (pElementForm)
    {
        pchName = pElementForm->GetIdentifier();
    }
    return pchName;
}


//+------------------------------------------------------------------------
//
//  Member:     CElement::SaveAttribute
//
//  Synopsis:   Save a single attribute to the stream
//
//-------------------------------------------------------------------------

HRESULT
CElement::SaveAttribute (
    CStreamWriteBuff *      pStreamWrBuff,
    LPTSTR                  pchName,
    LPTSTR                  pchValue,
    const PROPERTYDESC *    pPropDesc /* = NULL */,
    CBase *                 pBaseObj /* = NULL */,
    BOOL                    fEqualSpaces /* = TRUE */,    // TODO (dbau) fix all the test cases so that it never has spaces
    BOOL                    fAlwaysQuote /* = FALSE */)
    
{
    HRESULT     hr;
    DWORD       dwOldFlags;

    hr = THR(pStreamWrBuff->Write(_T(" "), 1));
    if (hr)
        goto Cleanup;

    hr = THR(pStreamWrBuff->Write(pchName, _tcslen(pchName)));
    if (hr)
        goto Cleanup;

    if (pchValue || pPropDesc)
    {
        // Quotes are necessary for pages like ASP, that might have
        // <% =x %>. This will mess up the parser if we don't output
        // the quotes around such ASP expressions.
        BOOL fForceQuotes = fAlwaysQuote || !pchValue || !pchValue[0] || 
            (pchValue && ( StrChr(pchValue, _T('<')) || StrChr(pchValue, _T('>')) ));

        if (fEqualSpaces)
            hr = THR(pStreamWrBuff->Write(_T(" = ")));
        else
            hr = THR(pStreamWrBuff->Write(_T("=")));
        if (hr)
            goto Cleanup;

        // We dont want to break the line in the middle of an attribute value
        dwOldFlags = pStreamWrBuff->SetFlags(WBF_NO_WRAP);

        if (pchValue)
        {
            hr = THR(pStreamWrBuff->WriteQuotedText(pchValue, fForceQuotes));
        }
        else
        {
            Assert (pPropDesc && pBaseObj);
            hr = THR(pPropDesc->HandleSaveToHTMLStream (pBaseObj, (void *)pStreamWrBuff));
        }
        if (hr)
            goto Cleanup;

        pStreamWrBuff->RestoreFlags(dwOldFlags);
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
// Member:     CElement::SaveUnknown
//
// Synopsis:   Write these guys out
//
// Returns:    HRESULT
//
//+------------------------------------------------------------------------

HRESULT
CElement::SaveUnknown(CStreamWriteBuff * pStreamWrBuff, BOOL *pfAny)
{
    HRESULT hr = S_OK;
    AAINDEX aaix = AA_IDX_UNKNOWN;
    LPCTSTR lpPropName;
    LPCTSTR lpszValue = NULL;
    BSTR bstrTemp = NULL;
    DISPID expandoDISPID;
    BOOL fAny = FALSE;

    // Look for all expandos & dump them out
    while ( (aaix = FindAAType (CAttrValue::AA_Expando, aaix ) )
        != AA_IDX_UNKNOWN )
    {
        CAttrValue *pAV = _pAA->FindAt(aaix);

        Assert (pAV);

        // Get value into a string, but skip VT_DISPATCH & VT_UNKNOWN
        if (pAV->GetAVType() == VT_DISPATCH || pAV->GetAVType() == VT_UNKNOWN )
            continue;

        // TODO rgardner - we should smarten this up so we don't need to allocate a string

        // Found a literal attrValue
        hr = pAV->GetIntoString( &bstrTemp, &lpszValue );

        if ( hr == S_FALSE )
        {
            // Can't convert to string
            continue;
        }
        else if ( hr )
        {
            goto Cleanup;
        }

        fAny = TRUE;

        expandoDISPID = GetDispIDAt ( aaix );
        if (TestClassFlag(ELEMENTDESC_OLESITE))
        {
            expandoDISPID = expandoDISPID + DISPID_EXPANDO_BASE - DISPID_ACTIVEX_EXPANDO_BASE;
        }

        hr = GetExpandoName ( expandoDISPID, &lpPropName );
        if (hr)
            goto Cleanup;

        hr = THR(SaveAttribute(pStreamWrBuff, (LPTSTR)lpPropName, (LPTSTR)lpszValue, NULL, NULL, FALSE, TRUE)); // Always quote value: IE5 57717
        if (hr)
            goto Cleanup;

        if ( bstrTemp )
        {
            SysFreeString ( bstrTemp );
            bstrTemp = NULL;
        }
    }

    if (pfAny)
        *pfAny = fAny;

Cleanup:
    if ( bstrTemp )
        FormsFreeString ( bstrTemp );
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
// Member:     CElement::SaveUnknown
//
// Synopsis:   Write these guys out
//
// Returns:    HRESULT
//
//+------------------------------------------------------------------------

HRESULT
CElement::SaveUnknown(IPropertyBag * pPropBag, BOOL fSaveBlankAttributes )
{
    HRESULT     hr = S_OK;
    AAINDEX     aaix = AA_IDX_UNKNOWN;
    LPCTSTR     lpPropName;
    CVariant    var;
    DISPID      dispidExpando;

    while ( (aaix = FindAAType ( CAttrValue::AA_Expando, aaix )) != AA_IDX_UNKNOWN )
    {
        var.vt = VT_EMPTY;

        hr = THR(GetIntoBSTRAt(aaix, &(var.bstrVal)));
        if (hr == S_FALSE)
        {
            // Can't convert to string
            continue;
        }
        else if (hr)
        {
            goto Cleanup;
        }

        // We do not save attributes with null string values for netscape compatibility of
        // <EMBED src=thisthat loop> attributes which have no value - the loop attribute
        // in the example.   Pluginst.cxx passes in FALSE for fSaveBlankAttributes, everybody
        // else passes in TRUE via a default param value.
        if( !fSaveBlankAttributes && (var.bstrVal == NULL || *var.bstrVal == _T('\0') ) )
        {
            VariantClear (&var);
            continue;
        }

        var.vt = VT_BSTR;

        dispidExpando = GetDispIDAt(aaix);
        if (TestClassFlag(ELEMENTDESC_OLESITE))
        {
            dispidExpando = dispidExpando +
                DISPID_EXPANDO_BASE - DISPID_ACTIVEX_EXPANDO_BASE;
        }
        hr = THR(GetExpandoName(dispidExpando, &lpPropName));
        if (hr)
            goto Cleanup;

        hr = THR(pPropBag->Write(lpPropName, &var));
        if (hr)
            goto Cleanup;

        VariantClear (&var);
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Helper:     StoreLineAndOffsetInfo
//
//  Synopsis:   stores line and offset information for a property in attr array of the object
//
//-------------------------------------------------------------------------

HRESULT
StoreLineAndOffsetInfo(CBase * pBaseObj, DISPID dispid, ULONG uLine, ULONG uOffset)
{
    HRESULT         hr;
    // pchData will be of the form "ulLine ulOffset", for example: "13 1313"
    TCHAR           pchData [30];   // in only needs to be 21, but let's be safe

    hr = Format(0, &pchData, 30, _T("<0du> <1du>"), uLine, uOffset);
    if (hr)
        goto Cleanup;

    hr = THR(pBaseObj->AddString(dispid, pchData, CAttrValue::AA_Internal));

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::GetLineAndOffsetInfo
//
//  Synopsis:   retrieves line and offset information for a property from attr array
//
//  Returns:    S_OK        successfully retrieved the data
//              S_FALSE     no error, but the information in attr array is not
//                          a line/offset string
//              FAILED(hr)  generic error condition
//
//-------------------------------------------------------------------------

HRESULT
GetLineAndOffsetInfo(CAttrArray * pAA, DISPID dispid, ULONG * puLine, ULONG * puOffset)
{
    HRESULT         hr;
    CAttrValue *    pAV;
    AAINDEX         aaIdx;
    LPTSTR          pchData;
    TCHAR *         pchTempStart;
    TCHAR *         pchTempEnd;

    Assert (puOffset && puLine);

    (*puOffset) = (*puLine) = 0;      // set defaults

    //
    // get the information string
    //

    aaIdx = AA_IDX_UNKNOWN;
    pAV = pAA->Find(dispid, CAttrValue::AA_Internal, &aaIdx);
    if (!pAV || VT_LPWSTR != pAV->GetAVType())
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    pchData = pAV->GetString();

    //
    // pchData is of the format: "lLine lOffset", for example: "13 1313"
    // Here we crack the string apart.
    //

    pchTempStart = pchData;
    pchTempEnd = _tcschr(pchData, _T(' '));

    Assert (pchTempEnd);

    *pchTempEnd = _T('\0');
    hr = THR(ttol_with_error(pchTempStart, (LONG*)puLine));
    *pchTempEnd = _T(' ');
    if (hr)
        goto Cleanup;

    pchTempStart = ++pchTempEnd;

    hr = THR(ttol_with_error(pchTempStart, (LONG*)puOffset));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN1 (hr, S_FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::ConnectEventHandler
//
//  Synopsis:   retrieves string with the specified dispid from attr array, constructs
//              code from the string and puts it in attr array with dispidCode.
//              When fStandard is set, meaning that the event handler is standard,
//              such as onclick, dispid identifies script text in AA_Attribute
//              section of attr array. If fStandard is false, then dispid identifies script
//              text in AA_Expando section of attr array.
//              Also caches language attribute in ppchLanguageCached if provided.
//              uOffset and uLine specify line and offset of script text in source html -
//              this information is necessary for script debugger.
//
//-------------------------------------------------------------------------

HRESULT
CElement::ConnectInlineEventHandler(
    DISPID      dispid,
    DISPID      dispidCode,
    ULONG       uOffset,
    ULONG       uLine,
    BOOL        fStandard,
    LPCTSTR *   ppchLanguageCached,
    CHtmlComponent *pComponent)
{
    HRESULT         hr = S_OK;
    LPCTSTR         pchCode = NULL;
    IDispatch *     pDispCode = NULL;
    CAttrArray *    pAA = *GetAttrArray();
    CAttrValue *    pAV = NULL;
    CBase *         pBaseObj;
    LPCTSTR         pchLanguageLocal;
    CMarkup *       pMarkup = GetMarkup();
    WHEN_DBG(CDoc *          pDoc = Doc();)

    Assert(pMarkup);

    // Don't hook up script event handlers in print mode
    // TODO (KTam): It may be more correct to put a query to
    // ProcessURLAction(URLACTION_SCRIPT_RUN) in the callers of this fn;
    // this is already happening in some cases (consider changing
    // CPeerSite::GetEventCookieHelper)
    if (pMarkup->DontRunScripts())
        goto Cleanup;
    //
    // get language
    //

    if (!ppchLanguageCached)
    {
        pchLanguageLocal = NULL;
        ppchLanguageCached = &pchLanguageLocal;
    }

    if (!(*ppchLanguageCached))
    {
        if (pAA == NULL || !pAA->FindString (DISPID_A_LANGUAGE, ppchLanguageCached, CAttrValue::AA_Attribute))
        {
            (*ppchLanguageCached) = _T("");
        }
    }

    //
    // get base object and code
    //

    pBaseObj = GetBaseObjectFor (dispid);

    if (!pBaseObj || !(*(pBaseObj->GetAttrArray())))
        goto Cleanup;

    // this is supposed to be found because of the logic dispid-s passed in this function (alexz)
    //   however, for peers on the object tag, the expandos are saved as activeX_EXPANDOS and we
    //   need to search for a differnt dispid
    // (JHarding) It's also possible the dispatch has already been set up.  We'll take that, too.
    pAV = (*(pBaseObj->GetAttrArray()))->Find( dispid, fStandard ? CAttrValue::AA_Attribute :
                                                                   CAttrValue::AA_Expando );
    if( !pAV )
        pAV = (*(pBaseObj->GetAttrArray()))->Find( ((dispid - DISPID_EXPANDO_BASE) + DISPID_ACTIVEX_EXPANDO_BASE),
                                                   CAttrValue::AA_Expando );
    if( !pAV )
        goto Cleanup;

    if( pAV->GetAVType() == VT_DISPATCH )
    {
        pDispCode = pAV->GetDispatch();
        if( pDispCode )
            pDispCode->AddRef();
    }
    else if( pAV->GetAVType() == VT_LPWSTR )
    {
        pchCode = pAV->GetLPWSTR();
    }

    if( !pchCode && !pDispCode )
        goto Cleanup;

    //
    // debug stuff
    //

#if DBG==1
    if (pchCode && IsTagEnabled(tagHtmSrcTest))
    {
        TCHAR achSrc[512];
        ULONG cch;

        HRESULT hrT;

        hrT = pDoc->GetHtmSourceText(uOffset, ARRAY_SIZE(achSrc) - 1,
                achSrc, &cch);

        if (hrT == S_OK)
        {
            cch = min(cch, (ULONG)_tcslen(pchCode));
            achSrc[cch] = 0;

            TraceTag((
                tagHtmSrcTest,
                "Expect \"%.64ls\", (ln=%ld pos=%ld) \"%.64ls\"",
                pchCode, uLine, uOffset, achSrc));
        }
    }
#endif

    //
    // get previously stored line/offset information
    //

    if (!fStandard && !pDispCode)
    {
        Assert (0 == uLine && 0 == uOffset);

        hr = THR(GetLineAndOffsetInfo(pAA, dispid, &uLine, &uOffset));
        if (!OK(hr))        // if not S_OK or S_FALSE
            goto Cleanup;
    }

    //
    // construct code and handle result
    //

    if( !pDispCode )
    {
        CScriptCollection *pScriptCollection;
        TCHAR *pchNamespace = (LPTSTR)NameOrIDOfParentForm();
        
        if (!pchNamespace && !pMarkup->HasWindowPending())
        {
            if (pComponent)
            {
                pchNamespace = pComponent->GetNamespace();
            }
            else
            {
                CMarkupScriptContext *pScriptContext;
                hr = THR(pMarkup->EnsureScriptContext(&pScriptContext));
                if (!hr)
                    pchNamespace = pScriptContext->GetNamespace();
            }

            Assert(pchNamespace || (pMarkup->_fMarkupServicesParsing && (Tag() == ETAG_OBJECT)));
        }

        pScriptCollection = pMarkup->GetScriptCollection();
        if (pScriptCollection)
        {
            hr = THR_NOTRACE(pScriptCollection->ConstructCode(
                pchNamespace,                       // pchScope
                (LPTSTR)pchCode,                    // pchCode
                NULL,                               // pchFormalParams
                (LPTSTR)(*ppchLanguageCached),      // pchLanguage
                pMarkup,                            // pMarkup
                NULL,                               // pchType (valid on script tags only)
                uOffset,                            // ulOffset
                uLine,                              // ulStartingLine
                pMarkup,                            // pSourceObject
                SCRIPTPROC_HOSTMANAGESSOURCE,       // dwFlags
                &pDispCode,                         // ppDispCode result
                TRUE,                               // fSingleLine
                pComponent));                       // An instance of lightwight behavior whose <ATTACH> tag is being hooked up
        }
    }

    if (S_OK == hr && pDispCode)
    {
        // pDispCode can be NULL if the script was parsed
        // but it contained no executeable statements
        hr = THR(pBaseObj->AddDispatchObject(
            dispidCode,
            pDispCode,
            CAttrValue::AA_Internal,
            CAttrValue::AA_Extra_OldEventStyle));
        ClearInterface (&pDispCode);
        if (hr)
            goto Cleanup;

        // if we add a data event to an element, make sure the event can fire
        CDataMemberMgr::EnsureDataEventsFor(pBaseObj, dispid);
    }
    else if (E_NOTIMPL == hr && !pDispCode)
    {
        //
        // ConstructCode must have failed because we are parsing VBScript and it does not support
        // function pointers. In this case, we will do AddScriptlet in CElement::AddAllScriptlets.
        // The only thing we need to do now is to store line/offset numbers in attr array in
        // AA_Internal section, if it is not there yet.
        // There are 2 codepaths which can lead us here:
        // 1.   We call this method from CElement::InitAttrBag to connect standard inline
        // event handlers, such as onclick. We call it passing actual line/offset information
        // available there from CHtmlTag * pht. In this case line/offset information is passed
        // and we store it
        // 2.   We call this method from CPeerHolder::RegisterEvent to connect custom peer event
        // handler. In this case the event handler is an expando and line/offset information was
        // stored for it in CElement::InitAttrBag; we don't need to do anything.

        if (fStandard) // equivalent to condition (0 != uLine || 0 != uOffset)
        {
            hr = StoreLineAndOffsetInfo (pBaseObj, dispid, uLine, uOffset);
            if (hr)
                goto Cleanup;
        }
    }
    
    // Don't propagate the last error - code construction could have failed due to
    // syntax errors so try to construct other event handlers
    hr = S_OK;

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::InitAttrBag
//
//  Synopsis:   Fetch values from CHtmTag and put into the bag
//
//  Arguments:  pht : parsed attributes in text format
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CElement::InitAttrBag(CHtmTag *pht, CMarkup * pMarkup)
{
    int i;
    CHtmTag::CAttr *pattr = NULL;
    HRESULT hr = S_OK;
    const PROPERTYDESC * ppropdesc;
    CBase *pBaseObj;
    InlineEvts  *pInlineEvts = NULL;
    WORD    wMaxstrlen = 0;
    TCHAR   chOld = _T('\0');
    THREADSTATE * pts = GetThreadState();
// HACK HACK 47681 start: ignore height/width for inputs not input/image
    BOOL    fHackForInput;
    BOOL    fHackForInputProp;
// HACK HACK 47681 end

    BOOL fIsStrictCSS1;

    if (*GetAttrArray())
    {
        // InitAttrBag must have already been called.
        return S_OK;
    }

    pts->fInInitAttrBag = TRUE;

// HACK HACK 47681 start: ignore height/width for inputs not input/image
    fHackForInput = (Tag() == ETAG_INPUT && DYNCAST(CInput, this)->GetType() != htmlInputImage);
// HACK HACK 47681 end

    // Loop over all attr pairs in the tag, and see if their BYTE in the known-attr array
    // is set; if not, add the attr and any val to the CaryUnknownAttrs in the attr bag
    // (create one if needed).

    for (i = pht ? pht->GetAttrCount() : 0; --i >= 0; )
    {
        pattr = pht->GetAttr(i);

        if (!pattr->_pchName)
            continue;

// HACK HACK 47681 start: ignore height/width for inputs not input/image
        fHackForInputProp = fHackForInput && 
                (StrCmpIC(s_propdescCInputheight.a.pstrName, pattr->_pchName) == 0
                || StrCmpIC(s_propdescCInputwidth.a.pstrName, pattr->_pchName) == 0);

        if (!fHackForInputProp && (ppropdesc = FindPropDescForName(pattr->_pchName)) != NULL)
//
// HACK HACK 47681 end. uncomment the following line when removing the HACK section
        // if ((ppropdesc = FindPropDescForName(pattr->_pchName)) != NULL)
        {
            // Allow some elements to redirect to another attr array
            pBaseObj = GetBaseObjectFor(ppropdesc->GetDispid(), pMarkup);

            if (!pBaseObj)
            {
                continue;
            }

#ifndef WIN16
            // BUGWIN16: HandleLoadFromHTMLString is a class method, I am amazed that we can check
            // for it being non - null !? - vamshi - 4/29/97
#ifndef UNIX
// Unix gets, Error: Taking address of the bound function PROPERTYDESC::HandleLoadFromHTMLString(CBase*, wchar_t*) const.
//             AssertSz(ppropdesc->HandleLoadFromHTMLString != NULL, "attempt to load abstract property from html");
#endif
#endif
            wMaxstrlen = (ppropdesc->GetBasicPropParams()->wMaxstrlen == pdlNoLimit) ? 0 :
                         (ppropdesc->GetBasicPropParams()->wMaxstrlen ? ppropdesc->GetBasicPropParams()->wMaxstrlen : DEFAULT_ATTR_SIZE);

            if (wMaxstrlen && pattr->_pchVal && _tcslen(pattr->_pchVal) > wMaxstrlen)
            {
                chOld = pattr->_pchVal[wMaxstrlen];
                pattr->_pchVal[wMaxstrlen] = _T('\0');
            }

            // InitAttrBag (this function) is responsible for applying the attributes on an html element. Normal attributes, i.e. all attributes on html
            // except "style", doesn't take care about css1 strictness. Only when applying the inline style attribute value it has to be taken into account
            // if we are in strict css1 or not. In <HTMLELEM style="...">  the DISPID for the "style" attribute is DISPID_CElement_style_Str.
            fIsStrictCSS1 = pMarkup->IsStrictCSS1Document() && (ppropdesc->GetDispid() == DISPID_CElement_style_Str);

            hr = THR_NOTRACE( ppropdesc->HandleLoadFromHTMLString ( pBaseObj, pattr->_pchVal, fIsStrictCSS1 ? HANDLEPROP_STRICTCSS1 : 0 ));

            if (ppropdesc->GetPPFlags() & PROPPARAM_SCRIPTLET)
            {
                if (!pInlineEvts)
                    pInlineEvts = new InlineEvts;

                if (pInlineEvts)
                {
                    pInlineEvts->adispidScriptlets[pInlineEvts->cScriptlets] = ppropdesc->GetDispid();
                    pInlineEvts->aOffsetScriptlets[pInlineEvts->cScriptlets] = pattr->_ulOffset;
                    pInlineEvts->aLineScriptlets[pInlineEvts->cScriptlets++] = pattr->_ulLine;
                }
                else
                    goto Cleanup;
            }

            if ( hr )
            {
                // Create an "unknown" attribute containing the original string from the HTML
                // SetString with fIsUnkown set to TRUE
                if (chOld)
                {
                    pattr->_pchVal[wMaxstrlen] = chOld;
                    chOld = 0;
                }
                hr = CAttrArray::SetString ( pBaseObj->GetAttrArray(), ppropdesc,
                    pattr->_pchVal, TRUE, CAttrValue::AA_Extra_DefaultValue );
            }

            // If the parameter was invalid, value will get set to default &
            // parameter will go into the unknown bag
            if ( !hr )
            {
                if ( ppropdesc->GetDispid() == DISPID_A_BACKGROUNDIMAGE )
                {
                    // Fork off an early download for background images
                    LPCTSTR lpszURL;
                    if ( !(*(pBaseObj->GetAttrArray()))->FindString(DISPID_A_BACKGROUNDIMAGE, &lpszURL) )
                    {
                        LONG lCookie;

                        if (GetImageUrlCookie(lpszURL, &lCookie, TRUE) == S_OK)
                        {
                            hr = THR(AddImgCtx(DISPID_A_BGURLIMGCTXCACHEINDEX, lCookie));
                            if (hr)
                            {
                                Doc()->ReleaseUrlImgCtx(lCookie, this);
                                goto Cleanup;
                            }
                        }
                    }
                }
            }
            else if (hr == E_OUTOFMEMORY)
            {
                goto Cleanup;
            }
        }
        else if (pMarkup->_fExpando)
        {
            DISPID  expandoDISPID;

            if (pMarkup->HasBehaviorContext() && ETAG_GENERIC_BUILTIN == Tag())
            {
                CHtmlComponent *pComponent = pMarkup->BehaviorContext()->_pHtmlComponent;
                // NOTE: Need to make sure that the parser ensures that the first buitin tag in a htc
                // is the HTC or COMPONENT tag for this to work reliably.
                if (pComponent &&
                    !pComponent->Dirty() &&
                    pComponent->_fFactoryComponent &&
                    !pComponent->_fLightWeight &&
                    (HTC_BEHAVIOR_DESC & TagNameToHtcBehaviorType(TagName())) &&
                    (StrCmpIC(_T("lightweight"), pattr->_pchName) == 0) &&
                    StringToBool(pattr->_pchVal))
                {
                    pComponent->_fLightWeight = TRUE;
                }

                if (pComponent &&
                    !pComponent->Dirty() &&
                    (pComponent->_fLightWeight || (!pComponent->_fFactoryComponent && pComponent->_fFirstInstance)) &&
                    pattr->_pchVal &&
                    *(pattr->_pchVal) &&
                    (HTC_BEHAVIOR_PROPERTYORMETHOD & TagNameToHtcBehaviorType(TagName())) &&
                    StrCmpIC(_T("NAME"), pattr->_pchName) == 0)
                {
                    if (pComponent->_fLightWeight)
                    {
                        Assert(pComponent->_fFactoryComponent);
                        pComponent->AddAtom(pattr->_pchVal, (LPVOID)this);
                    }
                    else if (!pComponent->_fFactoryComponent && pComponent->_fFirstInstance)
                    {
                        // cache the name of htc prop\method for faster retreival later in EnterTree
                        Assert(!DYNCAST(CGenericElement, this)->GetName());
                        DYNCAST(CGenericElement, this)->_cstrContents.Set(pattr->_pchVal);
                    }
                }
            }

            // Create an expando

            hr = THR_NOTRACE(AddExpando(pattr->_pchName, &expandoDISPID));

            Assert(expandoDISPID);

            if (hr == DISP_E_MEMBERNOTFOUND)
            {
                hr = S_OK;
                continue; // Expando not turned on
            }
            if (hr)
                goto Cleanup;

            if (TestClassFlag(ELEMENTDESC_OLESITE))
            {
                expandoDISPID = expandoDISPID - DISPID_EXPANDO_BASE +
                    DISPID_ACTIVEX_EXPANDO_BASE;
            }

            // Note that we always store expandos in the current object - we never redirect them
            hr = THR(AddString(
                    expandoDISPID,
                    pattr->_pchVal,
                    CAttrValue::AA_Expando));
            if (hr)
                goto Cleanup;

            // if begins with "on", this can be a peer registered event - need to store line/offset numbers
            if (0 == StrCmpNIC(_T("on"), pattr->_pchName, 2))
            {
                hr = THR(StoreLineAndOffsetInfo(this, expandoDISPID, pattr->_ulLine, pattr->_ulOffset));
                if (hr)
                    goto Cleanup;
            }
        }

        if (chOld)
        {
            pattr->_pchVal[wMaxstrlen] = chOld;
            chOld = _T('\0');
        }
    }

    if (pInlineEvts && pInlineEvts->cScriptlets && (ETAG_UNKNOWN != Tag()) && pMarkup && pMarkup->GetScriptCollection())
    {
        SetEventsShouldFire();

        StoreEventsToHook(pInlineEvts);
        pInlineEvts = NULL; // Make sure we don't free it.
    }

Cleanup:
    if (pInlineEvts)
        delete pInlineEvts;
    if (chOld)
        pattr->_pchVal[wMaxstrlen] = chOld;

    pts->fInInitAttrBag = FALSE;

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::MergeAttrBag
//
//  Synopsis:   Add any value from CHtmTag that are not already present
//              in the attrbag
//
//              Note: currently, expandos are not merged.
//
//  Arguments:  pht : parsed attributes in text format
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CElement::MergeAttrBag(CHtmTag *pht)
{
    int i;
    CHtmTag::CAttr *pattr = NULL;
    HRESULT hr = S_OK;
    const PROPERTYDESC * ppropdesc;
    InlineEvts inlineEvts;
    CBase *pBaseObj;
    WORD    wMaxstrlen = 0;
    TCHAR   chOld = _T('\0');
    CDoc *  pDoc = Doc();

    // Loop over all attr pairs in the tag, and see if their BYTE in the known-attr array
    // is set; if not, add the attr and any val to the CaryUnknownAttrs in the attr bag
    // (create one if needed).

    for (i = pht ? pht->GetAttrCount() : 0; --i >= 0; )
    {
        pattr = pht->GetAttr(i);

        if (!pattr->_pchName)
            continue;

        if ((ppropdesc = FindPropDescForName(pattr->_pchName)) != NULL)
        {
            // Allow some elements to redirect to another attr array
            pBaseObj = GetBaseObjectFor (ppropdesc->GetDispid());

            // Only add the attribute if it has not been previously defined
            // style attribute requires special handling
            if (!pBaseObj
                || (AA_IDX_UNKNOWN != pBaseObj->FindAAIndex(ppropdesc->GetDispid(), CAttrValue::AA_Attribute))
                || (AA_IDX_UNKNOWN != pBaseObj->FindAAIndex(ppropdesc->GetDispid(), CAttrValue::AA_UnknownAttr))
                || (AA_IDX_UNKNOWN != pBaseObj->FindAAIndex(ppropdesc->GetDispid(), CAttrValue::AA_Internal))
                || (AA_IDX_UNKNOWN != pBaseObj->FindAAIndex(ppropdesc->GetDispid(), CAttrValue::AA_AttrArray))
                || (ppropdesc == (PROPERTYDESC *)&s_propdescCElementstyle_Str && AA_IDX_UNKNOWN != pBaseObj->FindAAIndex(DISPID_INTERNAL_INLINESTYLEAA, CAttrValue::AA_AttrArray)))
            {
                continue;
            }

            wMaxstrlen = (ppropdesc->GetBasicPropParams()->wMaxstrlen == pdlNoLimit) ? 0 :
                         (ppropdesc->GetBasicPropParams()->wMaxstrlen ? ppropdesc->GetBasicPropParams()->wMaxstrlen : DEFAULT_ATTR_SIZE);

            if (wMaxstrlen && pattr->_pchVal && _tcslen(pattr->_pchVal) > wMaxstrlen)
            {
                chOld = pattr->_pchVal[wMaxstrlen];
                pattr->_pchVal[wMaxstrlen] = _T('\0');
            }
            hr = THR ( ppropdesc->HandleMergeFromHTMLString ( pBaseObj, pattr->_pchVal ) );

            if (ppropdesc->GetPPFlags() & PROPPARAM_SCRIPTLET)
            {
                inlineEvts.adispidScriptlets[inlineEvts.cScriptlets] = ppropdesc->GetDispid();
                inlineEvts.aOffsetScriptlets[inlineEvts.cScriptlets] = pattr->_ulOffset;
                inlineEvts.aLineScriptlets[inlineEvts.cScriptlets++] = pattr->_ulLine;
            }

            if (hr)
            {
                // Create an "unknown" attribute containing the original string from the HTML
                // SetString with fIsUnkown set to TRUE
                hr = CAttrArray::SetString ( pBaseObj->GetAttrArray(), ppropdesc,
                    pattr->_pchVal, TRUE, CAttrValue::AA_Extra_DefaultValue );
            }

            // If the parameter was invalid, value will get set to default &
            // parameter will go into the unknown bag
            if ( !hr )
            {
                if ( ppropdesc->GetDispid() == DISPID_A_BACKGROUNDIMAGE )
                {
                    // Fork off an early download for background images
                    LPCTSTR lpszURL;
                    if ( !(*(pBaseObj->GetAttrArray()))->FindString(DISPID_A_BACKGROUNDIMAGE, &lpszURL) )
                    {
                        LONG lCookie;

                        if (GetImageUrlCookie(lpszURL, &lCookie, TRUE) == S_OK)
                        {
                            hr = THR(AddImgCtx(DISPID_A_BGURLIMGCTXCACHEINDEX, lCookie));
                            if (hr)
                            {
                                pDoc->ReleaseUrlImgCtx(lCookie, this);
                                goto Cleanup;
                            }
                        }
                    }
                }
            }
            else if (hr == E_OUTOFMEMORY)
            {
                goto Cleanup;
            }
        }
        
        if (chOld)
        {
            pattr->_pchVal[wMaxstrlen] = chOld;
            chOld = _T('\0');
        }
    }
    
     hr = THR(inlineEvts.Connect(pDoc, this));
     if (hr)
         goto Cleanup;

Cleanup:
    if (chOld)
        pattr->_pchVal[wMaxstrlen] = chOld;

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::Init2
//
//  Synopsis:   Perform any element level initialization
//
//-------------------------------------------------------------------------

HRESULT
CElement::Init2(CInit2Context * pContext)
{
    HRESULT         hr = S_OK;
    LPCTSTR         pch;
    CDoc *          pDoc = Doc();
    CAttrArray *    pAAInline;

    Assert( !IsInMarkup() && pContext->_pTargetMarkup );
    Assert( !HasWindowedMarkupContextPtr() );
    
    hr = THR(SetWindowedMarkupContextPtr( pContext->_pTargetMarkup->GetWindowedMarkupContext() ) );
    if( hr )
        goto Cleanup;

    GetWindowedMarkupContextPtr()->SubAddRef();

    pch = GetIdentifier();
    if (pch)
    {
        hr = THR(pDoc->_AtomTable.AddNameToAtomTable(pch, NULL));
        if (hr)
            goto Cleanup;
    }

    //
    // behaviors support
    //

    // TODO (alexz) see if it is possible to make it without parsing inline styles here
    pAAInline = GetInLineStyleAttrArray();
    if (pAAInline && pAAInline->Find(DISPID_A_BEHAVIOR))
    {
        pDoc->SetCssPeersPossible();
    }

#ifdef NEVER
    //
    // Set the _fTabStop bit for all the default tags.
    //

    switch (etag)
    {
    case ETAG_HR:
    case ETAG_DIV:
    case ETAG_TABLE:
    case ETAG_IMG:
        if (pDoc->_fDesignMode)
        {
            _fTabStop = TRUE;
        }
        break;

    case ETAG_LABEL:
    case ETAG_A:
    case ETAG_FRAME:
    case ETAG_EMBED:
    case ETAG_LEGEND:
        if (etag == ETAG_FRAME && _fSynthesized)
            break;

        if (!pDoc->_fDesignMode)
        {
            _fTabStop = TRUE;
        }
        break;

    case ETAG_INPUT:
    case ETAG_SELECT:
    case ETAG_TEXTAREA:
    case ETAG_BUTTON:
#ifdef  NEVER
    case ETAG_HTMLAREA:
#endif
    case ETAG_IFRAME:
    case ETAG_OBJECT:
    case ETAG_APPLET:
        if (etag == ETAG_IFRAME && _fSynthesized)
            break;

        _fTabStop = TRUE;
       break;

    case ETAG_MAP:
    case ETAG_AREA:
        _fTabStop = FALSE;
        break;

    default:
        if (GetAAtabIndex() > 0)
        {
            _fTabStop = TRUE;
        }
        break;
    }
#endif

    hr = THR(InitExtendedTag(pContext));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::Save
//
//  Synopsis:   Save the element to the stream
//
//-------------------------------------------------------------------------

HRESULT
CElement::Save(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd)
{
    HRESULT hr;

    if (fEnd && HasFlag(TAGDESC_SAVEINDENT))
    {
        pStreamWrBuff->EndIndent();
    }

    hr = WriteTag(pStreamWrBuff, fEnd);
    if(hr)
        goto Cleanup;

    if (!fEnd && HasFlag(TAGDESC_SAVEINDENT))
    {
        pStreamWrBuff->BeginIndent();
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::SaveAttributes
//
//  Synopsis:   Save the attributes to the stream
//
//-------------------------------------------------------------------------

HRESULT
CElement::SaveAttributes ( CStreamWriteBuff * pStreamWrBuff, BOOL *pfAny )
{
    HRESULT hr = S_OK;
    BOOL fSave;
    LPCTSTR lpstrUnknownValue;
    CBase *pBaseObj;
    BOOL fAny = FALSE;

    // For printing, we let behaviors save their attributes first -- this is a hack to get
    // around the fact that if both the behavior and the element have the same attribute, they'll
    // both be persisted.  The parser lets the first one encountered win, and we want the behavior
    // to win.  Bug #94236 (KTam, JHarding)
    if (pStreamWrBuff->TestFlag(WBF_SAVE_FOR_PRINTDOC))
    {
        if (HasPeerHolder())
        {
            IGNORE_HR(GetPeerHolder()->SaveMulti(pStreamWrBuff, fAny ? NULL : &fAny));
        }
    }
    
    CPtrBagVTableAggregate::CIterator vTableIterator(GetStringTableAggregate());

    for (vTableIterator.Start(VTABLEDESC_BELONGSTOPARSE); !vTableIterator.End(); vTableIterator.Next())
    {
        const VTABLEDESC *pVTblDesc = vTableIterator.Item();
        Assert(pVTblDesc);
        const PROPERTYDESC *ppropdesc = pVTblDesc->FastGetPropDesc(VTABLEDESC_BELONGSTOPARSE);
        Assert(ppropdesc);

        // NOTE for now check for the method pointer because of old property implementation...
        if (!ppropdesc->pfnHandleProperty)
        {
            continue;
        }

        pBaseObj = GetBaseObjectFor (ppropdesc->GetDispid());

        if (!pBaseObj)
        {
            continue;
        }

        lpstrUnknownValue = NULL;
        if ( ppropdesc->GetPPFlags() & PROPPARAM_ATTRARRAY)
        {
            AAINDEX aaIx = AA_IDX_UNKNOWN;
            CAttrValue *pAV = NULL;
            CAttrArray *pAA = *(pBaseObj->GetAttrArray());

            if (pAA)
                pAV = pAA->Find(ppropdesc->GetDispid(), CAttrValue::AA_Attribute, &aaIx);

            if (pAA && (!pAV || pAV->IsDefault()))
            {
                if (pAV)
                    aaIx++;

                pAV = pAA->FindAt(aaIx);
                if (pAV)
                {
                    if ((pAV->GetDISPID() == ppropdesc->GetDispid()) &&
                        (pAV->GetAAType() == CAttrValue::AA_UnknownAttr))
                    {
                        // Unknown attrs are always strings
                        lpstrUnknownValue = pAV->GetLPWSTR();
                    }
                    else
                        pAV = NULL;
                }
            }
            fSave = !!pAV;

            // don't save databinding attributes during printing, so that we
            // print the current content instead of re-binding
            if (pStreamWrBuff->TestFlag(WBF_NO_DATABIND_ATTRS))
            {
                DISPID dispid = ppropdesc->GetDispid();
                if (    dispid == DISPID_CElement_dataSrc ||
                        dispid == DISPID_CElement_dataFld ||
                        dispid == DISPID_CElement_dataFormatAs)
                    fSave = FALSE;
            }
        }
        else
        {
            // Save the property if it was not the same as the default.
            // Do not save if we got an error retrieving it.
            fSave = ppropdesc->HandleCompare ( pBaseObj,
                (void *)&ppropdesc->ulTagNotPresentDefault ) == S_FALSE;
        }

        if (fSave)
        {
            fAny = TRUE;

            if (lpstrUnknownValue)
            {
                hr = THR(SaveAttribute(
                    pStreamWrBuff,
                    (LPTSTR)ppropdesc->pstrName,
                    (LPTSTR)lpstrUnknownValue,  // pchValue
                    NULL,                       // ppropdesc
                    NULL,                       // pBaseObj
                    FALSE));                    // fEqualSpaces
            }
            else
            {
                if (ppropdesc->IsBOOLProperty())
                {
                    hr = THR(SaveAttribute(
                        pStreamWrBuff,
                        (LPTSTR)ppropdesc->pstrName,
                        NULL,                       // pchValue
                        NULL,                       // ppropdesc
                        NULL,                       // pBaseObj
                        FALSE));                    // fEqualSpaces
                }
                else
                    hr = THR(SaveAttribute(
                        pStreamWrBuff,
                        (LPTSTR)ppropdesc->pstrName,
                        NULL,                       // pchValue
                        ppropdesc,                  // ppropdesc
                        pBaseObj,                   // pBaseObj
                        FALSE));                    // fEqualSpaces
            }
        }
    }

    hr = SaveUnknown(pStreamWrBuff, fAny ? NULL : &fAny);
    if (hr)
        goto Cleanup;

    // If we are persisting for anything other than printing, then
    // save behavior attributes at this point (compat).
    if (!pStreamWrBuff->TestFlag(WBF_SAVE_FOR_PRINTDOC))
    {
        if (HasPeerHolder())
        {
            IGNORE_HR(GetPeerHolder()->SaveMulti(pStreamWrBuff, fAny ? NULL : &fAny));
        }
    }

    if (pfAny)
        *pfAny = fAny;

Cleanup:
    RRETURN (hr);

}


//+------------------------------------------------------------------------
//
//  Member:     CElement::SaveAttributes
//
//  Synopsis:   Save the attributes into property bag
//
//-------------------------------------------------------------------------

HRESULT
CElement::SaveAttributes ( IPropertyBag * pPropBag, BOOL fSaveBlankAttributes )
{
    CPtrBagVTableAggregate::CIterator vTableIterator(const_cast<CPtrBagVTableAggregate *>(GetStringTableAggregate()));

    HRESULT             hr = S_OK;
    CVariant            Var;
    BOOL                fSave;
    CBase               *pBaseObj;

    if (!vTableIterator._pAggregateTable)
        goto Cleanup;
        
    for (vTableIterator.Start(VTABLEDESC_BELONGSTOPARSE); !vTableIterator.End(); vTableIterator.Next())
    {
        const VTABLEDESC *pVTblDesc = vTableIterator.Item();
        Assert(pVTblDesc);
        const PROPERTYDESC *ppropdesc = pVTblDesc->FastGetPropDesc(VTABLEDESC_BELONGSTOPARSE);
        Assert(ppropdesc);

        // NOTE for now check for the method pointer because of old property implementation...
        if (!ppropdesc->pfnHandleProperty)
        {
            continue;
        }

        pBaseObj = GetBaseObjectFor (ppropdesc->GetDispid());

        if (!pBaseObj)
        {
            continue;
        }

        if (ppropdesc->GetPPFlags() & PROPPARAM_ATTRARRAY)
        {
            AAINDEX aaIx;
            aaIx = pBaseObj->FindAAIndex ( ppropdesc->GetDispid(), CAttrValue::AA_Attribute );
            fSave = ( aaIx == AA_IDX_UNKNOWN ) ? FALSE : TRUE;
        }
        else
        {
            // Save the property if it was not the same as the default.
            // Do not save if we got an error retrieving it.
            fSave = ppropdesc->HandleCompare ( pBaseObj,
                (void *)&ppropdesc->ulTagNotPresentDefault ) == S_FALSE;
        }

        if (fSave)
        {
            // If we're dealing with a BOOL type, don't put a value
            if ( ppropdesc->IsBOOLProperty() )
            {
                // Boolean (flag), skip the =<val>
                Var.vt = VT_EMPTY;
            }
            else
            {
                hr = THR(ppropdesc->HandleGetIntoBSTR ( pBaseObj, &V_BSTR(&Var) ));
                if (hr)
                    continue;
                V_VT(&Var) = VT_BSTR;
            }
            hr = pPropBag->Write(ppropdesc->pstrName, &Var);
            if (hr)
                goto Cleanup;
            // if Var has an Allocated value, we need to free it before
            // going around the loop again.
            VariantClear(&Var);
        }
    }

    hr = SaveUnknown(pPropBag, fSaveBlankAttributes);

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CElement::HandleMessage
//
//  Synopsis:   Perform any element specific mesage handling
//
//  Arguments:  pmsg    Ptr to incoming message
//
//  Notes:      pBranch should always be non-scoped. This is the only way
//              that the context information can be maintained. each element
//              HandleMessage which uses pBranch needs to be very careful
//              to scope first.
//
//-------------------------------------------------------------------------

HRESULT
CElement::HandleMessage(CMessage *pmsg)
{
    HRESULT     hr                  = S_FALSE;

    // Only the marquee is allowed to cheat and pass the wrong
    // context in
    Assert(IsInMarkup());

    if (pmsg->message == WM_SETCURSOR && pmsg->htc == HTC_BEHAVIOR && pmsg->lBehaviorCookie )
    {
        if ( CHECK_EDIT_BIT( GetMarkup(), _fOverrideCursor ))
        {
            hr = S_OK; // we don't touch the cursor - up to the host.        
            goto Cleanup;
        }
        
        CPeerHolder *pPH = FindPeerHolder(pmsg->lBehaviorCookie);

        if (pPH)
        {
            hr = pPH->SetCursor(pmsg->lBehaviorPartID);
        }
    }

    if (hr != S_OK)
    {
        CLayout * pLayout = GetUpdatedLayout( pmsg->pLayoutContext );

        if (pLayout)
        {
            Assert(!pmsg->fStopForward);
            hr = THR(pLayout->HandleMessage(pmsg));
            if (hr != S_FALSE || pmsg->fStopForward)
                goto Cleanup;
        }
        else if (   WM_CONTEXTMENU == pmsg->message
                &&  HasCapture()
                &&  !Doc()->_pInPlace->_fBubbleInsideOut)
        {
            hr = THR(OnContextMenu(
                    (short) LOWORD(pmsg->lParam),
                    (short) HIWORD(pmsg->lParam),
                    CONTEXT_MENU_DEFAULT));
        }


        if (pmsg->message == WM_SETCURSOR)
        {
            hr = THR_NOTRACE(SetCursorStyle((LPTSTR)NULL, GetFirstBranch()));
        }
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+------------------------------------------------------------------------
//
//  Member:     DisallowSelection
//
//  Synopsis:   Returns TRUE iff selection must be diallowed.
//
//-------------------------------------------------------------------------

BOOL
CElement::DisallowSelection()
{
    // In dialogs, only editable controls can be selected
    return ((Doc()->_dwFlagsHostInfo & DOCHOSTUIFLAG_DIALOG)
         && !(ShouldHaveLayout() && GetUpdatedLayout( GUL_USEFIRSTLAYOUT )->_fAllowSelectionInDialog && IsEnabled()));
}


//+------------------------------------------------------------------------
//
//  Member:     CloseErrorInfo
//
//  Synopsis:   Pass the call to the form so it can return its clsid
//              instead of the object's clsid as in CBase.
//
//-------------------------------------------------------------------------

HRESULT
CElement::CloseErrorInfo(HRESULT hr)
{
    Doc()->CloseErrorInfo(hr);

    return hr;
}

LPCTSTR GetCursorForStyle( BYTE iIndex )
{

    static const LPCTSTR aStyleToCursor[] = 
    {
        IDC_ARROW,                       // auto map to arrow
        IDC_CROSS,                       // map to crosshair
        IDC_ARROW,                       // default map to arrow
        MAKEINTRESOURCE(IDC_HYPERLINK),  // hand map to IDC_HYPERLINK
        IDC_SIZEALL,                     // move map to SIZEALL
        IDC_SIZEWE ,                     // e-resize
        IDC_SIZENESW,                    // ne-resize
        IDC_SIZENWSE,                    // nw-resize
        IDC_SIZENS,                      // n-resize
        IDC_SIZENWSE,                    // se-resize
        IDC_SIZENESW,                    // sw-resize
        IDC_SIZENS,                      // s-resize
        IDC_SIZEWE ,                     // w-resize
        IDC_IBEAM,                       // text
        IDC_WAIT,                        // wait
#if(WINVER >= 0x0400)
        IDC_HELP,                        // help as IDC_help
#else
        IDC_ARROW,                       // help as IDC_ARROW
#endif
        MAKEINTRESOURCE(IDC_HYPERLINK),  // pointer maps to IDC_HYPERLINK

        //
        // New cursors
        //
        IDC_APPSTARTING,                 // "spinning"
        IDC_NO,                          // "not-allowed"
                
        MAKEINTRESOURCE(IDC_HYPERLINK_OFFLINE),               // "no-drop"        
        MAKEINTRESOURCE(IDC_HIBEAM),                          // vertical text
        MAKEINTRESOURCE(IDC_NOSCROLLVH),                      // all-scroll - need to find    
        MAKEINTRESOURCE(IDC_RESIZECOL2),                      // "col-resize"
        MAKEINTRESOURCE(IDC_RESIZEROW2),                      // "row-resize"
    };
    Assert(iIndex >= 0 && iIndex < ARRAY_SIZE(aStyleToCursor));

    return aStyleToCursor[iIndex];
}

CCustomCursor*
GetCustomCursorForNode(CTreeNode* pStartNode)
{
    const CFancyFormat* pFF = pStartNode->GetFancyFormat();  
    CTreeNode * pNodeParent;

    if ( pStartNode->Element()->HasMasterPtr() )
    {
        pNodeParent = pStartNode->Element()->GetMasterIfSlave()->GetFirstBranch();
    }
    else
        pNodeParent = pStartNode->Parent();
                
    while (  pFF->_iCustomCursor == -1 && pNodeParent )
    {            
        pFF = pNodeParent->GetFancyFormat();

        if ( pNodeParent->Element()->HasMasterPtr() )
        {
            pNodeParent = pNodeParent->Element()->GetMasterIfSlave()->GetFirstBranch();
        }
        else
            pNodeParent = pNodeParent->Parent();
    }
    
    if ( pFF->_iCustomCursor != -1 )
    {
        return GetCustomCursorFromCacheEx( pFF->_iCustomCursor );             
    }          

    return NULL;
}

//+------------------------------------------------------------------------
//
//  Member  :   SetCursorStyle
//
//  Synopsis : if the element.style.cursor property is set then on the handling
//      of the WM_CURSOR we should set the cursor to the one specified in
//      the style.
//
//-----------------------------------------------------------------------------

HRESULT
CElement::SetCursorStyle(LPCTSTR idcArg, CTreeNode* pContext /* = NULL */)
{
    HRESULT hr = E_FAIL;
    LPCTSTR idc = NULL;
    HCURSOR hCurNew = NULL;
    
    
    const CCharFormat * pCF;

    if (!IsInMarkup())
        goto Cleanup;

    if (CHECK_EDIT_BIT( GetMarkup(), _fOverrideCursor ))
    {
        return S_OK; // we don't touch the cursor - up to the host.        
    }

    
    pContext = pContext ? pContext : GetFirstBranch();
    if (!pContext)
        goto Cleanup;

    pCF = pContext->GetCharFormat();
    Assert(pCF);


    if (GetMarkup()->_fShowWaitCursor)
    {
        // Waiting for page to navigate.  Show wait cursor.
        idc = IDC_APPSTARTING;
    }
    else if (  !IsParentEditable() 
             && pCF->_bCursorIdx 
             && pCF->_bCursorIdx  != styleCursorNotSet)
    {
        // The style is set to something other than auto
        // so use g_aStyleToCursor to map the enum to a cursor id.

        if ( pCF->_bCursorIdx != styleCursorcustom )
        {
            idc = GetCursorForStyle( pCF->_bCursorIdx );
        }
        else
        {
            CCustomCursor* pCust = GetCustomCursorForNode( pContext );
            if ( pCust )
            {
                hCurNew = pCust->GetCursor();
            }
#if DBG == 1
            else
            {
                AssertSz(0,"Didn't find Custom Cursor");
            }
#endif      
        }
    }
    else if (pCF->HasVerticalLayoutFlow() && idcArg == IDC_IBEAM)
    {
        idc = MAKEINTRESOURCE(IDC_HIBEAM);
    }
    else if (idcArg)
    {
        idc = idcArg;
    }
    else
    {
        // We didn't handle it.
        idc = NULL;

        //
        // check for style of 'auto' + style set on parent. 
        //
        if ( ! IsParentEditable() &&
             pCF->_bCursorIdx == styleCursorAuto )
        {
            CTreeNode* pNode = pContext->Parent();
            pCF = pNode ? pNode->GetCharFormat() : NULL ;
            
            if ( pNode && pCF &&
                 pCF->_bCursorIdx != styleCursorAuto &&
                 pCF->_bCursorIdx != styleCursorNotSet )
            {
                idc = idcArg ? idcArg : 
                               ( pCF->HasVerticalLayoutFlow() ? MAKEINTRESOURCE(IDC_HIBEAM) : IDC_IBEAM);
            }                 
        }
    }

    if (idc || hCurNew )
    {
        SetCursorIDC(idc, hCurNew );
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

Cleanup:
    RRETURN1(hr, S_FALSE );
}


//+------------------------------------------------------------------------
//
//  Function:   IsIDMSuperscript
//
//  Synopsis:   Tests the element passed is a superscript
//
//  Arguments:  CTreeNode *  element to be tested.
//
//  Returns:    BOOL    TRUE if the element passed is a superscript element
//
//-----------------------------------------------------------------------------
BOOL
IsIDMSuperscript(CTreeNode * pNode)
{
    ELEMENT_TAG etag = pNode->Tag();

    return etag == ETAG_SUP;
}

//+------------------------------------------------------------------------
//
//  Function:   IsIDMSubscript
//
//  Synopsis:   Tests the element passed is a subscript
//
//  Arguments:  CTreeNode *   element to be tested.
//
//  Returns:    BOOL    TRUE if the element passed is a subscript element
//
//-----------------------------------------------------------------------------
BOOL
IsIDMSubscript(CTreeNode * pNode)
{
    ELEMENT_TAG etag = pNode->Tag();

    return etag == ETAG_SUB;
}


//+------------------------------------------------------------------------
//
//  Function:   IsIDMBold
//
//  Synopsis:   Tests the element passed is a Bold or Strong element
//
//  Arguments:  CTreeNode *   element to be tested.
//
//  Returns:    BOOL    TRUE if the element passed is a bold/strong element
//
//-----------------------------------------------------------------------------
BOOL
IsIDMBold(CTreeNode * pNode)
{
    ELEMENT_TAG etag = pNode->Tag();

    return (etag == ETAG_B || etag == ETAG_STRONG);
}


//+------------------------------------------------------------------------
//
//  Function:   IsIDMCharAttr
//
//  Synopsis:   Tests the element passed is a character attribute.  This
//              function is used to determine whether an element is a
//              candidate for deletion when the user selects "remove
//              character formatting" (aka "set to normal.")
//
//  Arguments:  CTreeNode *   element to be tested.
//
//  Returns:    BOOL    TRUE if the element passed is a not "normal"
//
//-----------------------------------------------------------------------------

BOOL
IsIDMCharAttr(CTreeNode * pNode)
{
    return pNode->Element()->HasFlag(TAGDESC_EDITREMOVABLE);
}

//+----------------------------------------------------------------------------
//
//  Function:   IsIDMItalic
//
//  Synopsis:   Tests the element passed is a Italic or Cite element
//
//  Arguments:  CTreeNode *   element to be tested.
//
//  Returns:    BOOL    TRUE if the element passed is a Italic/Cite element
//
//-----------------------------------------------------------------------------

BOOL
IsIDMItalic(CTreeNode * pNode)
{
    ELEMENT_TAG etag = pNode->Tag();

    return (etag == ETAG_I || etag == ETAG_EM || etag == ETAG_CITE);
}

//+----------------------------------------------------------------------------
//
//  Function:   IsIDMUnderlined
//
//  Synopsis:   Tests the element passed is a Underline element
//
//  Arguments:  CTreeNode *   element to be tested.
//
//  Returns:    BOOL    TRUE if the element passed is a Underline element
//
//-----------------------------------------------------------------------------

BOOL
IsIDMUnderlined(CTreeNode * pNode)
{
    return (pNode->Tag() == ETAG_U);
}


//+----------------------------------------------------------------------------
//
//  Function:   WriteTag
//
//  Synopsis:   writes an open/end tag to the stream buffer
//
//  Arguments:  pStreamWrBuff   -   stream buffer
//              fEnd            -   TRUE if End tag is to be written out
//              fForce          -   Force writing of tag
//              fAtomic         -   Save as atomic tag (ie, <tagname />)
//
//  Returns:    S_OK    if  successful
//
//-----------------------------------------------------------------------------

HRESULT
CElement::WriteTag(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd, BOOL fForce, BOOL fAtomic)
{
    HRESULT         hr = S_OK;
    DWORD           dwOldFlags = pStreamWrBuff->ClearFlags(WBF_ENTITYREF);
    const TCHAR *   pszTagName = TagName();
    const TCHAR *   pszScopeName;
    ELEMENT_TAG     etag = Tag();

    //
    // Do not write tags out in plaintext mode or when we are
    // explicitly asked not to.
    //
    if (pStreamWrBuff->TestFlag(WBF_SAVE_PLAINTEXT)
        || !pszTagName[0]
        || (this == pStreamWrBuff->GetElementContext()
            && pStreamWrBuff->TestFlag(WBF_NO_TAG_FOR_CONTEXT)
           )
        || (fEnd
            && (TagHasNoEndTag(Tag())
                || (!_fExplicitEndTag
                    && !HasFlag(TAGDESC_SAVEALWAYSEND)
                    && !fForce
                   )
                || fAtomic
               )
           )
       )
    {
        goto Cleanup;
    }

    if(fEnd)
    {
        hr = pStreamWrBuff->Write(_T("</"), 2);
    }
    else
    {
        CExtendedTagDesc *  pExtendedTagDesc = GetExtendedTagDesc();
        if ( pExtendedTagDesc && !pStreamWrBuff->TestFlag( WBF_FOR_TREESYNC ) )
        {
            hr = THR(pStreamWrBuff->EnsurePIsSaved(this, pExtendedTagDesc, HasIdentityPeerHolder() ? XMLNAMESPACEDECL_IMPORT : XMLNAMESPACEDECL_TAG));
            if (hr)
                goto Cleanup;
        }

        if (pStreamWrBuff->TestFlag(WBF_FOR_RTF_CONV) &&
            Tag() == ETAG_DIV)
        {
            // For the RTF converter, transform DIV tags into P tags.
            pszTagName = SZTAG_P;
        }

        // NOTE: In IE4, we would save a NewLine before every
        // element that was a ped.  This is roughly equivalent
        // to saving it before every element that is a container now
        // However, this does not round trip properly so I'm taking
        // that check out.

        if (    ! pStreamWrBuff->TestFlag(WBF_NO_PRETTY_CRLF)
            &&  (   HasFlag(TAGDESC_SAVETAGOWNLINE)
                ||  IsBlockTag() ) )
        {
            hr = pStreamWrBuff->NewLine();
            if (hr)
                goto Cleanup;
        }
        hr = pStreamWrBuff->Write(_T("<"), 1);
    }

    if(hr)
        goto Cleanup;


    pszScopeName = pStreamWrBuff->TestFlag(WBF_SAVE_FOR_PRINTDOC) && 
               pStreamWrBuff->TestFlag(WBF_SAVE_FOR_XML) &&
               Tag() != ETAG_GENERIC
                    ? NamespaceHtml() : Namespace();

    if (pszScopeName)
    {
        hr = pStreamWrBuff->Write(pszScopeName);
        if(hr)
            goto Cleanup;

        hr = pStreamWrBuff->Write(_T(":"));
        if(hr)
            goto Cleanup;
    }

    hr = pStreamWrBuff->Write(pszTagName);
    if(hr)
        goto Cleanup;

    if(!fEnd)
    {
        BOOL fAny;

        hr = SaveAttributes(pStreamWrBuff, &fAny);
        if(hr)
            goto Cleanup;

        if (ETAG_HTML == etag)
        {
            Assert (IsInMarkup());

            hr = THR(GetMarkup()->SaveXmlNamespaceAttrs(pStreamWrBuff));
            if (hr)
                goto Cleanup;
        }

        // If saving as an atomic tag, add a trailing slash
        if( fAtomic )
        {
            hr = THR( pStreamWrBuff->Write(_T(" /"), 2 ) );
            if( hr )
                goto Cleanup;
        }
    }

    hr = pStreamWrBuff->Write(_T(">"), 1);
    if (hr)
        goto Cleanup;

#if 0
    if(fEnd && HasFlag(TAGDESC_SAVENEWLINEATEND))
    {
            hr = pStreamWrBuff->NewLine();
            if (hr)
                    goto Cleanup;
    }
#endif

Cleanup:
    pStreamWrBuff->RestoreFlags(dwOldFlags);

    RRETURN(hr);
}


HRESULT STDMETHODCALLTYPE
CElement::scrollIntoView(VARIANTARG varargStart)
{
    HRESULT                hr;
    SCROLLPIN              spVert;
    BOOL                   fStart;
    CVariant               varBOOLStart;

    hr = THR(varBOOLStart.CoerceVariantArg(&varargStart, VT_BOOL));
    if ( hr == S_OK )
    {
        fStart = V_BOOL(&varBOOLStart);
    }
    else if ( hr == S_FALSE )
    {
        // when no argument
        fStart = TRUE;
    }
    else
        goto Cleanup;

    spVert = fStart ? SP_TOPLEFT : SP_BOTTOMRIGHT;

    hr = THR(ScrollIntoView(spVert, SP_TOPLEFT));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::DeferScrollIntoView(SCROLLPIN spVert, SCROLLPIN spHorz )
{
    HRESULT hr;

    GWKillMethodCall (this, ONCALL_METHOD(CElement, DeferredScrollIntoView, deferredscrollintoview), 0);
    hr = THR(GWPostMethodCall (this, ONCALL_METHOD(CElement, DeferredScrollIntoView, deferredscrollintoview),
                                (DWORD_PTR)(spVert | (spHorz << 16)), FALSE, "CElement::DeferredScrollIntoView"));
    return hr;
}

void
CElement::DeferredScrollIntoView(DWORD_PTR dwParam)
{
    SCROLLPIN spVert = (SCROLLPIN)((DWORD)dwParam & 0xffff);
    SCROLLPIN spHorz = (SCROLLPIN)((DWORD)dwParam >> 16);

    IGNORE_HR(ScrollIntoView(spVert, spHorz));
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::GetAtomTable, virtual override from CBase
//
//-------------------------------------------------------------------------

CAtomTable *
CElement::GetAtomTable (BOOL *pfExpando)
{
    CAtomTable  *pat = NULL;
    CDoc        *pDoc;

    pDoc = Doc();
    if (pDoc)
    {
        pat = &(pDoc->_AtomTable);
        if (pfExpando)
        {
            CMarkup *pMarkupContext = IsInMarkup() ? GetMarkupPtr()->GetWindowedMarkupContext()
                                                   : (HasWindowedMarkupContextPtr() ?  GetWindowedMarkupContextPtr() : NULL);
            *pfExpando = pMarkupContext ? pMarkupContext->_fExpando : TRUE;
        }
    }

    // We should have an atom table otherwise there's a problem.
    Assert(pat && "Element is not associated with a CDoc.");

    return pat;
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::GetPlainTextInScope
//
//  Synopsis:   Returns a text string containing all the plain text in the
//              scope of this element. The caller must free the memory.
//              This function can be used to merely retrieve the text
//              length by setting ppchText to NULL.
//
//  Arguments:  pstrText    If NULL,
//                              no text is returned.
//                          If not NULL but there is no text,
//                              *pstrText is set to NULL.
//                          Otherwise
//                              *pstrText points to a new CStr
//
//-------------------------------------------------------------------------

HRESULT
CElement::GetPlainTextInScope(CStr * pstrText)
{
    HRESULT     hr = S_OK;
    long        cp, cch;

    Assert(pstrText);

    if(!IsInMarkup())
    {
        pstrText->Set(NULL);
        goto Cleanup;
    }

    cp = GetFirstCp();
    cch = GetElementCch();

    {
        CTxtPtr     tp( GetMarkup(), cp );

        cch = tp.GetPlainTextLength(cch);

        // copy text into buffer

        pstrText->SetLengthNoAlloc(0);
        hr = pstrText->ReAlloc(cch);
        if (hr)
        {
            pstrText->Set(NULL);
            goto Cleanup;
        }

        cch = tp.GetPlainText(cch, (LPTSTR)*pstrText);

        Assert(cch >= 0);

        if (cch)
        {
            // Terminate with 0. GetPlainText() does not seem to do this.
            pstrText->SetLengthNoAlloc(cch);
            *(LPTSTR(*pstrText) + cch) = 0;
        }
        else
        {
            // just making sure...
            pstrText->Free();
        }
    }

Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
// Member: GetAccessKey & MatchAccessKey
//
//-----------------------------------------------------------------------------

// In lieu of the C Run-time function _totlower() that we are not linking with
#define TOTLOWER(ch)  (TCHAR((DWORD)(DWORD_PTR)CharLower((LPTSTR)(DWORD_PTR)ch)))
// TODO - yinxie, need to make sure this will work for non IBM compatible keyboards
// Caps Lock scan code = 0x3a, all keys higher than this will not be allowed in access key
#ifndef UNIX
#define ISVALIDKEY(x)   (((x >> 16) & 0x00FF) < 0x3a)
#else
inline BOOL ISVALIDKEY(LPARAM x) { return (MwCharacterFromWM_KEY(x) != 0); }
#endif

#define VIRTKEY_TO_SCAN 0

VOID
ConvertMessageToUnicode(CMessage* pmsg, WCHAR* pwchKey )
{
    Assert( pwchKey );
    *pwchKey = (TCHAR) pmsg->wParam;

    if(pmsg->message == WM_SYSKEYDOWN && pmsg->wParam > 31)
    {
        BYTE bKeyState[256];
        if(GetKeyboardState(bKeyState))
        {
            WORD cBuf[2];
            int cchBuf;
            HKL hkl = GetKeyboardLayout(0);

            UINT wScanCode = MapVirtualKeyEx(pmsg->wParam, VIRTKEY_TO_SCAN, hkl);
            cchBuf = ToAsciiEx(pmsg->wParam, wScanCode, bKeyState, cBuf, 1, hkl);

            if(cchBuf == 1)
            {
                WCHAR wBuf[2];
                UINT  uKbdCodePage = GetKeyboardCodePage();

                MultiByteToWideChar(uKbdCodePage, 0, (char *)cBuf, 2, wBuf, 2);
                *pwchKey = wBuf[0];
            }
        }
    }   
}

BOOL
CElement::MatchAccessKey(CMessage * pmsg, long lSubDivision, WCHAR* pwch )
{
    // TODO (MohanB) lSubDivision is ignored for now. Should make this work
    // to get accesskey working on AREAs.

    BOOL    fMatched = FALSE;
    LPCTSTR lpAccKey = GetAAaccessKey();
    WCHAR chKey;
    
    // Raid 57053
    // If we are in HTML dialog, accessKey can be matched with/without
    // SHIFT/CTRL/ALT keys.
    //
    if ( ! pwch )
    {
        pwch = & chKey;     
        ConvertMessageToUnicode( pmsg, pwch );
    }
    
    // 60711 - Translate the virtkey to unicode for foreign languages.
    // We only test for 0x20 (space key) or above. This way we avoid
    // coming in here for other system type keys

 
    if ((pmsg->message == WM_SYSKEYDOWN ||
                    (Doc()->_fInHTMLDlg && pmsg->message == WM_CHAR))
            && lpAccKey
            && lpAccKey[0]
            && TOTLOWER((TCHAR) *pwch) == TOTLOWER(lpAccKey[0])
            && ISVALIDKEY(pmsg->lParam))
    {
        fMatched = TRUE;
    }
    return fMatched;
}

//+-------------------------------------------------------------------------
//
// Member::    CElement::ShowMessage
//
//--------------------------------------------------------------------------

HRESULT __cdecl
CElement::ShowMessage(
        int * pnResult,
        DWORD dwFlags,
        DWORD dwHelpContext,
        UINT  idsMessage, ...)
{
    CDoc *              pDoc = Doc();
    HRESULT             hr = S_OK;
    va_list             arg;

    va_start(arg, idsMessage);

    if (pDoc)
    {
        hr = THR(pDoc->ShowMessageV(
            pnResult,
            dwFlags,
            dwHelpContext,
            idsMessage,
            &arg));
    }

    va_end(arg);
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
// Member::    CElement::ShowMessageV
//
//--------------------------------------------------------------------------

HRESULT
CElement::ShowMessageV(
                int   * pnResult,
                DWORD   dwFlags,
                DWORD   dwHelpContext,
                UINT    idsMessage,
                void  * pvArgs)
{
    RRETURN (Doc()->ShowMessageV(pnResult, dwFlags, dwHelpContext, idsMessage, pvArgs));
}

//+-------------------------------------------------------------------------
//
// Member::    CElement::ShowLastErrorInfo
//
//--------------------------------------------------------------------------

HRESULT
CElement::ShowLastErrorInfo(HRESULT hr, int iIDSDefault)
{
    RRETURN (Doc()->ShowLastErrorInfo(hr, iIDSDefault));
}

//+-------------------------------------------------------------------------
//
// Member::    CElement::ShowHelp
//
//--------------------------------------------------------------------------

HRESULT
CElement::ShowHelp(TCHAR * szHelpFile, DWORD dwData, UINT uCmd, POINT pt)
{
    RRETURN (Doc()->ShowHelp(szHelpFile, dwData, uCmd, pt));
}

CBase *CElement::GetOmWindow(CMarkup * pMarkup /* = NULL */)
{
    if (!pMarkup && IsInMarkup())
    {
        pMarkup = GetMarkup();
    }

    if (pMarkup)
    {
        Assert(!IsInMarkup() || pMarkup == GetMarkup());
      
        return pMarkup->Window();
    }

    return NULL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CElement::UndoManager
//
//  Synopsis:   Get the undo manager
//
//--------------------------------------------------------------------------

#ifndef NO_EDIT
IOleUndoManager *
CElement::UndoManager()
{
    return Doc()->UndoManager();
}
#endif // NO_EDIT

//+-------------------------------------------------------------------------
//
//  Method:     CElement::QueryCreateUndo
//
//  Synopsis:   Query whether to create undo or not.  Also dirties the doc.
//
//--------------------------------------------------------------------------

#ifndef NO_EDIT
BOOL
CElement::QueryCreateUndo(BOOL fRequiresParent, BOOL fDirtyChange /* = FALSE */, BOOL * pfTreeSync /* = NULL */)
{
    if( pfTreeSync )
    {
        CMarkup * pMarkup;
        *pfTreeSync = FALSE;

        if( IsInMarkup() )
        {
            pMarkup = GetMarkup();
            
            *pfTreeSync = pMarkup->HasLogManager() && pMarkup->GetLogManager()->IsAnyoneListening();
        }
    }

    if( fDirtyChange && IsInMarkup() )
    {
        GetMarkup()->SetDirtyFlag();
    }

    return Doc()->QueryCreateUndo( fRequiresParent, fDirtyChange, NULL );
}

HRESULT
CElement::LogAttributeChange( CStyle * pStyle, DISPID dispidProp, VARIANT * pvarOld, VARIANT * pvarNew )
{
    CMarkup * pMarkup;
    ATTR_CHANGE_FLAGS lFlags = ATTR_CHANGE_NONE;
    CBase * pBase = this;

    AssertSz( IsInMarkup(), "Shouldn't be trying to log attr change w/out a markup" );
    pMarkup = GetMarkup();

    Assert( pMarkup->HasLogManager() && pMarkup->GetLogManager()->IsAnyoneListening() );

    if( pStyle )
    {
        lFlags = ( GetRuntimeStylePtr() == pStyle ) ? ATTR_CHANGE_RUNTIMESTYLE : ATTR_CHANGE_INLINESTYLE;
        pBase = pStyle;
    }

    IGNORE_HR( pMarkup->GetLogManager()->AttrChangeProp( this, pBase, lFlags, dispidProp, pvarOld, pvarNew ) );

    return S_OK;
}

#endif // NO_EDIT


//+-------------------------------------------------------------------------
//
//  Method:     CElement::ShowTooltip
//
//  Synopsis:   Displays the tooltip for the site.
//
//  Arguments:  [pt]    Mouse position in container window coordinates
//              msg     Message passed to tooltip for Processing
//
//--------------------------------------------------------------------------

HRESULT
CElement::ShowTooltipInternal(CMessage *pmsg, POINT pt, CDoc * pDoc)
{
    HRESULT hr = S_FALSE;
    RECT    rc;
    TCHAR * pchString;
    BOOL fRTL = FALSE;

    if (pDoc->State() < OS_INPLACE)
        goto Cleanup;

#if DBG == 1
    TCHAR  achBuf[100];

    if (IsTagEnabled(tagFormatTooltips))
    {
        CTreeNode *pNode = pmsg->pNodeHit;

        Format(0,
               achBuf,
               100,
               L"<0s>  SN=<1d>\n_iCF=<2d>  _iPF=<3d>  _iFF=<4d>",
               pNode->Element()->TagName(),
               pNode->SN(),
               pNode->_iCF,
               pNode->_iPF,
               pNode->_iFF);

        pchString = achBuf;
    }
    else
#endif
    //
    // if there is a title property, use it as tooltip
    //

    pchString = (LPTSTR) GetAAtitle();
    if (pchString != NULL)
    {
        GetElementRc(&rc, GERC_CLIPPED | GERC_ONALINE, &pt);

        //It is possible to have an empty rect when an
        //element doesn't have a TxtSite above it.
        //Should this be an ASSERT or TODO?
        if(IsRectEmpty(&rc))
        {
            rc.left = pt.x - 10;
            rc.right = pt.x + 10;
            rc.top = pt.y - 10;
            rc.bottom = pt.y + 10;
        }

        // Ignore spurious WM_ERASEBACKGROUNDs generated by tooltips
        CServer::CLock Lock(pDoc, SERVERLOCK_IGNOREERASEBKGND);

        // COMPLEXSCRIPT - determine if element is right to left for tooltip style setting
        if(GetFirstBranch())
        {
            fRTL = GetFirstBranch()->GetCharFormat()->_fRTL;
        }
        
        if (!pDoc->_pDocPopup)
        {
            FormsShowTooltip(pchString, pDoc->_pInPlace->_hwnd, *pmsg, &rc, (DWORD_PTR) GetMarkup(), (DWORD_PTR) this, fRTL);
        }

        hr = S_OK;
    }

Cleanup:
    return hr;
}

#ifndef WIN16
BEGIN_TEAROFF_TABLE(CElementFactory, IDispatchEx)
    //  IDispatch methods
    TEAROFF_METHOD(super, GetTypeInfoCount, gettypeinfocount, (UINT *pcTinfo))
    TEAROFF_METHOD(super, GetTypeInfo, gettypeinfo, (UINT itinfo, ULONG lcid, ITypeInfo ** ppTI))
    TEAROFF_METHOD(super, GetIDsOfNames, getidsofnames, (REFIID riid,
                                          LPOLESTR *prgpsz,
                                          UINT cpsz,
                                          LCID lcid,
                                          DISPID *prgid))
    TEAROFF_METHOD(super, Invoke, invoke, (DISPID dispidMember,
                                   REFIID riid,
                                   LCID lcid,
                                   WORD wFlags,
                                   DISPPARAMS * pdispparams,
                                   VARIANT * pvarResult,
                                   EXCEPINFO * pexcepinfo,
                                   UINT * puArgErr))
    TEAROFF_METHOD(super, GetDispID, getdispid, (BSTR bstrName,
                                      DWORD grfdex,
                                      DISPID *pid))
    TEAROFF_METHOD(CElementFactory, InvokeEx, invokeex, (DISPID id,
                             LCID lcid,
                             WORD wFlags,
                             DISPPARAMS *pdp,
                             VARIANT *pvarRes,
                             EXCEPINFO *pei,
                             IServiceProvider *pSrvProvider))
    TEAROFF_METHOD(super, DeleteMemberByName, deletememberbyname, (BSTR bstr,DWORD grfdex))
    TEAROFF_METHOD(super, DeleteMemberByDispID, deletememberbydispid, (DISPID id))
    TEAROFF_METHOD(super, GetMemberProperties, getmemberproperties, (DISPID id,
                                                DWORD grfdexFetch,
                                                DWORD *pgrfdex))
    TEAROFF_METHOD(super, GetMemberName, getmembername, (DISPID id,
                                          BSTR *pbstrName))
    TEAROFF_METHOD(super, GetNextDispID, getnextdispid, (DWORD grfdex,
                                          DISPID id,
                                          DISPID *pid))
    TEAROFF_METHOD(super, GetNameSpaceParent, getnamespaceparent, (IUnknown **ppunk))
END_TEAROFF_TABLE()
#endif

HRESULT
CElementFactory::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT hr=S_OK;

    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
#ifndef WIN16
        QI_TEAROFF_DISPEX(this, NULL)
#else
    case Data1_IDispatchEx:
        CBase::PrivateQueryInterface(iid, ppv);
        break;
#endif
    QI_TEAROFF(this, IObjectIdentity, NULL)

    default:
        {
            const CLASSDESC *pclassdesc = (const CLASSDESC *) BaseDesc();
            if (pclassdesc &&
                pclassdesc->_apfnTearOff &&
                pclassdesc->_classdescBase._piidDispinterface &&
                (iid == *pclassdesc->_classdescBase._piidDispinterface ))
            {
                hr = THR(CreateTearOffThunk(this, (void *)(pclassdesc->_apfnTearOff), NULL, ppv));
            }
        }
    }

    if (!hr)
    {
        if (*ppv)
            (*(IUnknown **)ppv)->AddRef();
        else
            hr = E_NOINTERFACE;
    }
    RRETURN(hr);
}

HRESULT
CElementFactory::InvokeEx(DISPID dispidMember,
                          LCID lcid,
                          WORD wFlags,
                          DISPPARAMS * pdispparams,
                          VARIANT * pvarResult,
                          EXCEPINFO * pexcepinfo,
                          IServiceProvider *pSrvProvider)
{
    if ( (wFlags & DISPATCH_CONSTRUCT) && (dispidMember == DISPID_VALUE) )
    {
        // turn it into a method call ( expect dispid=0 )
        wFlags &= ~DISPATCH_CONSTRUCT;
        wFlags |= DISPATCH_METHOD;
    }

    RRETURN(super::InvokeEx(dispidMember,
                            lcid,
                            wFlags,
                            pdispparams,
                            pvarResult,
                            pexcepinfo,
                            pSrvProvider));
}


//+----------------------------------------------------------------------------
//
//  Method: LogAttrArray
//
//  Synopsis: Logs the attribute array differences to the Log Manager
//      One AttrArray can be null signifying a CLEAR of an attr array.
//
//      [CStyle *]      pStyle          -   Style object for attr arrays, or NULL
//      [CAttrArray *]  pAttrArrayOld   -   Attr Array of old values
//      [CAttrArray *]  pAttrArrayNew   -   Attr Array of new values
//
//+----------------------------------------------------------------------------
HRESULT CElement::LogAttrArray( CStyle * pStyle, CAttrArray * pAttrArrayOld, CAttrArray *pAttrArrayNew )
{
    CAttrValue * pAVOld;
    CAttrValue * pAVNew;
    CAttrValue * pAV;
    long         cAV;
    CBase      * pBase = pStyle ? (CBase *)pStyle : (CBase *)this;

    AssertSz( pAttrArrayOld || pAttrArrayNew, "Only one attr array can be null here" );

    if( pAttrArrayOld && pAttrArrayNew && pAttrArrayOld->Size() != pAttrArrayNew->Size() )
    {
        AssertSz( FALSE, "Unbalanced Attr Arrays" );
        return E_FAIL;
    }

    pAVOld = pAttrArrayOld ? (CAttrValue *)*pAttrArrayOld : NULL;
    pAVNew = pAttrArrayNew ? (CAttrValue *)*pAttrArrayNew : NULL;
    pAV    = pAVOld ? pAVOld : pAVNew;
    cAV = pAttrArrayOld ? pAttrArrayOld->Size() : pAttrArrayNew->Size();

    for( ; cAV; cAV-- )
    {
        VARIANT                 vtOld;
        VARIANT                 vtNew;
        DISPID                  dispid;
        const PROPERTYDESC  *   pPropDesc;

        // TODO (JHarding): Skipping the nested inline style attr array for now
        if( pAV->GetAAType() == CAttrValue::AA_AttrArray )
            goto NextAttr;

        if( pAV->GetPropDesc() )
        {
            pPropDesc = pAV->GetPropDesc();
            dispid = pPropDesc->GetDispid();
        }
        else
        {
            dispid = pAV->GetDISPID();
            pBase->FindPropDescFromDispID( dispid, const_cast<PROPERTYDESC **>(&pPropDesc), NULL, NULL );
        }

        AssertSz( pPropDesc, "Couldn't find propdesc!" );
        if( pPropDesc )
        {
            VariantInit( &vtOld );
            VariantInit( &vtNew );

            if( pAVOld )
                pAVOld->GetIntoDispatchableVariant( &vtOld, pPropDesc );
            if( pAVNew )
                pAVNew->GetIntoDispatchableVariant( &vtNew, pPropDesc );

            IGNORE_HR( LogAttributeChange( pStyle, dispid, &vtOld, &vtNew ) );

            VariantClear(&vtOld);
            VariantClear(&vtNew);
        }

NextAttr:
        if( pAVOld )
            pAVOld++;
        if( pAVNew )
            pAVNew++;
        pAV++;
    }

    return S_OK;
}
//+----------------------------------------------------------------------------
//
// Member:      CopyCommonAttributes
//
// Synopsis:    Copy the common attributes for a given element to the current
//              element (generally used when replacing an element with another
//              while editing).
//
//-----------------------------------------------------------------------------

HRESULT
CElement::MergeAttributes(CElement *pElementFrom, BOOL fCopyID)
{
    HRESULT         hr = S_OK;
    CAttrArray *    pInLineStyleAAFrom;
    CAttrArray **   ppInLineStyleAATo;
    CAttrArray *    pAAFrom = *(pElementFrom->GetAttrArray());
    CBase *         pelTarget = this;
    CAttrArray *    pAttrUndo = NULL;
    CAttrArray *    pAttrSync = NULL;
    CAttrArray *    pAttrStyleUndo = NULL;
    CAttrArray *    pAttrStyleSync = NULL;
    CMergeAttributesUndo Undo( this );
    BOOL            fCreateUndo;
    BOOL            fTreeSync;

    if (pElementFrom->Tag() == Tag())
        pelTarget = NULL;

    Undo.SetWasNamed( _fIsNamed );
    Undo.SetCopyId( fCopyID );
    Undo.SetPassElTarget( !!pelTarget );

    fCreateUndo = QueryCreateUndo( TRUE, FALSE, &fTreeSync );
    if( pAAFrom && ( fCreateUndo || fTreeSync ) )
    {
        pAttrUndo       = new CAttrArray();
        pAttrStyleUndo  = new CAttrArray();
        if( !pAttrUndo || !pAttrStyleUndo )
        {
            // If we couldn't make these two arrays, we're hosed.
            fTreeSync = FALSE;
            fCreateUndo = FALSE;

            delete pAttrUndo;
            delete pAttrStyleUndo;
        }

        if( fTreeSync )
        {
            pAttrSync      = new CAttrArray();
            pAttrStyleSync = new CAttrArray();

            if( !pAttrSync || !pAttrStyleSync )
            {
                // If we couldn't make these two arrays, tree sync is hosed
                fTreeSync = FALSE;

                delete pAttrSync;
                delete pAttrStyleSync;
            }
        }
    }

    if (pAAFrom)
    {
        CAttrArray     **ppAATo = GetAttrArray();

        hr = THR(pAAFrom->Merge(ppAATo, pelTarget, pAttrUndo, pAttrSync, FALSE, fCopyID));
        if (hr)
            goto Cleanup;

        SetEventsShouldFire();

        // If the From has is a named element then the element is probably changed.
        if (pElementFrom->_fIsNamed && fCopyID)
        {
            _fIsNamed = TRUE;
            // Inval all collections affected by a name change
            DoElementNameChangeCollections();
        }

        pInLineStyleAAFrom = pElementFrom->GetInLineStyleAttrArray();
        if (pInLineStyleAAFrom && pInLineStyleAAFrom->Size())
        {
            ppInLineStyleAATo = CreateStyleAttrArray(DISPID_INTERNAL_INLINESTYLEAA);
            if (!ppInLineStyleAATo)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            hr = THR(pInLineStyleAAFrom->Merge(ppInLineStyleAATo, NULL, pAttrStyleUndo, pAttrStyleSync));
            if (hr)
                goto Cleanup;
        }

        if( fTreeSync )
        {
            CStyle     * pStyle = NULL;

            if( pAttrStyleSync->Size() )
                IGNORE_HR( GetStyleObject( &pStyle ) );

            IGNORE_HR( LogAttrArray( NULL, pAttrUndo, pAttrSync ) );
            IGNORE_HR( LogAttrArray( pStyle, pAttrStyleUndo, pAttrStyleSync ) );
                
            delete pAttrSync;
            delete pAttrStyleSync;
        }

        if( fCreateUndo )
        {
            Undo.SetAA( pAttrUndo );
            Undo.SetAAStyle( pAttrStyleUndo );
        }
        else
        {
            delete pAttrUndo;
            delete pAttrStyleUndo;
        }
    }

    IGNORE_HR(Undo.CreateAndSubmit());

Cleanup:

    RRETURN(hr);
}

HRESULT
CElement::GetNameSpaceParent(IUnknown **ppunk)
{
    HRESULT     hr;
    CTreeNode * pNodeForm;
    CTreeNode * pNodeContext = GetFirstBranch();
    CMarkup *   pMarkup;

    if (!ppunk)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppunk = NULL;

    if (pNodeContext && pNodeContext->Parent())
    {
        pNodeForm = pNodeContext->Parent()->SearchBranchToRootForTag( ETAG_FORM );

        if (pNodeForm)
        {
            hr = THR( pNodeForm->GetElementInterface( IID_IDispatchEx, (void **) ppunk ) );

            goto Cleanup;
        }
    }

    pMarkup = GetMarkup();
    if (!pMarkup)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = THR(pMarkup->GetDefaultDocument()->PrivateQueryInterface(IID_IDispatchEx, (void**) ppunk));

Cleanup:

    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     CElement::CanShow
//
//  Synopsis:   Determines whether an element can be shown at this moment.
//
//--------------------------------------------------------------------------
BOOL
CElement::CanShow()
{
    BOOL fRet = TRUE;
    CTreeNode *pNodeSite = GetFirstBranch()->GetUpdatedNearestLayoutNode();

    while (pNodeSite)
    {
        if (!pNodeSite->Element()->GetInfo(GETINFO_ISCOMPLETED))
        {
            fRet = FALSE;
            break;
        }
        pNodeSite = pNodeSite->GetUpdatedParentLayoutNode();
    }
    return fRet;
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::OnCssChangeStable
//
//-------------------------------------------------------------------------

HRESULT
CElement::OnCssChange(BOOL fStable, BOOL fRecomputePeers)
{
    HRESULT     hr = S_OK;

    if (IsInMarkup())
    {
        hr = THR(GetMarkup()->OnCssChange(fStable, fRecomputePeers));
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::Invalidate
//
//  Synopsis:   Invalidates the area occupied by the element.
//
//-------------------------------------------------------------------------
void
CElement::Invalidate()
{
    if(!IsInMarkup())
        return;

    SendNotification(NTYPE_ELEMENT_INVALIDATE);
}

//+-------------------------------------------------------------------------
//
//  Method:     GetElementRc
//
//  Synopsis:   Get the bounding rect for the element
//
//  Arguments:  prc:      the rc to be returned
//              dwFlags:  flags indicating desired behaviour
//                           GERC_ONALINE: rc on a line, line indicated by ppt.
//                           GERC_CLIPPED: rc clipped by visible client rect.
//              ppt:      the point around which we want the rect
//
//  Returns:    hr
//
//--------------------------------------------------------------------------

HRESULT
CElement::GetElementRc(RECT *prc, DWORD dwFlags, POINT *ppt)
{
    CDataAry<RECT> aryRects(Mt(CElementGetElementRc_aryRects_pv));
    HRESULT        hr = S_FALSE;
    LONG           i;

    Assert(prc);

    // make sure that current will be calced
    hr = THR(EnsureRecalcNotify());
    if (hr)
        goto Cleanup;

    // Get the region for the element
    GetElementRegion(&aryRects,
                    !(dwFlags & GERC_ONALINE)
                        ? prc
                        : NULL,
                    RFE_SCREENCOORD);

    if (dwFlags & GERC_ONALINE)
    {
        Assert(ppt);
        for (i = 0; i < aryRects.Size(); i++)
        {
            if (PtInRect(&aryRects[i], *ppt))
            {
                *prc = aryRects[i];
                hr = S_OK;
                break;
            }
        }
    }

    if (   (S_OK == hr)
        && (dwFlags & GERC_CLIPPED)
       )
    {
        CRect      rcVisible;
        CDispNode *pDispNode;
        CLayout   *pLayout = GetUpdatedNearestLayout();

        if(!pLayout)
        {
            CElement *pElementClient = CMarkup::GetElementClientHelper(GetMarkup());
            if(pElementClient)
                pLayout = pElementClient->GetUpdatedNearestLayout();
            else
            {
                prc->left = prc->top = prc->right = prc->bottom = 0;
                hr = E_FAIL;
                goto Cleanup;
            }
        }

        Assert(pLayout);
        pDispNode = pLayout->GetElementDispNode(this);

        if (!pDispNode)
        {
            pDispNode = pLayout->GetElementDispNode(pLayout->ElementOwner());
        }


        if (pDispNode)
        {
            pDispNode->GetClippedBounds(&rcVisible, COORDSYS_GLOBAL);
            IntersectRect(prc, prc, &rcVisible);
        }
    }

Cleanup:
    return hr;
}

//+----------------------------------------------------------------------------
//
// Member:      CElement::ComputeHorzBorderAndPadding
//
// Synopsis:    Compute horizontal border and padding for a given element
//              The results represent cumulative border and padding up the
//              element's ancestor chain, up to but NOT INCLUDING element's
//              containing layout.  The layout's border should not be counted
//              when determining a contained element's indent, because it lies
//              outside the box boundary from which we are measuring.  The 
//              layout's padding usually does need to be accounted for; the caller
//              must do this! (via GetPadding on the layout's CDisplay).
//
//-----------------------------------------------------------------------------

void
CElement::ComputeHorzBorderAndPadding(CCalcInfo * pci, CTreeNode * pNodeContext, CElement * pElementStop,
                                  LONG * pxBorderLeft, LONG * pxPaddingLeft,
                                  LONG * pxBorderRight, LONG * pxPaddingRight)
{
    Assert(pNodeContext && SameScope(this, pNodeContext));

    Assert(pxBorderLeft || pxPaddingLeft || pxBorderRight || pxPaddingRight);

    CTreeNode * pNode = pNodeContext;
    CBorderInfo borderinfo;
    CElement *  pElement;
    const CFancyFormat * pFF;
    const CParaFormat *  pPF;
    const CCharFormat *  pCF;
    BOOL fNodeVertical;
    BOOL fWritingModeUsed;

    Assert(pxBorderLeft && pxPaddingLeft && pxBorderRight && pxPaddingRight);

    *pxBorderLeft = 0;
    *pxBorderRight = 0;
    *pxPaddingLeft = 0;;
    *pxPaddingRight = 0;

    while(pNode && pNode->Element() != pElementStop)
    {
        pElement = pNode->Element();
        pFF = pNode->GetFancyFormat();
        pPF = pNode->GetParaFormat();
        pCF = pNode->GetCharFormat();
        fNodeVertical = pCF->HasVerticalLayoutFlow();
        fWritingModeUsed = pCF->_fWritingModeUsed;

        // We only want to compute the border and padding for 
        // block elements. Inline border and padding should not
        // be accounted for here.
        if (pFF->_fBlockNess)
        {
            if ( !pElement->_fDefinitelyNoBorders )
            {
                pElement->_fDefinitelyNoBorders = !GetBorderInfoHelper( pNode, pci, &borderinfo, GBIH_NONE );

                *pxBorderRight  += borderinfo.aiWidths[SIDE_RIGHT];
                *pxBorderLeft   += borderinfo.aiWidths[SIDE_LEFT];
            }

            *pxPaddingLeft  += pFF->GetLogicalPadding(SIDE_LEFT, fNodeVertical, fWritingModeUsed).XGetPixelValue(pci,
                                        pci->_sizeParent.cx, pPF->_lFontHeightTwips);
            *pxPaddingRight += pFF->GetLogicalPadding(SIDE_RIGHT, fNodeVertical, fWritingModeUsed).XGetPixelValue(pci,
                                        pci->_sizeParent.cx, pPF->_lFontHeightTwips);
        }

        pNode = pNode->Parent();
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CElement::Clone
//
//  Synopsis:   Make a new one just like this one
//
//-------------------------------------------------------------------------

HRESULT
CElement::Clone ( CElement * * ppElementClone, CDoc * pDoc )
{
    HRESULT          hr;
    CAttrArray *     pAA;
    CStr             cstrPch;
    CElement       * pElementNew = NULL;
    const CTagDesc * ptd;
    CHtmTag          ht;
    BOOL             fDie = FALSE;
    ELEMENT_TAG      etag = Tag();
    
    Assert( ppElementClone );

    if (IsGenericTag( etag ))
    {
        hr = THR( cstrPch.Set( Namespace() ) );

        if (hr)
            goto Cleanup;

        hr = THR( cstrPch.Append( _T( ":" ) ) );

        if (hr)
            goto Cleanup;

        hr = THR( cstrPch.Append( TagName() ) );

        if (hr)
            goto Cleanup;
    }
    else if (etag == ETAG_UNKNOWN)
    {
        hr = THR( cstrPch.Append( TagName() ) );

        if (hr)
            goto Cleanup;
    }

    ptd = TagDescFromEtag( etag );

    if (!ptd)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    ht.Reset();
    ht.SetTag( etag );
    ht.SetPch( cstrPch );
    ht.SetCch( cstrPch.Length() );

    if (etag == ETAG_INPUT)
    {
        hr = THR(CInput::CreateElement(&ht, pDoc, &pElementNew, (htmlInput)(DYNCAST(CInput, this)->GetType())));
        if (hr)
            goto Cleanup;

        DYNCAST(CInput, pElementNew)->_fScriptCreated = TRUE;
    }
    else
        hr = ptd->_pfnElementCreator( & ht, pDoc, & pElementNew );

    if (hr)
        goto Cleanup;

    if (fDie)
        goto Die;

    hr = THR( pElementNew->Init() );

    if (hr)
        goto Cleanup;

    if (fDie)
        goto Die;

    pElementNew->_fBreakOnEmpty = _fBreakOnEmpty;
    pElementNew->_fExplicitEndTag = _fExplicitEndTag;

    pAA = * GetAttrArray();

    if (pAA)
    {
        CAttrArray * * ppAAClone = pElementNew->GetAttrArray();

        hr = THR( pAA->Clone( ppAAClone ) );

        if (hr)
            goto Cleanup;

        if (fDie)
            goto Die;
    }

    pElementNew->_fIsNamed = _fIsNamed;

    if( HasIdentityPeerHolder() )
    {
        ht.SetExtendedTag();
        ht.SetDynamic();
    }

    {
        CInit2Context   context(&ht, IsInMarkup() ? GetMarkupPtr() : GetWindowedMarkupContext(), INIT2FLAG_EXECUTE);

        hr = THR( pElementNew->Init2(&context) );
    }
    if (hr)
        goto Cleanup;

    if (etag == ETAG_INPUT)
    {
        CStr cstrValue;

        hr = THR(DYNCAST(CInput, this)->GetValueHelper(&cstrValue));
        if (hr)
            goto Cleanup;

        hr = THR(DYNCAST(CInput, pElementNew)->SetValueHelper(&cstrValue));
        if (hr)
            goto Cleanup;
    }

    if (fDie)
        goto Die;

    pElementNew->SetEventsShouldFire();

    if (ETAG_RAW_COMMENT == etag)
    {
        hr = THR(DYNCAST(CCommentElement, pElementNew)->_cstrText.Set(DYNCAST(CCommentElement, this)->_cstrText));
        if  (hr)
            goto Cleanup;
    }

Cleanup:
    if (hr && pElementNew)
        CElement::ClearPtr( & pElementNew );

    *ppElementClone = pElementNew;
    RRETURN(hr);

Die:
    hr = E_ABORT;
    goto Cleanup;
}


//+---------------------------------------------------------------------------
//
//  Member:     CElement::StealAttributes, public
//
//  Synopsis:   Steals the attributes from another element.
//
//  Arguments:  [pElementVictim] -- Element to steal attributes from.
//
//  Returns:    HRESULT
//
//  Notes:      Used when we want to replace one element with another, after
//              we've computed all the formats and created the attribute bag.
//
//----------------------------------------------------------------------------

HRESULT
CElement::StealAttributes(CElement * pElementVictim)
{
    _pAA = pElementVictim->_pAA;
    pElementVictim->_pAA = NULL;


    // TODO rgardner - Why do we do this ? Why not just steal the attr array & the format indices,
    // and set the indices in the victim to -1 ????


    // After we have stolen the attr array, we must adjust
    // any addrefs for images that the victim may be holding on to.

    if (pElementVictim->_fHasImage)
    {
        int n;
        long lCookie;

        // Add ref any image context cookies this element holds

        for (n = 0; n < ARRAY_SIZE(s_aryImgDispID); ++n)
        {
            if ( _pAA->FindSimple(s_aryImgDispID[n].cacheID, (DWORD *)&lCookie,
                                  CAttrValue::AA_Internal) )
            {
                CDoc *  pDoc = Doc();

                // Replace ref on victim with one on thief
                pDoc->AddRefUrlImgCtx(lCookie, this);
                pDoc->ReleaseUrlImgCtx(lCookie, pElementVictim);
            }
        }

        _fHasImage = TRUE;
        pElementVictim->_fHasImage = FALSE;
    }

    // some of the properties depend on the element being
    // a site so do not copy format indicies.

    return S_OK;
}



//+-----------------------------------------------------------------
//
//  members : get_filters
//
//  synopsis : IHTMLELement implementaion to return the filter collection
//
//-------------------------------------------------------------------
HRESULT
CElement::get_filters(IHTMLFiltersCollection **ppFilters)
{
    HRESULT    hr;
    BOOL       fAdded;

    CFilterBehaviorSite *  pFilterSite;

    // make sure ComputeFormats is called so that filter tasks are interted
    //  into the queue
    CTreeNode * pNode = GetFirstBranch();
    if (!pNode)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    // This will ensure that the filter string is available
    pNode->GetFancyFormatIndex();

    // Make sure that all the pending filters re created
    Doc()->ExecuteFilterTasks(&fAdded);

    hr = THR(EnsureFilterBehavior(FALSE, &pFilterSite));
    if(FAILED(hr))
        goto Cleanup;

    Assert(pFilterSite);

    hr = THR(pFilterSite->GetIHTMLFiltersCollection(ppFilters));

    if(fAdded)
    {
        // make sure GetSize is being called on filters
        hr = THR(EnsureRecalcNotify());
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CElement::toString(BSTR* String)
{
    RRETURN(super::toString(String));
};

HRESULT
CElement::setCapture(VARIANT_BOOL containerCapture)
{
    HRESULT hr = S_OK;
    CDoc * pDoc = Doc();

    if (!pDoc || (pDoc->State() < OS_INPLACE) || pDoc->_fOnLoseCapture)
        goto Cleanup;

    pDoc->SetMouseCapture(
            MOUSECAPTURE_METHOD(CElement, HandleCaptureMessage, handlecapturemessage),
            this,
            containerCapture == VB_TRUE);
Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::releaseCapture()
{
    TakeCapture(FALSE);
    RRETURN(SetErrorInfo(S_OK));
}

BOOL
CElement::HasCapture()
{
    return Doc()->HasCapture(this);
}

BOOL
CElement::WantTextChangeNotifications()
{
    if( !CurrentlyHasAnyLayout() )
        return FALSE;

    // TODO (KTam): Rewrite this to be cleaner.
    // Basically we're trying to do an IsListening call, which
    // tells us whether a flow layout has been calc'ed or not.
    // Think about implementing a virtual IsListening on CLayoutInfo
    // and keeping current CFlowLayout::IsListening as a non-virtual
    // helper (for perf, since IsListening is called heavily inside
    // CFlowLayout).
    CFlowLayout * pFlowLayout = GetUpdatedLayout( GUL_USEFIRSTLAYOUT )->IsFlowLayout();
    if( pFlowLayout && pFlowLayout->IsListening() )
        return TRUE;

    return FALSE;
}

void
CElement::Notify(CNotification * pnf)
{
    CFilterBehaviorSite *  pFilterSite;
    IStream *              pStream = NULL;

    Assert(pnf);

    if (HasPeerHolder())
    {
        GetPeerHolder()->OnElementNotification(pnf);
    }

    switch (pnf->Type())
    {
    
    case NTYPE_MARKUP_RENDER_STYLE:
    {
        if ( HasSlavePtr() &&
             GetSlavePtr()->GetMarkup()->GetElementClient() )
        {
            CNotification nf;
            CTreePos* ptpFirst;
            CTreePos* ptpEnd;
            CMarkup* pMarkup = GetSlavePtr()->GetMarkup();
            
            pMarkup->GetElementClient()->GetTreeExtent( & ptpFirst, & ptpEnd );    
            nf.MarkupRenderStyle( ptpFirst->GetCp(), ptpEnd->GetCp() - ptpFirst->GetCp(), pnf->DataAsPtr() );
            
            pMarkup->Notify( & nf );
        }
    }
    break;
    
    case NTYPE_AMBIENT_PROP_CHANGE:
        pFilterSite = GetFilterSitePtr();
        if (pFilterSite)
        {
            DISPID  dispid;
            ICSSFilter   * pICSSFilter = NULL;

            pnf->Data(&dispid);
            if(!pFilterSite->GetICSSFilter(&pICSSFilter))
            {
                pICSSFilter->OnAmbientPropertyChange(dispid);
                pICSSFilter->Release();
            }
        }
        Invalidate();
        break;

    case NTYPE_COMMAND:
        pFilterSite = GetFilterSitePtr();
        if (pFilterSite)
        {
            COnCommandExecParams *  pParams;

            pnf->Data((void **)&pParams);
            pFilterSite->OnCommand(pParams);
        }
        break;

    case NTYPE_FAVORITES_LOAD:
    case NTYPE_XTAG_HISTORY_LOAD:
    case NTYPE_SNAP_SHOT_SAVE:
        {
            IHTMLPersistData *  pPersist = GetPeerPersist();

            if (pPersist)
            {
                CPtrAry<CElement *> *   pary;

                pnf->Data((void **)&pary);
                pary->Append(this);
                pPersist->Release();
            }
        }
        break;

    case NTYPE_ACTIVE_MOVIE:
        if (Tag() != ETAG_INPUT && HasSlavePtr())
        {
            CElement *      pElemSlave  = GetSlavePtr();
            CNotification   nf;
            void * pv;

            Assert(pElemSlave && pElemSlave->Tag() == ETAG_ROOT);

            pnf->Data(&pv);

            nf.ActiveMovie(pElemSlave, pv);
            pElemSlave->SendNotification(&nf);
        }
        break;

    case NTYPE_SAVE_HISTORY_1:
        if (HasSlavePtr() && Tag() != ETAG_INPUT)
        {
            CElement *  pElemSlave = GetSlavePtr();
        
            if (pElemSlave->IsInMarkup())
            {
                pnf->SetSecondChanceRequested();
            }
        }
        break;

    case NTYPE_XTAG_HISTORY_SAVE:
        {
            void * pv;

            pnf->Data(&pv);
            IGNORE_HR(TryPeerPersist(XTAG_HISTORY_SAVE, pv));
        }
        // Follow through in the normal SAVE_HISTORY notification since we need to
        // bubble the notification to any viewlinked elements.

    case NTYPE_SAVE_HISTORY_2:
        if (HasSlavePtr() && Tag() != ETAG_INPUT)
        {
            CElement *  pElemSlave = GetSlavePtr();
        
            if (pElemSlave->IsInMarkup())
            {
                HRESULT             hr = S_OK;
                CHistorySaveCtx *   phsc;

                pnf->Data((void **)&phsc);

                hr = THR(phsc->BeginSaveStream((0xF000000 | GetSourceIndex()), HistoryCode(), &pStream));
                if (hr)
                    goto Cleanup;

                pElemSlave->GetMarkup()->SaveHistoryInternal(pStream, phsc->_dwOptions);

                hr = THR(phsc->EndSaveStream());
                if (hr)
                    goto Cleanup;
            }
        }
        break;

    case NTYPE_FAVORITES_SAVE:
        {
            void * pv;

            pnf->Data(&pv);
            IGNORE_HR(TryPeerPersist(FAVORITES_SAVE, pv));
        }
        break;

    case NTYPE_DELAY_LOAD_HISTORY:
        {
            CMarkup * pMarkup = GetMarkup();
            CDoc *  pDoc = pMarkup->Doc();
            CMarkupTransNavContext * ptnc = pMarkup->GetTransNavContext();

            if (ptnc && ptnc->_historyCurElem.lIndex >= 0 &&
                HistoryCode() == ptnc->_historyCurElem.dwCode)
            {
                long   lSrcIndex  = GetSourceIndex();

                Assert(lSrcIndex >= 0);

                if (   !pMarkup->_fUserInteracted 
                    &&  lSrcIndex == ptnc->_historyCurElem.lIndex)
                {
                    if (IsEnabled())
                    {
                        pDoc->_fFirstTimeTab = FALSE;
                        BecomeCurrent(ptnc->_historyCurElem.lSubDivision);
                    }
                    
                    // found the current element
                    ptnc->_historyCurElem.lIndex = -1;
                    pMarkup->EnsureDeleteTransNavContext(ptnc);
                }
            }
        }
        break;

    case NTYPE_ELEMENT_EXITVIEW_1:
        // If we have expressions on this elements remove them from the recalc engine 
        // they will be re-added when the element comes back into view
        SuspendExpressionRecalc();
        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        if( HasPeerHolder() || HasAccObjPtr() )
        {
            pnf->SetData( pnf->DataAsDWORD() | EXITTREE_DELAYRELEASENEEDED );
        }

#ifndef NO_DATABINDING
        if (GetDataMemberManager())
        {
            GetDataMemberManager()->Notify(pnf);
        }
#endif

        // Remove this element's expressions (if any) from the recalc engine
        SuspendExpressionRecalc();

        ExitTree( pnf->DataAsDWORD() );

        // Notify slave tree (however, INPUT slave tree is not interesting
        // and doesn't need to hear this).
        if (HasSlavePtr() && Tag() != ETAG_INPUT)
        {
            Assert(_fExittreePending);
            if (IsConnectedToPrimaryWindow())
            {
                // Requrest second-chance since olesites may inplace-deactivate
                // on exitview.
                if (GetSlavePtr()->GetMarkup()->GetObjectRefs() > 1)
                {
                    pnf->SetSecondChanceRequested();
                }
            }
        }
        break;

    case NTYPE_ELEMENT_EXITTREE_2:
        // Notify slave tree (however, INPUT slave tree is not interesting
        // and doesn't need to hear this).
        if (HasSlavePtr() && Tag() != ETAG_INPUT)
        {
            CNotification   nf;
            CElement *      pElemSlave = GetSlavePtr();

            Assert(pElemSlave->Tag() == ETAG_ROOT);

            // Send ExitView notify to the slave tree since it is
            // getting diconnected from the primary markup.
            // For perf reasons we do that only if there is more than 
            // one reference to the master

            nf.ElementExitview1(pElemSlave);

            // TODO (greglett)
            // ExitView does not notify self - so we need to manually notify the ROOT element.
            // Right now, self and second-chance are mutually exclusive.  We need to fix this.
            pElemSlave->Notify(&nf);

            pElemSlave->SendNotification(&nf);
        }
        break;

    case NTYPE_RELEASE_EXTERNAL_OBJECTS:
        // NOTE in most cases we don't receive the notification
        if (HasPeerHolder())
        {
            // delete peer holder ptr and release the peer holder
            DelPeerHolder()->PrivateRelease();
        }
        break;

    case NTYPE_RECOMPUTE_BEHAVIOR:
        IGNORE_HR(ProcessPeerTask(PEERTASK_RECOMPUTEBEHAVIORS));
        break;

    case NTYPE_ELEMENT_ENTERTREE:
        EnterTree();
        break;

    case NTYPE_ELEMENT_ENTERVIEW_1:
        EnterView();
        break;

    case NTYPE_VISIBILITY_CHANGE:
// TODO:   Sanitize this by making official throughout the code that layout-like notifications
//         targeted at positioned elements without layouts are re-directed to the nearest layout.
//         This redirection should be done in CMarkup::NotifyElement rather than ad hoc. (brendand)
//        Assert(GetFirstBranch()->GetCascadedposition() == stylePositionrelative);
        Assert(!ShouldHaveLayout());
        {
            CLayout *   pLayout = GetUpdatedNearestLayout();

            if (pLayout)
            {
                WHEN_DBG(pnf->ResetSN());
                pLayout->Notify(pnf);
            }
        }
        break;

    case NTYPE_MARKUP_UNLOAD_2:
        if (HasSlavePtr())
        {
            CElement *  pElemSlave = GetSlavePtr();
            
            if (pElemSlave && 
                pElemSlave->IsInMarkup() &&
                pElemSlave->GetMarkup()->HasWindow())
            {
                pElemSlave->GetMarkup()->TearDownMarkup();
            }
        }
        
        break;

    case NTYPE_MARKUP_UNLOAD_1:
        if (HasSlavePtr())
        {
            pnf->SetSecondChanceRequested();
        }

        // Fall thru
    case NTYPE_STOP_1:
        if (pnf->Type() != NTYPE_MARKUP_UNLOAD_1)
        {
            if (HasSlavePtr())
            {
                CElement *  pElemSlave = GetSlavePtr();
            
                if (pElemSlave && pElemSlave->IsInMarkup())
                {
                    pElemSlave->GetMarkup()->ExecStop();
                }
            }
        }
        // Fall thru
        
    case NTYPE_STOP_2:
    case NTYPE_BEFORE_UNLOAD:
        if (HasPeerMgr())
        {
            CPeerMgr * pPeerMgr = GetPeerMgr();
            pPeerMgr->DelDownloadProgress();
        }
#ifndef NO_DATABINDING
        if (GetDataMemberManager())
        {
            GetDataMemberManager()->Notify(pnf);
        }
#endif
        break;


    case NTYPE_ELEMENT_INVAL_Z_DESCENDANTS:
        {
            // TODO (carled) this notification should really be unnecessary. what it
            // (and the one above) are crying for is a Notifcation for OnPropertyChange
            // so that descendants can take specific action.  More generally, there are
            // other OPP things like VoidCachedInfo that are duplicating the Notification
            // logic (walking the subtree) which could get rolled into this.  unifiying 
            // these things could go a long way to streamlining the code, and preventing
            // inconsistencies and lots of workarounds. (like this notification)
            //
            // This notification is targeted at positioned elements which are children of 
            // the element that sent it. We do not want to delegate to the nearest Layout
            // since if they are positioned, they have thier own. Since the source element2
            // may not have a layout we have to use the element tree for the routing.

            CLayoutInfo *   pLayoutInfo = GetUpdatedLayoutInfo();

            if (IsPositioned())
            {
                if (pLayoutInfo)
                {
                    WHEN_DBG(pnf->ResetSN());
                    pLayoutInfo->Notify(pnf);
                }
                else
                {
                    Invalidate();
                }
            }
        }
        break;
    case NTYPE_SHOW_WAIT_CURSOR:
        if (HasSlavePtr())
        {
            CElement *pElemSlave = GetSlavePtr();

            if (pElemSlave && pElemSlave->IsInMarkup())
            {
                Assert(pnf->IsDataValid());
                pElemSlave->GetMarkup()->_fShowWaitCursor = pnf->DataAsDWORD() ? TRUE : FALSE;
            }
        }
        break;
    case NTYPE_CHANGE_ACCELERATOR:
        {
            for (CTreeNode *pNode = GetFirstBranch();
                 pNode != NULL;
                 pNode = pNode->NextBranch()
                )
            {
                if (pNode->GetCharFormat()->_fAccelerator)
                {
                    pNode->VoidCachedInfo();
                    Assert(pnf->IsDataValid());
                    // Indicate that there are still accelerators around
                    pnf->SetData((DWORD)1);
                }
            }
        }
        break;
    } // switch
    
Cleanup:
    ClearInterface(&pStream);
    return;
}

HRESULT
CElement::EnterTree()
{
    HRESULT         hr;
    CDoc *          pDoc = Doc();
    CMarkup *       pMarkup;
    InlineEvts *    pInlineEvts;
    BOOL            fInView = IsConnectedToPrimaryWindow();

    Assert( IsInMarkup() );

    pMarkup = GetMarkup();

    // hook up any script for\event handlers attached to this id'd element
    if (pMarkup->_fHasScriptForEvent && !pMarkup->_fMarkupServicesParsing && IsNamed() && (Tag() != ETAG_SCRIPT))
    {
        IGNORE_HR(pDoc->CommitScripts(pMarkup, this));
    }

    // Connect up event handlers...
    if (!pMarkup->_fMarkupServicesParsing || (Tag() == ETAG_OBJECT))
    {
        pInlineEvts = GetEventsToHook();
        if (pInlineEvts)
        {
            BOOL fConnect = TRUE;
            if (pMarkup->HasBehaviorContext())
            {
                CHtmlComponent *pComponent = pMarkup->BehaviorContext()->_pHtmlComponent;
                fConnect = pComponent ? !pComponent->_fFactoryComponent : TRUE;
            }

            if (fConnect)
                pInlineEvts->Connect(pDoc, this);

            delete pInlineEvts;
            StoreEventsToHook(NULL);
        }
    }

    // While we're in a markup, we'll use its WMC ptr
    if ( HasWindowedMarkupContextPtr() )
        DelWindowedMarkupContextPtr()->SubRelease();

    // behaviors
    hr = THR(ProcessPeerTask(PEERTASK_ENTERTREE_UNSTABLE));
    if (hr)
        goto Cleanup;

    // other
    if (fInView)
    {
        EnterView();
    }
    
    //  Init is currently called in the procedure that actually creates the layout.
    //  It does not need to be called here.
    //if (ShouldHaveLayout())
    //{
    //    GetUpdatedLayout()->Init();
    //}
 
    if (pMarkup->CollectionCache())
    {
        OnEnterExitInvalidateCollections(FALSE);
    }

    if (HasSlavePtr() && HasDefaults())
    {
        CDefaults * pDefaults = GetDefaults();

        // Make sure that a cycle is not being created
        Assert(GetSlavePtr()->GetMarkup());

        if (IsCircularViewLink(GetSlavePtr()->GetMarkup()))
        {
            // Found a cycle! Break the viewLink
            hr = THR(pDefaults->put_viewLink(NULL));
            if (hr)
                goto Cleanup;

            Assert(!HasSlavePtr());
#if DBG == 1
            {
                IHTMLDocument * pISlave = NULL;
                Assert(S_OK == pDefaults->get_viewLink(&pISlave) && !pISlave);
            }
#endif
        }
    }

    if (fInView && HasSlavePtr())
    {
        // broadcast an ENTERVIEW notification to the slave content
        CElement *      pElemSlave  = GetSlavePtr();
        CNotification   nf;

        Assert(pElemSlave && pElemSlave->Tag() == ETAG_ROOT);
        nf.ElementEnterview1(pElemSlave);

        // TODO (greglett)
        // EnterView does not notify self - so we need to manually notify the ROOT element.
        // Right now, self and second-chance are mutually exclusive.  We need to fix this.
        pElemSlave->Notify(&nf);

        // INPUTs never have an interesting markup.  Their tree doesn't need to hear this.
        if (Tag() != ETAG_INPUT)
            pElemSlave->SendNotification(&nf);
    }

Cleanup:
    
    RRETURN (hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CElement::EnterView
//
//  Synopsis:   Update the focus collection, initiate data binding, etc.
//
//-------------------------------------------------------------------------

void
CElement::EnterView()
{
    CDoc * pDoc = Doc();

    AttachDataBindings();
    if (_fSurface)
    {
        ++ pDoc->_cSurface;
    }
    if (_f3DSurface)
    {
        ++ pDoc->_c3DSurface;
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CElement::ExitTree
//
//  Synopsis:   Remove the element from the tree, cleanup
//
//-------------------------------------------------------------------------

void
CElement::ExitTree( DWORD dwExitFlags )
{
    CMarkup         * pMarkup = GetMarkup();
    CDoc            * pDoc  = pMarkup->Doc();
    CLayout         * pLayout;   

    Assert(IsInMarkup());
    
    pDoc->OnElementExit(this, dwExitFlags);
    
    if (!pMarkup->_fInnerHTMLMarkup)
    {
        if( !(dwExitFlags & EXITTREE_DESTROY))
        {
            pLayout = GetUpdatedLayout( GUL_USEFIRSTLAYOUT );
    
            if (!IsParentFrozen() &&
                ((pLayout &&  pLayout->IsAdorned()) ||
                ShouldHaveLayout()))
            {
                Assert( pLayout && "Should always have a layout due to, thought we might not need it" );
                //
                // We now send the notification for adorned elements - or 
                // any LayoutElement leaving the tree.
                //
                //
                // TODO marka - make this work via the adorner telling the selection manager
                // to change state. Also make sure _fAdorned is cleared on removal of the Adorner
                //
                IUnknown* pUnknown = NULL;
                IGNORE_HR( this->QueryInterface( IID_IUnknown, ( void**) & pUnknown ));
                IGNORE_HR( pDoc->NotifySelection( EDITOR_NOTIFY_EXIT_TREE , pUnknown ));
                ReleaseInterface( pUnknown );
            }
            pLayout = NULL;
        }
    
        if (pDoc->GetView()->HasAdorners())
        {
            Verify(pDoc->GetView()->OpenView());
            pDoc->GetView()->RemoveAdorners(this);
        }
    
    }
    if (pMarkup->HasCollectionCache())
    {
        OnEnterExitInvalidateCollections(FALSE);
    }

    //
    // Filters do not survive tree changes
    //
    if (_fHasPendingFilterTask)
    {
        pDoc->RemoveFilterTask(this);
        Assert(!_fHasPendingFilterTask);
    }

    // If we don't have any lookasides we don't have to do *any* of the following tests!
    if (_fHasLookasidePtr)
    {
        if (HasPeerHolder() && !(dwExitFlags & EXITTREE_PASSIVATEPENDING))
        {
            IGNORE_HR(ProcessPeerTask(PEERTASK_EXITTREE_UNSTABLE));
        }

#ifndef NO_DATABINDING
        if (HasDataBindPtr())
        {
            DetachDataBindings();
        }
#endif

        if (HasPeerMgr())
        {
            CPeerMgr * pPeerMgr = GetPeerMgr();
            pPeerMgr->OnExitTree();
        }

        //  According to an old, ex-comment: This must happen after the filter has been detached.
        if ( (_fSurface || _f3DSurface) &&
             ( (dwExitFlags & EXITTREE_DOSURFACECOUNT) ||
               (!(dwExitFlags & EXITTREE_DESTROY) && IsConnectedToPrimaryMarkup())
             ))
        {
            if (_fSurface)
            {
                Assert(Doc()->_cSurface > 0);
                Doc()->_cSurface--;
            }
            if (_f3DSurface)
            {
                Assert(Doc()->_c3DSurface > 0);
                Doc()->_c3DSurface--;
            }
        }

        // If we've queued layout requests on other layouts, we need to
        // mark the request as dead, since we're leaving the tree and don't
        // need to be serviced.  Refs on the CRequest obj are held by the
        // corresponding layouts, so we don't need to release here -- instead
        // we'll let the layout's ProcessRequests take care of it.
        if (HasRequestPtr())
        {
            GetRequestPtr()->RemoveFromLayouts();
            AssertSz( !HasRequestPtr(), "Removing from layouts should have caused request to go away!" );
        }
    }

    // Remember our WMC before we go back to the ether
    Assert( !HasWindowedMarkupContextPtr() );

    // TODO (JHarding) - If we can't set this pointer, this element is in bad shape.
    if( !SetWindowedMarkupContextPtr( GetWindowedMarkupContext() ) )
        GetWindowedMarkupContextPtr()->SubAddRef();

    if (HasLayoutPtr())
    {
        CLayout *   pLayout;

        GetUpdatedLayout()->OnExitTree();

        if (!_fLayoutAlwaysValid)
        {
            pLayout = DelLayoutPtr();

            pLayout->Detach();
            pLayout->Release();
        }
    }
    // We may have multiple layouts!
    else if ( HasLayoutAry() )
    {
        CLayoutAry *pLA;

        pLA = GetLayoutAry();
        pLA->OnExitTree();

        if ( !_fLayoutAlwaysValid )
        {
            DelLayoutAry(); // will take care of detaching/releasing its layouts
        }            
    }
}

//+------------------------------------------------------------------------
//  Member:     CElement::SuspendExpressionRecalc
//
//  Synopsis:   If we have expressions on this element remove them from the 
//              recalc engine - they will be re-added to the recalc engine 
//              when the element comes back into view
//-------------------------------------------------------------------------

void
CElement::SuspendExpressionRecalc()
{
    CDoc    * pDoc =  Doc();

    if (_fHasPendingRecalcTask)
        pDoc->RemoveExpressionTask(this);

    if (_fHasExpressions)
        pDoc->_recalcHost.removeAllExpressions(this);
}

//+---------------------------------------------------------------------------------
//
//  Member :    CElement::IsEqualObject()
//
//  Synopsis :  IObjectIdentity method implementation. it direct comparison of two
//              pUnks fails, then the script engines will QI for IObjectIdentity and
//              call IsEqualObject one one, passing in the other pointer.
//
//   Returns : S_OK if the Objects are the same
//             E_FAIL if the objects are different
//
//----------------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CElement::IsEqualObject(IUnknown * pUnk)
{
    HRESULT      hr = E_POINTER;
    IServiceProvider * pISP = NULL;
    IUnknown   * pUnkTarget = NULL;
    IUnknown   * pUnkThis = NULL;

    if (!pUnk)
        goto Cleanup;

    hr = THR_NOTRACE(QueryInterface(IID_IUnknown, (void **)&pUnkThis));
    if (hr)
        goto Cleanup;

    if (pUnk == pUnkThis)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = THR_NOTRACE(pUnk->QueryInterface(IID_IServiceProvider, (void**)&pISP));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(pISP->QueryService(SID_ELEMENT_SCOPE_OBJECT,
                                        IID_IUnknown,
                                        (void**)&pUnkTarget));
    if (hr)
        goto Cleanup;

    hr = (pUnkThis == pUnkTarget) ? S_OK : S_FALSE;

Cleanup:
    ReleaseInterface(pUnkThis);
    ReleaseInterface(pUnkTarget);
    ReleaseInterface(pISP);
    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------------------
//
//  Method : CElement :: QueryService
//
//  Synopsis : IServiceProvider methoid Implementaion.
//
//-----------------------------------------------------------------------------
HRESULT
CElement::QueryService(REFGUID guidService, REFIID riid, void **ppvObject)
{
    HRESULT hr = E_POINTER;

    if (!ppvObject)
        goto Cleanup;

    if (IsEqualGUID(guidService, SID_ELEMENT_SCOPE_OBJECT))
    {
        hr = THR_NOTRACE(QueryInterface(riid, ppvObject));
    }
    else if (IsEqualGUID(guidService, CLSID_HTMLWindow2))
    {
        CMarkup * pMarkup = GetNearestMarkupForScriptCollection();

        Assert(pMarkup);
        Assert(pMarkup->HasWindow());

        *ppvObject = pMarkup->Window()->Window();

        hr = S_OK;
    }
    else if (IsEqualGUID(guidService, IID_IAccessible))
    {
        CAccBase * pAccObj = GetAccObjOfElement(this);

        // The pointer we receive is not addref'd QI for IAccessible and return that.
        // To make sure, we expect that the riid == IID_IAccessible

        // It is possible to receive a NULL pointer from the function call in case
        // the element is not accessible.
        if (pAccObj)
        {
            hr = THR(pAccObj->QueryInterface( riid, ppvObject));
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }
    else
    {
        hr = THR_NOTRACE(super::QueryService(guidService, riid, ppvObject));
        if (hr == E_NOINTERFACE)
        {
            if (IsInMarkup())
            {
                CDocument * pDocument = GetMarkup()->Document();
                
                if (pDocument)
                {
                    hr = THR_NOTRACE(pDocument->QueryService(guidService, riid, ppvObject));
                }
            }
            else
            {
                hr = THR_NOTRACE(Doc()->QueryService(guidService, riid, ppvObject));
            }
        }
    }

Cleanup:
    RRETURN1( hr, E_NOINTERFACE);
}

//+-------------------------------------------------------------------------
//
//  Method:     CElement::ContextThunk_Invoke
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

#ifdef USE_STACK_SPEW
#pragma check_stack(off)
#endif

STDMETHODIMP
CElement::ContextThunk_Invoke(
        DISPID dispidMember,
        REFIID riid,
        LCID lcid,
        WORD wFlags,
        DISPPARAMS * pdispparams,
        VARIANT * pvarResult,
        EXCEPINFO * pexcepinfo,
        UINT *)
{
    IUnknown * pUnkContext;

    // Magic macro which pulls context out of nowhere (actually eax)
    CONTEXTTHUNK_SETCONTEXT

    HRESULT         hr;
    IDispatchEx    *pDispEx;

    if (!IsEqualIID(riid, IID_NULL))
        RRETURN(E_INVALIDARG);

    if (!pUnkContext)
        pUnkContext = (IUnknown*)this;

    if (HasPeerHolder())
    {
        hr = THR_NOTRACE(GetPeerHolder()->InvokeExMulti(
            dispidMember,
            lcid,
            wFlags,
            pdispparams,
            pvarResult,
            pexcepinfo,
            NULL));
        if (DISP_E_MEMBERNOTFOUND != hr) // if succeced or failed with error other then DISP_E_MEMBERNOTFOUND
            goto Cleanup;
    }

    hr = THR(pUnkContext->QueryInterface(IID_IDispatchEx, (void **)&pDispEx));
    if (hr)
    {
        // Object doesn't support IDispatchEx use CBase::InvokeEx
        hr = ContextInvokeEx(
            dispidMember,
            lcid,
            wFlags,
            pdispparams,
            pvarResult,
            pexcepinfo,
            NULL,
            pUnkContext ? pUnkContext : (IUnknown*)this);
    }
    else
    {
        // Object supports IDispatchEx call InvokeEx thru it's v-table.
        hr = pDispEx->InvokeEx(dispidMember, lcid, wFlags, pdispparams,pvarResult, pexcepinfo, NULL);
        ReleaseInterface(pDispEx);
    }

Cleanup:
    RRETURN(hr);
}

#ifdef USE_STACK_SPEW
#pragma check_stack(on)
#endif


//+-------------------------------------------------------------------------
//
//  Method:     CElement::ContextThunk_InvokeEx, IDispatchEx
//
//  Synopsis:   Gets node context from eax and passes it to ContextInvokeEx
//
//--------------------------------------------------------------------------

#ifdef USE_STACK_SPEW
#pragma check_stack(off)
#endif

STDMETHODIMP CElement::ContextThunk_InvokeEx(DISPID dispidMember,
                                             LCID lcid,
                                             WORD wFlags,
                                             DISPPARAMS * pdispparams,
                                             VARIANT * pvarResult,
                                             EXCEPINFO * pexcepinfo,
                                             IServiceProvider *pSrvProvider)
{
    HRESULT     hr;
    IUnknown *  pUnkContext;

    // Magic macro which pulls context out of nowhere (actually eax)
    CONTEXTTHUNK_SETCONTEXT

    hr = THR_NOTRACE(CElement::ContextInvokeEx(dispidMember,
                                  lcid,
                                  wFlags,
                                  pdispparams,
                                  pvarResult,
                                  pexcepinfo,
                                  pSrvProvider,
                                  pUnkContext ? pUnkContext : (IUnknown*)this));

    RRETURN (hr);
}

#ifdef USE_STACK_SPEW
#pragma check_stack(on)
#endif

//+-------------------------------------------------------------------------
//
//  Method:     CElement::ContextInvokeEx, IDispatchEx
//
//  Synopsis:   Real implementation of InvokeEx.  Uses context passed
//              in for actual calls
//
//--------------------------------------------------------------------------

STDMETHODIMP CElement::ContextInvokeEx(DISPID dispidMember,
                                    LCID lcid,
                                    WORD wFlags,
                                    DISPPARAMS * pdispparams,
                                    VARIANT * pvarResult,
                                    EXCEPINFO * pexcepinfo,
                                    IServiceProvider *pSrvProvider,
                                    IUnknown *pUnkContext)
{
    HRESULT     hr;

    if (HasPeerHolder())
    {
        hr = THR_NOTRACE(GetPeerHolder()->InvokeExMulti(
            dispidMember,
            lcid,
            wFlags,
            pdispparams,
            pvarResult,
            pexcepinfo,
            pSrvProvider));
        if (DISP_E_MEMBERNOTFOUND != hr) // if succeced or failed with error other then DISP_E_MEMBERNOTFOUND
            goto Cleanup;
    }

    hr = THR_NOTRACE(CBase::ContextInvokeEx(dispidMember,
                                  lcid,
                                  wFlags,
                                  pdispparams,
                                  pvarResult,
                                  pexcepinfo,
                                  pSrvProvider,
                                  pUnkContext ? pUnkContext : (IUnknown*)this));

Cleanup:
    RRETURN (hr);
}

//+----------------------------------------------------------------------------------
//
//  Member:     CElement::GetDispID, per IDispatchEx
//
//-----------------------------------------------------------------------------------

HRESULT
CElement::GetDispID(BSTR bstrName, DWORD grfdex, DISPID * pid)
{
    HRESULT         hr;

    if (GetFrameOrPrimaryMarkup())
    {
        GetFrameOrPrimaryMarkup()->ProcessPeerTasks(0);
    }

    if (HasPeerHolder())
    {
        hr = THR_NOTRACE(GetPeerHolder()->GetDispIDMulti(bstrName, grfdex, pid));
        if (DISP_E_UNKNOWNNAME != hr) // if succeeded or failed with error other then DISP_E_UNKNOWNNAME
            goto Cleanup;
    }

    hr = THR_NOTRACE(super::GetDispID(bstrName, grfdex, pid));

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------------
//
//  Member:     CElement::GetExpandoDispID, helper
//
//-----------------------------------------------------------------------------------

HRESULT
CElement::GetExpandoDispID(BSTR bstrName, DISPID * pid, DWORD grfdex)
{
    return GetExpandoDISPID(bstrName, pid, grfdex);
}

HRESULT
CElement::GetExpandoDISPID(LPTSTR pchName, DISPID *pid, DWORD grfdex)
{
    HRESULT     hr;

    hr = THR_NOTRACE(super::GetExpandoDispID(pchName, pid, grfdex));
    if (hr)
        goto Cleanup;

    if (TestClassFlag(ELEMENTDESC_OLESITE))
    {
        DYNCAST(COleSite, this)->RemapActivexExpandoDispid(pid);
    }

Cleanup:

    RRETURN (hr);
}


//+----------------------------------------------------------------------------------
//
//  Member:     CElement::GetNextDispID, per IDispatchEx
//
//-----------------------------------------------------------------------------------

HRESULT
CElement::GetNextDispID(DWORD grfdex, DISPID dispid, DISPID * pdispid)
{
    HRESULT         hr = S_FALSE;
    CPeerHolder *   pPeerHolder;

    if (!IsPeerDispid(dispid))
    {
        hr = THR_NOTRACE(super::GetNextDispID(grfdex, dispid, pdispid));
        if (S_FALSE != hr)  // if (S_OK == hr || FAILED(hr))
            goto Cleanup;
    }

    pPeerHolder = GetPeerHolder();

    if (pPeerHolder)
    {
        hr = THR_NOTRACE(pPeerHolder->GetNextDispIDMulti(grfdex, dispid, pdispid));
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------------------------
//
//  Member:     CElement::GetMemberName, per IDispatchEx
//
//-----------------------------------------------------------------------------------

HRESULT
CElement::GetMemberName(DISPID dispid, BSTR * pbstrName)
{
    HRESULT         hr;

    if (IsPeerDispid(dispid))
    {
        CPeerHolder *   pPeerHolder = GetPeerHolder();

        if (pPeerHolder)
        {
            hr = THR_NOTRACE(pPeerHolder->GetMemberNameMulti(dispid, pbstrName));
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        goto Cleanup;   // done
    }

    hr = THR_NOTRACE(super::GetMemberName(dispid, pbstrName));

Cleanup:
    RRETURN2(hr, DISP_E_MEMBERNOTFOUND, DISP_E_UNKNOWNNAME);
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetMultiTypeInfoCount, per IProvideMultipleClassInfo
//
//----------------------------------------------------------------------------

HRESULT
CElement::GetMultiTypeInfoCount(ULONG * pCount)
{
    HRESULT     hr;

    if (GetReadyState() < READYSTATE_COMPLETE)
        RRETURN (E_UNEXPECTED);

    Assert (pCount);
    if (!pCount)
        RRETURN (E_POINTER);

    hr = THR(super::GetMultiTypeInfoCount(pCount));
    if (hr)
        goto Cleanup;

    if (HasPeerHolder())
    {
        hr = THR(GetPeerHolder()->GetCustomEventsTypeInfoCount(pCount));
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetInfoOfIndex, per IProvideMultipleClassInfo
//
//----------------------------------------------------------------------------

HRESULT
CElement::GetInfoOfIndex(
    ULONG       iTI,
    DWORD       dwFlags,
    ITypeInfo** ppTICoClass,
    DWORD*      pdwTIFlags,
    ULONG*      pcdispidReserved,
    IID *       piidPrimary,
    IID *       piidSource)
{
    HRESULT         hr;

    if (GetReadyState() < READYSTATE_COMPLETE)
        RRETURN (E_UNEXPECTED);

    if (HasPeerHolder())
    {
        hr = THR(GetPeerHolder()->CreateCustomEventsTypeInfo(iTI, ppTICoClass));
        if (S_FALSE != hr)  // if (S_OK == hr || FAILED(hr))
            goto Cleanup;   // nothing more to do
        // S_FALSE indicated that this belongs to super
    }

    hr = THR(super::GetInfoOfIndex(
        iTI, dwFlags, ppTICoClass, pdwTIFlags, pcdispidReserved, piidPrimary, piidSource));

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::CreateTearOffThunk
//
//----------------------------------------------------------------------------

HRESULT
CElement::CreateTearOffThunk(
    void *      pvObject1,
    const void * apfn1,
    IUnknown *  pUnkOuter,
    void **     ppvThunk,
    void *      appropdescsInVtblOrder)
{
    CPeerHolder *   pPeerHolderInQI = GetPeerHolderInQI();
    if (pPeerHolderInQI)
    {
        return ::CreateTearOffThunk(
            pvObject1,
            apfn1,
            pUnkOuter,
            ppvThunk,
            pPeerHolderInQI,
            *(void **)(IUnknown *)pPeerHolderInQI,
            QI_MASK | ADDREF_MASK | RELEASE_MASK,
            NULL,
            appropdescsInVtblOrder);
    }
    else
    {
        return ::CreateTearOffThunk(
            pvObject1,
            apfn1,
            pUnkOuter,
            ppvThunk,
            appropdescsInVtblOrder);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::CreateTearOffThunk
//
//----------------------------------------------------------------------------

HRESULT
CElement::CreateTearOffThunk(
    void*       pvObject1,
    const void * apfn1,
    IUnknown *  pUnkOuter,
    void **     ppvThunk,
    void *      pvObject2,
    void *      apfn2,
    DWORD       dwMask,
    const IID * const * apIID,
    void *      appropdescsInVtblOrder)
{
    CPeerHolder *   pPeerHolderInQI = GetPeerHolderInQI();
    if (pPeerHolderInQI && !pvObject2)
    {
        pvObject2 = pPeerHolderInQI;
        apfn2 = *(void **)(IUnknown *)pPeerHolderInQI;
        dwMask |= QI_MASK | ADDREF_MASK | RELEASE_MASK;
    }

    return ::CreateTearOffThunk(
        pvObject1,
        apfn1,
        pUnkOuter,
        ppvThunk,
        pvObject2,
        apfn2,
        dwMask,
        apIID,
        appropdescsInVtblOrder);
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::get_dir
//
//  Synopsis: Object model entry point to get the dir property.
//
//  Arguments:
//            [p]  - where to return BSTR containing the string
//
//  Returns:  S_OK                  - this element supports this property
//            DISP_E_MEMBERNOTFOUND - this element doesn't support this
//                                    property
//            E_OUTOFMEMORY         - memory allocation failure
//            E_POINTER             - NULL pointer to receive BSTR
//
//----------------------------------------------------------------------------
STDMETHODIMP
CElement::get_dir(BSTR * p)
{
    HRESULT hr;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if ( p )
        *p = NULL;

    hr = s_propdescCElementdir.b.GetEnumStringProperty(
                p,
                this,
                (CVoid *)(void *)(GetAttrArray()) );

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::put_dir
//
//  Synopsis: Object model entry point to put the dir property.
//
//  Arguments:
//            [v]  - BSTR containing the new property value (ltr or rtl)
//
//  Returns:  S_OK                  - successful
//            DISP_E_MEMBERNOTFOUND - this element doesn't support this
//                                    property
//            E_INVALIDARG          - the argument is not one of the enum string
//                                    values (ltr or rtl)
//
//----------------------------------------------------------------------------
STDMETHODIMP
CElement::put_dir(BSTR v)
{
    HRESULT hr;

    hr = s_propdescCElementdir.b.SetEnumStringProperty(
                v,
                this,
                (CVoid *)(void *)(GetAttrArray()) );

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Lookaside storage
//
//----------------------------------------------------------------------------

void *
CElement::GetLookasidePtr(int iPtr) const
{
#if DBG == 1
    if(HasLookasidePtr(iPtr))
    {
        void * pLookasidePtr =  Doc()->GetLookasidePtr((DWORD *)this + iPtr);

        Assert(pLookasidePtr == _apLookAside[iPtr]);

        return pLookasidePtr;
    }
    else
        return NULL;
#else
    return(HasLookasidePtr(iPtr) ? Doc()->GetLookasidePtr((DWORD *)this + iPtr) : NULL);
#endif
}

HRESULT
CElement::SetLookasidePtr(int iPtr, void * pvVal)
{
    Assert (!HasLookasidePtr(iPtr) && "Can't set lookaside ptr when the previous ptr is not cleared");

    HRESULT hr = THR(Doc()->SetLookasidePtr((DWORD *)this + iPtr, pvVal));

    if (hr == S_OK)
    {
        _fHasLookasidePtr |= 1 << iPtr;

#if DBG == 1
        _apLookAside[iPtr] = pvVal;
#endif
    }

    RRETURN(hr);
}

void *
CElement::DelLookasidePtr(int iPtr)
{
    if (HasLookasidePtr(iPtr))
    {
        void * pvVal = Doc()->DelLookasidePtr((DWORD *)this + iPtr);
        _fHasLookasidePtr &= ~(1 << iPtr);
#if DBG == 1
        _apLookAside[iPtr] = NULL;
#endif
        return(pvVal);
    }

    return(NULL);
}

void *
CElement::GetLookasidePtr2(int iPtr) const
{
#if DBG == 1
    if(HasLookasidePtr2(iPtr))
    {
        void * pLookasidePtr2 =  Doc()->GetLookasidePtr2((DWORD *)this + iPtr);

        Assert(pLookasidePtr2 == _apLookAside2[iPtr]);

        return pLookasidePtr2;
    }
    else
        return NULL;
#else
    return(HasLookasidePtr2(iPtr) ? Doc()->GetLookasidePtr2((DWORD *)this + iPtr) : NULL);
#endif
}

HRESULT
CElement::SetLookasidePtr2(int iPtr, void * pvVal)
{
    Assert (!HasLookasidePtr2(iPtr) && "Can't set lookaside ptr when the previous ptr is not cleared");

    HRESULT hr = THR(Doc()->SetLookasidePtr2((DWORD *)this + iPtr, pvVal));

    if (hr == S_OK)
    {
        _fHasLookasidePtr2 |= 1 << iPtr;

#if DBG == 1
        _apLookAside2[iPtr] = pvVal;
#endif
    }

    RRETURN(hr);
}

void *
CElement::DelLookasidePtr2(int iPtr)
{
    if (HasLookasidePtr2(iPtr))
    {
        void * pvVal = Doc()->DelLookasidePtr2((DWORD *)this + iPtr);
        _fHasLookasidePtr2 &= ~(1 << iPtr);
#if DBG == 1
        _apLookAside2[iPtr] = NULL;
#endif
        return(pvVal);
    }

    return(NULL);
}

//+---------------------------------------------------------------------------
//
//  Native accessibility support
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//  Member  :   AccObjForTag
//
//  Synopsis:   Creates and returns a CAccBase derived instance, 
//              depending on the tag of the element. If the tag is not supported
//              the tabindex is checked if the flag is set. 
//----------------------------------------------------------------------------
CAccElement * 
CElement::AccObjForTag()
{
    switch (Tag())
    {
        case ETAG_BODY:
        case ETAG_FRAMESET:
            return new CAccBody( this );
            break;

        case ETAG_A:
          return new CAccAnchor( this );
          break;

        case ETAG_AREA:
            return new CAccArea( this );
            break;

        case ETAG_BUTTON:
            return new CAccButton( this );
            break;

        case ETAG_IMG:
            return new CAccImage( this );
            break;

        case ETAG_MARQUEE:
            return new CAccMarquee( this );
            break;

        case ETAG_TEXTAREA:
            return new CAccEdit( this, FALSE);
            break;

        case ETAG_INPUT:
            {
                htmlInput type = DYNCAST(CInput, this)->GetAAtype();
                switch(type)
                {
                case htmlInputCheckbox:
                    return new CAccCheckbox( this );

                case htmlInputRadio:
                   return new CAccRadio( this );

                case htmlInputImage:
                    return new CAccInputImg( this );

                case htmlInputButton:
                case htmlInputReset:
                case htmlInputSubmit:
                    return new CAccButton( this );

                case htmlInputPassword:
                    return new CAccEdit( this, TRUE );

                case htmlInputText:
                case htmlInputHidden:
                    return new CAccEdit( this, FALSE );

                case htmlInputFile:
                    return new CAccInputFile( this );
                }
            }
            break;

        case ETAG_LABEL:
            return new CAccLabel(this);
            break;

        case ETAG_OBJECT:
        case ETAG_EMBED:
        case ETAG_APPLET:
            return new CAccObject( this );
            break;

        case ETAG_TABLE:
            return new CAccTable( this );
            break;

        case ETAG_TH:
        case ETAG_TD:
            return new CAccTableCell( this );
            break;

        case ETAG_SELECT:
            return new CAccSelect( this );
            break;

        default:
            // but wait there is one more check, if this element is normally
            // unsupported (not in the about cases) then we still want to
            // create an accObject if this element has an explicit tabstop set.
            if (GetAAtabIndex() != htmlTabIndexNotSet)
            {
                return new CAccTabStopped( this );
            }
    }

    return NULL;
}

//+---------------------------------------------------------------------------
//  Member  :   AccObjForBehavior
//  
//  Synopsis:   Get the accessible object for a behavior implementation.
//
//    1. A behavior that implements IAccessible:                        We want to create an AccBehavior that delegates
//    2. A behavior that does not implement IAccessible                 Return NULL and let CreatAccObj handle it
//    3. A view link without an attached that implements IAccessible    We want to create an AccBehavior that does not delegate
//
//----------------------------------------------------------------------------

CAccElement * 
CElement::AccObjForBehavior()
{
    CAccBehavior *  pAccBehavior = NULL;

    if (IsIAccessiblePeer(this))
    {
        pAccBehavior = new CAccBehavior(this, TRUE);      
    }                                                
    else if (HasSlavePtr() && Tag() != ETAG_INPUT)
    {
        pAccBehavior = new CAccBehavior(this, FALSE); 

        Assert(pAccBehavior);

        if (pAccBehavior)
        {
            IGNORE_HR(pAccBehavior->EnsureSubElement());
        }
    }

    return pAccBehavior;
}

//----------------------------------------------------------------------------
//  Member:   CElement::CreateAccObj
//
//  Synopsis: Creates and returns the proper accessibility object for this element
//
//    1. A behavior that implements IAccessible:                        We want to create an AccBehavior that delegates
//    2. A behavior that does not implement IAccessible                 If the tag is supported or there is a tabindex we want to create the appropriate AccObj
//    3. A view link without an attached that implements IAccessible    We want to create an AccBehavior that does not delegate
//    4. A normal tag without an attached that implements IAccessible   If the tag is supported or there is a tabindex we want to create the appropriate AccObj
//
//----------------------------------------------------------------------------

CAccElement *
CElement::CreateAccObj()
{
    CAccElement * pAcc = NULL;

    if (HasPeerHolder())
    {
        pAcc = AccObjForBehavior(); // Cases 1 and 3 (If 2 AccObjForBehavior will return NULL)
    }
    
    if (pAcc == NULL)
    {
        pAcc = AccObjForTag();      // Case  2 and 4
    }

    return pAcc;
}

CElement *
CElement::GetParentAncestorSafe(ELEMENT_TAG etag) const
{
    CTreeNode *pNode = GetFirstBranch();
    CElement  *p = NULL;
    if (pNode)
    {
        pNode = pNode->Parent();
        if (pNode)
        {
            pNode = pNode->Ancestor(etag);
            if (pNode)
                p = pNode->Element();
        }
    }
    return p;
}

CElement *
CElement::GetParentAncestorSafe(const ELEMENT_TAG *arytag) const
{
    CTreeNode *pNode = GetFirstBranch();
    CElement  *p = NULL;
    if (pNode)
    {
        pNode = pNode->Parent();
        if (pNode)
        {
            pNode = pNode->Ancestor(arytag);
            if (pNode)
                p = pNode->Element();
        }
    }
    return p;
}

//
// CElement Collection Helpers - manage the WINDOW_COLLECTION
//
HRESULT
CElement::GetIDHelper ( CStr *pf )
{
    LPCTSTR lpszID = NULL;
    HRESULT hr;

    if (_pAA && _pAA->HasAnyAttribute())
        _pAA->FindString(DISPID_CElement_id, &lpszID);

    hr = THR(pf->Set ( lpszID ));

    return hr;
}

HRESULT 
CElement::SetIdentifierHelper ( LPCTSTR lpszValue, DISPID dspIDThis, DISPID dspOther1, DISPID dspOther2 )
{
    HRESULT     hr;
    BOOL        fNamed;
    CDoc *      pDoc = Doc();
    CMarkup *   pMarkup = GetMarkup();

    // unhook any old script attached to this element.
    if (pMarkup && (Tag() != ETAG_SCRIPT) && IsNamed())
    {
        pDoc->CommitScripts(pMarkup, this, FALSE);
    }
    
    hr = AddString (dspIDThis, lpszValue, CAttrValue::AA_Attribute );
    if ( !hr )
    {
        // Remember if we're named, so that if this element moves into a different tree
        // we can inval the appropriate collections
        fNamed = lpszValue && lpszValue [ 0 ];
 
        // We're named if NAME= or ID= something or we have a unique name
        if ( !fNamed )
        {
            LPCTSTR lpsz = NULL;
            if (_pAA && _pAA->HasAnyAttribute())
            {
                _pAA->FindString(dspOther1, &lpsz);
                if ( !(lpsz && *lpsz ) )
                    _pAA->FindString(dspOther2, &lpsz);
            }
            fNamed = lpsz && *lpsz;
        }
        
        _fIsNamed = fNamed;
        // Inval all collections affected by a name change
        DoElementNameChangeCollections();

        // hook up any script for\event handlerw attached to this element thru new id
        if (pMarkup && (Tag() != ETAG_SCRIPT) && _fIsNamed)
        {
            pDoc->CommitScripts(pMarkup, this);
        }

    }

    RRETURN(hr);
}

HRESULT
CElement::SetIDHelper ( CStr *pf )
{
    RRETURN(SetIdentifierHelper((LPCTSTR)(*pf),
        DISPID_CElement_id,
        STDPROPID_XOBJ_NAME,
        DISPID_CElement_uniqueName));   
}

HRESULT
CElement::GetnameHelper ( CStr *pf )
{
    LPCTSTR lpszID = NULL;
    HRESULT hr;

    if (_pAA && _pAA->HasAnyAttribute())
        _pAA->FindString(STDPROPID_XOBJ_NAME, &lpszID);

    hr = THR(pf->Set ( lpszID ));

    return hr;
}

HRESULT
CElement::SetnameHelper ( CStr *pf )
{
    RRETURN(SetIdentifierHelper((LPCTSTR)(*pf),
        STDPROPID_XOBJ_NAME,
        DISPID_CElement_id,
        DISPID_CElement_uniqueName));   
}

HRESULT
CElement::SetUniqueNameHelper ( LPCTSTR szUniqueName )
{
    RRETURN(SetIdentifierHelper( szUniqueName,
        DISPID_CElement_uniqueName,
        DISPID_CElement_id,
        STDPROPID_XOBJ_NAME));   
}

void
CElement::InvalidateCollection ( long lIndex )
{
    CMarkup *pMarkup;
    CCollectionCache *pCollCache;

    pMarkup = GetMarkup();
    if ( pMarkup )
    {
        pCollCache = pMarkup->CollectionCache();
        if ( pCollCache )
        {
            pCollCache->InvalidateItem ( lIndex );
        }
    }
}

//
// Replace CBase::removeAttribute, need to special case some DISPID's
//

HRESULT 
CElement::removeAttribute(BSTR strPropertyName, LONG lFlags, VARIANT_BOOL *pfSuccess)
{
    DISPID dispID;
    IDispatchEx *pDEX = NULL;

    if (pfSuccess)
        *pfSuccess = VB_FALSE;

    // TODO rgardner should move the STDPROPID_XOBJ_STYLE
    // code from CBase::removeAttribute to here

    if (THR_NOTRACE(PrivateQueryInterface ( IID_IDispatchEx, (void**)&pDEX )))
        goto Cleanup;

    if (THR_NOTRACE(pDEX->GetDispID(strPropertyName, lFlags & GETMEMBER_CASE_SENSITIVE ?
                                                    fdexNameCaseSensitive : 0, &dispID)))
        goto Cleanup;

    if (!removeAttributeDispid(dispID))
        goto Cleanup;


    // If we remove name or ID, update the WINDOW_COLLECTION if needed
    // Don't need to deal with uniqueName here - it's not exposed externaly

    if ( dispID == DISPID_CElement_id || dispID == STDPROPID_XOBJ_NAME )
    {
        LPCTSTR lpszNameID = NULL;
        BOOL fNamed;

        // Named if ID or name is present
        if (_pAA && _pAA->HasAnyAttribute())
        {
            _pAA->FindString( dispID == DISPID_CElement_id ?
                    STDPROPID_XOBJ_NAME : 
                    DISPID_CElement_id, 
                &lpszNameID);
            if ( !(lpszNameID && *lpszNameID ) )
                _pAA->FindString(DISPID_CElement_uniqueName, &lpszNameID);
        }

        fNamed = lpszNameID && *lpszNameID;

        if ( fNamed != !!_fIsNamed )
        {
            // Inval all collections affected by a name change
            DoElementNameChangeCollections();
            _fIsNamed = fNamed;
        }
    }

    if (pfSuccess)
        *pfSuccess = VB_TRUE;

Cleanup:
    ReleaseInterface ( pDEX );

    RRETURN ( SetErrorInfo ( S_OK ) );
}


//----------------------------------------------------------------------------
//  Member:   CElement::Primitive(Get/Set)Expando
//
//  Synopsis: Gets or sets the given variant as an expando into the AA.
//            This does not fire any events, support undo, &c...
//
//----------------------------------------------------------------------------
HRESULT
CElement::PrimitiveSetExpando(BSTR bstrPropertyName, VARIANT varPropertyValue)
{
    HRESULT hr;
    DISPID  dispID;
    AAINDEX aaIdx;

    hr = THR(CBase::GetExpandoDispID(bstrPropertyName, &dispID, fdexNameEnsure));
    if (hr)
        goto Cleanup;

    aaIdx = FindAAIndex(dispID, CAttrValue::AA_Expando);

    if (aaIdx == AA_IDX_UNKNOWN)
    {
        hr = AddVariant(dispID,
                        &varPropertyValue,
                        CAttrValue::AA_Expando);
    }
    else
    {
        hr = ChangeVariantAt(aaIdx, &varPropertyValue);
    }

Cleanup:
    return hr;
}

HRESULT
CElement::PrimitiveGetExpando(BSTR bstrPropertyName, VARIANT *pvarPropertyValue)
{
    HRESULT hr;
    DISPID  dispID;

    hr = CBase::GetExpandoDispID(bstrPropertyName, &dispID, 0);
    if (hr)
        goto Cleanup;

    hr = GetVariantAt(FindAAIndex(dispID, CAttrValue::AA_Expando),
                      pvarPropertyValue, /* fAllowNullVariant = */FALSE);

Cleanup:
    return hr;
}


HRESULT
CElement::PrimitiveRemoveExpando(BSTR bstrPropertyName)
{
    HRESULT hr;
    DISPID  dispID;

    hr = THR ( CBase::GetExpandoDispID(bstrPropertyName, &dispID, 0) );
    if (hr)
        goto Cleanup;

    DeleteAt(FindAAIndex(dispID, CAttrValue::AA_Expando));

Cleanup:
    return hr;
}

HRESULT
CElement::OnTabIndexChange()
{
    long                i;
    HRESULT             hr = S_OK;
    CMarkup           * pMarkup = GetMarkup();
    CAryFocusItem     * paryFocusItem;
    
    Assert (pMarkup);
    paryFocusItem = pMarkup->GetFocusItems(TRUE);
    Assert (paryFocusItem);

    for (i = 0; i < paryFocusItem->Size(); i++)
    {
        if ((*paryFocusItem)[i].pElement == this)
        {
            paryFocusItem->Delete(i);
        }
    }
    
    hr = THR(pMarkup->InsertFocusArrayItem(this));
    if (hr) 
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


void
CElement::OnEnterExitInvalidateCollections(BOOL fForceNamedBuild)
{
    //
    // Optimized collections
    // If a named (name= or ID=) element enters the tree, inval the collections
    //
    
    //
    // DEVNOTE rgardner
    // This code is tighly couples with CMarkup::AddToCollections and needs
    // to be kept in sync with any changes in that function
    //

    if (IsNamed() || fForceNamedBuild)
    {
        InvalidateCollection ( CMarkup::WINDOW_COLLECTION );
    }

    // Inval collections based on specific element types
    switch ( _etag )
    {
    case ETAG_LABEL:
        InvalidateCollection ( CMarkup::LABEL_COLLECTION );
        break;

    case ETAG_FRAME:
    case ETAG_IFRAME:
        InvalidateCollection ( CMarkup::FRAMES_COLLECTION );
        if ( IsNamed() || fForceNamedBuild )
            InvalidateCollection ( CMarkup::NAVDOCUMENT_COLLECTION );
        break;

    case ETAG_IMG:
        InvalidateCollection ( CMarkup::IMAGES_COLLECTION );
        if ( IsNamed() || fForceNamedBuild )
            InvalidateCollection ( CMarkup::NAVDOCUMENT_COLLECTION );
        break;

    case ETAG_OBJECT:
    case ETAG_APPLET:
        InvalidateCollection ( CMarkup::APPLETS_COLLECTION );
        if ( IsNamed() || fForceNamedBuild )
            InvalidateCollection ( CMarkup::NAVDOCUMENT_COLLECTION );
        break;

    case ETAG_SCRIPT:
        InvalidateCollection ( CMarkup::SCRIPTS_COLLECTION );
        break;

    case ETAG_MAP:
        InvalidateCollection ( CMarkup::MAPS_COLLECTION );
        break;

    case ETAG_AREA:
        InvalidateCollection ( CMarkup::LINKS_COLLECTION );
        break;

    case ETAG_EMBED:
        InvalidateCollection ( CMarkup::EMBEDS_COLLECTION );
        if ( IsNamed() || fForceNamedBuild )
            InvalidateCollection ( CMarkup::NAVDOCUMENT_COLLECTION );
        break;

    case ETAG_FORM:
        InvalidateCollection ( CMarkup::FORMS_COLLECTION );
        if ( IsNamed() || fForceNamedBuild )
            InvalidateCollection ( CMarkup::NAVDOCUMENT_COLLECTION );
        break;

    case ETAG_A:
        InvalidateCollection ( CMarkup::LINKS_COLLECTION );
        if (IsNamed() || fForceNamedBuild)
            InvalidateCollection ( CMarkup::ANCHORS_COLLECTION );
        break;
    }
}

void
CElement::DoElementNameChangeCollections(void)
{
    CMarkup *pMarkup;
    // Inval all the base collections, based on TAGNAme.
    // Force the WINDOW_COLLECTION to be built
    OnEnterExitInvalidateCollections ( TRUE );

    // Artificialy update the _lTreeVersion so any named collection derived from 
    // the ELEMENT_COLLECTION are inval'ed

    // This function is also called by the tree code when the page contains a 
    // <FORM> tag.  If we update the tree version here, CHtmRootParseCtx::FlushNotifications
    // will assume some thing is wrong and attempt to reload the page.
    // Assume the parser will update the version its self when needed.
        
    pMarkup = GetMarkup();
    if (pMarkup && !pMarkup->GetRootParseCtx())  // Parsing if GetRootParseCtx returns something.
        pMarkup->UpdateMarkupTreeVersion();    
}

HRESULT
InlineEvts::Connect(CDoc *pDoc, CElement *pElement)
{
    HRESULT     hr = S_OK;

    Assert(pDoc && pElement);

    //
    // Look over all scriptlets and hook them up
    //
    if (cScriptlets)
    {
        CMarkup *pMarkup = pElement->GetMarkup();
        if (pMarkup->GetScriptCollection())
        {
            BOOL        fRunScript;
            LPCTSTR     pchLanguage = NULL;
            hr = THR(pMarkup->ProcessURLAction(URLACTION_SCRIPT_RUN, &fRunScript));
            if (hr || !fRunScript)
                goto Cleanup;

            for (int i = 0; i < cScriptlets; i++)
            {
                IGNORE_HR(pElement->ConnectInlineEventHandler(
                    adispidScriptlets[i],   // dispid
                    adispidScriptlets[i],   // dispidCode - in this case it is the same
                    aOffsetScriptlets[i],
                    aLineScriptlets[i],
                    TRUE,                   // fStandard
                    &pchLanguage));
            }
        }
    }

Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Member:     IsConnectedToPrimaryWindow
//
//  Synopsis:   Chescks if the element is in amrkup connected (possibly through
//              pending markups) to the primary window. 
//
//-----------------------------------------------------------------------------
// TODO (jbeda) Handle HTCs?
BOOL
CElement::IsConnectedToPrimaryWindow()
{
    CMarkup * pMarkup           = GetMarkup();
    CMarkup * pMarkupPrimary    = Doc()->PrimaryMarkup();

    while (pMarkup)
    {
        if (pMarkup == pMarkupPrimary)
            return TRUE;

        if (pMarkup->Root()->HasMasterPtr())
        {
            pMarkup = pMarkup->Root()->GetMasterPtr()->GetMarkup();
        }
        else if (pMarkup->_fWindowPending)
        {
            Assert(!pMarkup->_fWindow);
            Assert(pMarkup != pMarkup->GetWindowPending()->Window()->Markup());
            pMarkup = pMarkup->GetWindowPending()->Window()->Markup();
        }
        else
            pMarkup = NULL;
    }
    return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Member:     SetViewSlave
//
//  Synopsis:   Sets up the slave/master ptrs, invalidates the layout, etc.
//
//-----------------------------------------------------------------------------

HRESULT
CElement::SetViewSlave(CElement * pSlaveNew)
{
    HRESULT     hr          = S_OK;
    CElement*   pSlaveOld   = NULL;

    if (HasSlavePtr())
    {
        pSlaveOld = GetSlavePtr();
    }

    if (pSlaveOld == pSlaveNew)
        goto Cleanup;

    // A slave usually implies a flow layout, so we need to destroy the old layout if it is inappropriate.
    // TODO (greglett)
    // The slave may imply a CContainerLayout, in which case we want to destroy the old CContainerLayout
    // if it is not already the head of a chain.  Since this is optimization rather than critical logic,
    // we can revisit.
    if (HasLayoutPtr())
    {
        CLayout * pLayoutOld = GetLayoutPtr();

        BOOL fFlowLayout = !!pLayoutOld->IsFlowLayout();

        if (    !fFlowLayout
            || (    pSlaveOld
                &&  !pSlaveNew) )
        {
           Verify(pLayoutOld == DelLayoutPtr());
           pLayoutOld->Detach();
           pLayoutOld->Release();
        }
    }
    else if ( HasLayoutAry() )
    {
        BOOL fFlowLayout = GetLayoutAry()->IsFlowLayout();
        
        if (    !fFlowLayout
            || (    pSlaveOld
                &&  !pSlaveNew) )
        {
            DelLayoutAry(); // will take care of detaching/releasing its layouts
        }
    }


    // Detach old slave
    if (pSlaveOld)
    {
        if (Tag() != ETAG_INPUT && IsConnectedToPrimaryWindow())
        {
            CMarkup *       pMarkupOld = pSlaveOld->GetMarkup();
            CNotification   nf;

            Assert(pSlaveOld->Tag() == ETAG_ROOT);
            Assert(pMarkupOld);

            // TODO (MohanB) Hack for windowed slave markups not in frames (#106433)
            // These markups do not passivate due to a ref count loop. Should fix in v6.
            if (Tag() == ETAG_GENERIC && pMarkupOld->HasWindow())
            {
                pMarkupOld->TearDownMarkup(TRUE, TRUE);
            }

            // Send ExitView notify to the slave tree since it is
            // getting diconnected from the primary markup.
            // For perf reasons we do that only if there is more than 
            // one reference to the master

            if (pMarkupOld->GetObjectRefs() > 1)
            {
                pMarkupOld->_fSlaveInExitView = 1;
                nf.ElementExitview1(pSlaveOld);
                pSlaveOld->SendNotification(&nf);
                pMarkupOld->_fSlaveInExitView = 0;
            }
        }

        DelSlavePtr();
        pSlaveOld->DelMasterPtr();
        pSlaveOld->Release();
    }
    else
    {
        CNotification   nf;

        // no previous slave, but we still need to send exitview 
        // notifications to all the children of the generic element
        nf.ElementExitview1(this);
        SendNotification(&nf);
    }

    // validate & attach new slave
    if (pSlaveNew)
    {
        // Make sure that the slave and the master are in the same CDoc
        Assert(Doc() == pSlaveNew->Doc());

        // TODO (MohanB)
        // Move all this validation /cycle-detection code into another function
        // and call it lazily in EnsureView()
#if 0

        if (!IsInMarkup())
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        if (!pSlaveNew->IsInMarkup())
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        // check for potential cycles

        // 1. check that the slave is not on master's parent/master chain
        {
            CElement * pMaster = this;

            do
            {
                if (pSlaveNew == pMaster)
                {
                    hr = E_INVALIDARG;
                    goto Cleanup;
                }
                if (pMaster->HasMasterPtr())
                {
                    pMaster = pMaster->GetMasterPtr();
                }
                else
                {
                    // TODO (MohanB) What about overlapping?
                    CTreeNode * pNode = pMaster->GetFirstBranch();

                    if (pNode)
                    {
                        pNode = pNode->Parent();
                    }
                    pMaster = pNode ? pNode->Element() : NULL;
                }
            }
            while (pMaster);
        }

        // 2. check that the slave is not already in someone else's layout
        {
            CTreeNode * pNodeTest = pSlaveNew->GetFirstBranch();

            Assert(pNodeTest);

            pNodeTest = pNodeTest->Parent();
            while (pNodeTest)
            {
                if (pNodeTest->Element()->HasMasterPtr())
                {
                    hr = E_INVALIDARG;
                    goto Cleanup;
                }
                if (pNodeTest->Element()->HasSlavePtr())
                {
                    // The parent has a slave, which implies that this
                    // element's content isn't being rendered in that.
                    break;
                }
                else if (pNodeTest->Element()->ShouldHaveLayout())
                {
                    hr = E_INVALIDARG;
                    goto Cleanup;
                }
                pNodeTest = pNodeTest->Parent();

            }
        }
#endif // End of validation code       
               
        // we're not actually exiting the tree, just trying to get the 
        // editor to reposition the caret in a valid position    

        // TODO For some reason, this repositioning crashes the VID test, 
        // perhaps due to the input tag's use of viewlinking. So for now
        // we only reposition on generic tags. (peterlee)        
        if (Tag() == ETAG_GENERIC)
        {
            IUnknown* pUnknown = NULL;
            IGNORE_HR( this->QueryInterface( IID_IUnknown, ( void**) & pUnknown ));
            IGNORE_HR( Doc()->NotifySelection( EDITOR_NOTIFY_SETTING_VIEW_LINK , pUnknown ));
            ReleaseInterface( pUnknown );      
        }
        
        // attach
        SetSlavePtr(pSlaveNew);
        pSlaveNew->SetMasterPtr(this);
        pSlaveNew->AddRef();

        Doc()->_fHasViewSlave = TRUE;
    }

    // clear formats and force a lazy remeasure
    {
        DWORD dwFlags = ELEMCHNG_CLEARCACHES;
        
        if (Tag() != ETAG_INPUT && IsConnectedToPrimaryWindow())
        {
            dwFlags |= ELEMCHNG_SETTINGVIEWLINK;
        }

        EnsureFormatCacheChange(dwFlags);
    }

    //ResizeElement();
    RemeasureElement(NFLAGS_FORCE);

    if( pSlaveNew )
    {
        hr = THR(pSlaveNew->GetMarkup()->LoadSlaveMarkupHistory());
        pSlaveNew->GetMarkup()->_fLoadHistoryReady = TRUE;
    }

Cleanup:
    RRETURN(hr);
}

BOOL
CElement::IsCircularViewLink(CMarkup * pMarkupSlave)
{
    CMarkup * pMarkupPrimary    = Doc()->PrimaryMarkup();
    CMarkup * pMarkupThis       = GetMarkup();

    Assert(pMarkupSlave);

    // Primary markup can never have a master
    Assert(pMarkupPrimary && !pMarkupPrimary->Root()->HasMasterPtr());

    while (pMarkupThis)
    {
        if (pMarkupThis == pMarkupSlave)
        {
            return TRUE;
        }
        if (pMarkupThis == pMarkupPrimary)
            break;
        pMarkupThis = pMarkupThis->Root()->HasMasterPtr()
                        ? pMarkupThis->Root()->GetMasterPtr()->GetMarkup()
                        : NULL;
    }
    return FALSE;
}


// KTam: If fTreatPrintingAsViewLink is true, elements inside a layoutrect will
// return true.
BOOL
CElement::IsInViewLinkBehavior( BOOL fTreatPrintingAsViewLink )
{
    AssertSz(IsInMarkup(), "Must be in a markup to answer this question");
    CElement * pRoot = GetMarkup()->Root();
    if (pRoot->HasMasterPtr())
    {
        CElement *pMaster = pRoot->GetMasterPtr();
        if ( pMaster->TagType() == ETAG_GENERIC )
        {
            if (   fTreatPrintingAsViewLink
                || !pMaster->IsLinkedContentElement() )
            {
                return TRUE;
            }
        }
    }
    return FALSE;
}

BOOL
CElement::IsPrintMedia()
{
    return IsInMarkup() ? GetMarkup()->IsPrintMedia() : FALSE;
}

HTHEME
CElement::GetTheme(THEMECLASSID themeId)
{
    if (GetFirstBranch()->GetFancyFormat()->IsThemeDisabled())
    {
        return NULL;
    }
    else
    {
        CMarkup * pMarkup = GetMarkup();
        if (pMarkup)
        {
            return pMarkup->GetTheme(themeId);
        }
        else
        {
            return NULL;
        }
    }
}

#ifdef NEVER

BOOL
CElement::CanHaveViewSlave()
{
    // You cannot set a viewSlave for non-renderable tags (e.g. SCRIPT). I am doing
    // this just to play safe.
    // Also, you cannot set viewSlave for certain renderable elements (e.g. TABLE),
    // because they make specific assumptions about their layout/content. To support
    // arbitrary view on any element, we need to fix this.

    switch (Tag())
    {
        // Non-renderable tags (picked from GetDefaultFocussability with FOCUSSABILITY_NEVER)
    case ETAG_AREA:
    case ETAG_BASE:
    case ETAG_BASEFONT:
    case ETAG_BGSOUND:
    case ETAG_BR:
    case ETAG_CODE:
    case ETAG_COL:
    case ETAG_COLGROUP:
    case ETAG_COMMENT:
    case ETAG_HEAD:
    case ETAG_HTML:
    case ETAG_LINK:
    case ETAG_MAP:
    case ETAG_META:
    case ETAG_NEXTID:
    case ETAG_NOBR:
    case ETAG_NOEMBED:
    case ETAG_NOFRAMES:
    case ETAG_NOSCRIPT:
    case ETAG_OPTION:
    case ETAG_PARAM:
    case ETAG_RAW_BEGINFRAG:
    case ETAG_RAW_BEGINSEL:
    case ETAG_RAW_CODEPAGE:
    case ETAG_RAW_COMMENT:
    case ETAG_RAW_DOCSIZE:
    case ETAG_RAW_ENDFRAG:
    case ETAG_RAW_ENDSEL:
    case ETAG_RAW_EOF:
    case ETAG_RAW_SOURCE:
    case ETAG_RAW_TEXT:
    case ETAG_RAW_TEXTFRAG:
    case ETAG_SCRIPT:
    case ETAG_STYLE:
    case ETAG_TITLE_ELEMENT:
    case ETAG_TITLE_TAG:
    case ETAG_WBR:
    case ETAG_UNKNOWN:
        return FALSE;

        // Tags which make specific assumptions about their layout
    case ETAG_APPLET:
    case ETAG_EMBED:
    case ETAG_FRAMESET:
    case ETAG_HR:
    case ETAG_OBJECT:
    case ETAG_SELECT:
    case ETAG_TABLE:
    case ETAG_TR:
        return FALSE;

        // Certain types of INPUTs which make specific assumptions about their slave
    case ETAG_INPUT:
        switch (DYNCAST(CInput, this)->GetType())
        {
        case htmlInputButton:
        case htmlInputReset:
        case htmlInputSubmit:
        case htmlInputFile:
        case htmlInputText:
        case htmlInputPassword:
        case htmlInputHidden:
            return FALSE;
        }
        break;
    }
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// viewLink OM
//
#define DISPID_INTERNAL_PUBLIC_VIEWLINK   (DISPID_ELEMENT+??) // from element.pdl

//+----------------------------------------------------------------------------
//
//  Member:     PutViewLinkHelper
//
//  Synopsis:   Sets the slave element.
//
//-----------------------------------------------------------------------------

HRESULT
CElement::PutViewLinkHelper(IHTMLElement * pISlave)
{
    HRESULT     hr          = S_OK;
    CElement*   pElemSlave  = NULL;

    if (!CanHaveViewSlave())
    {
        hr = E_NOTIMPL;
        goto Cleanup;
    }

    if (pISlave)
    {
        hr = THR(pISlave->QueryInterface(CLSID_CElement, (void**) &pElemSlave));
        if (hr)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        Assert(pElemSlave);
    }

    hr = THR(SetViewSlave(pElemSlave));

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     put_viewLink
//
//  Synopsis:   IHTMLElement3 method. Sets the slave element.
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CElement::put_viewLink(IHTMLElement * pISlave)
{
    HRESULT hr;
    AAINDEX aaIdx   = FindAAIndex(DISPID_INTERNAL_PUBLIC_VIEWLINK, CAttrValue::AA_Internal);

    if (aaIdx == AA_IDX_UNKNOWN)
    {
        hr = AddUnknownObject(DISPID_INTERNAL_PUBLIC_VIEWLINK, pISlave, CAttrValue::AA_Internal);
    }
    else
    {
        hr = ChangeUnknownObjectAt(aaIdx, pISlave);
    }
    if (hr)
        goto Cleanup;

    hr = PutViewLinkHelper(pISlave);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
//  Member:     get_viewLink
//
//  Synopsis:   IHTMLElement3 method. Returns the slave element.
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CElement::get_viewLink(IHTMLElement ** ppISlave)
{
    if (!ppISlave)
        return E_INVALIDARG;
#ifdef MULTI_LAYOUT
    if (HasSlavePtr()) {
        CElement * pSlave = GetSlavePtr();
        return pSlave->QueryInterface(IID_IHTMLElement, (void**)ppISlave);
    }
    else
    {
        CViewChain * pChain = GetUpdatedLayout()->ViewChain();
        if (pChain)
        {
            CElement * pSlave = GetUpdatedLayout()->ViewChain()->GetLayoutOwner()->ElementOwner()->GetSlavePtr();
            return pSlave->QueryInterface(IID_IHTMLElement, (void**)ppISlave);
        }
    }
#endif

    RRETURN(SetErrorInfo(GetUnknownObjectAt(
                            FindAAIndex(DISPID_INTERNAL_PUBLIC_VIEWLINK, CAttrValue::AA_Internal),
                            (IUnknown**)ppISlave)));
}
#endif // NEVER

BOOL
CElement::ShouldHaveLayout(CTreeNode *pBranchNode FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    if (Tag() == ETAG_OBJECT && IsInMarkup())
    {
        if (!GetMarkup() || GetMarkup()->SearchBranchForTagInStory(GetFirstBranch(), ETAG_HEAD))
            return FALSE;
    }

    //hack. (dmitryt) We calculate layoutness bit for HTML element when we calc its formats.
    //Unfortunately, to see if HTML has layout, we not only check 'Strict CSS' bit
    //on Markup but also _fDesignMode and IsPrintPreview (see IsHtmlLayout() implementation).
    //But because _fDesignMode on markup is playing funny games when markup gets loaded,
    //we can calculate and cache wrong FancyFormat bit for HTML layout.
    //To 'fix' this temporarily, I'm putting this hack for HTML element in hope 
    //it will help. The right solution would be to only check for CSS1 bit. Unfortunately,
    //it's too late in IE6 cycle.

    if(Tag() == ETAG_HTML)
        return (GetMarkup() && GetMarkup()->IsHtmlLayout());

    if (_fLayoutAlwaysValid)
        return (!TestClassFlag(ELEMENTDESC_NOLAYOUT));

    CTreeNode * pNode = ( pBranchNode ? pBranchNode : GetFirstBranch() );

    // If formats have been computed, then we know whether we should have layout (and that knowledge
    // is cached on the tree node).  Else we need to compute formats to figure it out.
    // COMPUTEFORMATS NO LONGER CREATES LAYOUTS, it only updates the _fShouldHaveLayout bits.
    
    // If we don't have a node, it means we're not in the tree.  In that case, we can't answer the
    // question "should this element have layout", so we'd like to make sure no one asks it.
    // Currently CElement::FireEvent calls GetUpdatedNearestLayout(), which causes us to come in here
    // with a null branch; this happens in the DRT's xtags tests.  Talk to them to figure out the
    // right fix, then enable this assert.
    // Assert( pNode );
    
    if ( pNode )
    {

#ifdef MULTI_FORMAT
        if ( IS_FC(FCPARAM) )
        {
            return pNode->GetFancyFormat(FCPARAM)->_fShouldHaveLayout;
        }
        else
#endif //MULTI_FORMAT
        {        
            return (pNode->_iFF != -1)
                    ? pNode->_fShouldHaveLayout
                    : pNode->GetFancyFormat()->_fShouldHaveLayout;                   
        }
    }

    return FALSE;
}

CBase *
CElement::GetBaseObjectFor(DISPID dispID, CMarkup * pMarkup /* = NULL */)
{
    return this;
}

CControlledFormatter::CControlledFormatter(CElement *pElement, DISPID dispid, DWORD dwFlags)
{
    _pElement = pElement;
    _pNode = _pElement->GetFirstBranch();
    _dispid = dispid;
    _dwFlags = dwFlags;
    WHEN_DBG(_fInited = FALSE;)
}

CControlledFormatter::~CControlledFormatter()
{
    AssertSz(   _fShouldComputeFormatsForDISPID
             || _pElement->AreAllMyFormatsAreDirty(_dwFlags),
             "Compute formats was called erroneously! Perf problem!"
            );
}

BOOL
CControlledFormatter::Init(HRESULT *phr)
{
    BOOL fRet = FALSE;

    AssertSz(!_fInited, "Do not init me twice!");
    _fHadLayoutBeforeFormatsChange = _pElement->CurrentlyHasAnyLayout();
    _fShouldComputeFormatsForDISPID = ShouldComputeFormatsForDISPID();
    if (_fShouldComputeFormatsForDISPID)
    {
        *phr = THR(_pElement->EnsureFormatCacheChange(_dwFlags));
        if (*phr != S_OK)
            goto Cleanup;

       //
       // In the case of an activex control, we may be in the process of computing formats  Sujalp owns
       // adding a better assert.
       //
       // AssertSz(_pElement->AreAllMyFormatsAreDirty(_dwFlags), "Ensure format cache change failed!");
        
        _fHasLayoutAfterFormatsChange = _pElement->ShouldHaveLayout();
        _pNearestLayoutInfo = _pElement->GetUpdatedNearestLayoutInfo();
        _pNearestLayout = _pElement->GetUpdatedNearestLayout(GUL_USEFIRSTLAYOUT);
        if (   !_pNearestLayoutInfo
            || !_pNearestLayoutInfo->ElementOwner()->IsInMarkup()
            || !_pNearestLayout
            || !_pNearestLayout->ElementOwner()->IsInMarkup()
           )
        {
            goto Cleanup;
        }
        SendZNotification();
    }
    else
    {
        SendZNotification();
        *phr = THR(_pElement->EnsureFormatCacheChange(_dwFlags));
        if (*phr != S_OK)
            goto Cleanup;
    }
    fRet = TRUE;
    
Cleanup:
    WHEN_DBG(_fInited = TRUE;)
    return fRet;
}

BOOL
CControlledFormatter::SendZNotification()
{
    // Invalidation on z-index changes will be handled by FixZOrder in CSite
    // unless the change is on a non-site
    if (    _pElement->Doc()->_state >= OS_INPLACE
        &&  !(_dispid == DISPID_A_ZINDEX && _pElement->CurrentlyHasAnyLayout()))
    {
        if (    (_dwFlags & (ELEMCHNG_SITEREDRAW | ELEMCHNG_CLEARCACHES | ELEMCHNG_CLEARFF))
             && !(_dwFlags & ELEMCHNG_SITEPOSITION && _pElement->CurrentlyHasAnyLayout()))
        {
            // NOTE: CLayout will get called *twice* on _pElement because of this code.
            // Once for the first invalidate and once for the INVAL_Z_DESCENDANTS
            // call.

            _pElement->Invalidate();

            // Invalidate() sends a notification ot the parent, however in OPC
            // descendant elemetns may inherit what has just changed, so we need
            // a notification that goes down to the positioned children
            // so that they know to invalidate.  This is necessary since
            // when a property is changed they may have a change in an 
            // inherited value that they need to display
            //
            //  if we wind up needing this notification fired from other 
            // places, consider moving it into InvalidateElement()
            _pElement->SendNotification(NTYPE_ELEMENT_INVAL_Z_DESCENDANTS);
        }
    }
    return TRUE;
}

BOOL
CControlledFormatter::ShouldComputeFormatsForDISPID()
{
    return TRUE;
}

#ifdef NOT_NOW
BOOL
CControlledFormatter::ShouldComputeFormatsForDISPID()
{
    BOOL fRet;
    
#define D(Y)  case DISPID_A_##Y:
#define DE(Y) case DISPID_##Y:
#define S(Y)  case STDPROPID_XOBJ_##Y:
    switch(_dispid)
    {
    // These dispids could potentially change the layoutness of an element, in which case we are interested
    D(RECTANGULAR) S(WIDTH) S(HEIGHT) D(POSITION)
    D(FLOAT) D(ZOOM) D(ROTATE) D(LAYOUTFLOW) D(WRITINGMODE)
    DE(CElement_id) D(EDITABLE) D(STYLETEXT)
    
    // These dispids need to look at formats to do their OPC work
    S(LEFT) S(RIGHT) S(TOP) S(BOTTOM)
    D(ZINDEX) D(VISIBILITY) D(DISPLAY) D(CLIP) D(CLIPRECTTOP)
    D(CLIPRECTRIGHT) D(CLIPRECTBOTTOM) D(CLIPRECTLEFT)

    // These dispids need to look at the new layout to do their OPC work
    D(OVERFLOWY) DE(CElement_className) D(BACKGROUNDIMAGE)
    DE(UNKNOWN) DE(BACKCOLOR)
#undef D
#undef DE
#undef S
    {
        fRet = TRUE;
        break;
    }
    default:
    {
        fRet = FALSE;
        break;
    }
    }

    if (   !fRet
        && (_dwFlags & (ELEMCHNG_RESIZENONSITESONLY | ELEMCHNG_SITEPOSITION))
       )
    {
        fRet = TRUE;
    }
    return fRet;
}
#endif

#if DBG==1
BOOL
CElement::AreAllMyFormatsAreDirty(DWORD dwFlags)
{
    BOOL fAll = dwFlags & ELEMCHNG_CLEARCACHES;
    BOOL fFFOnly = dwFlags & ELEMCHNG_CLEARFF;
    
    CTreeNode *pNode = GetFirstBranch();

    while(pNode)
    {
        if (fAll && pNode->_iCF != -1)
            return FALSE;
        if (fFFOnly && pNode->_iFF != -1)
            return FALSE;
        pNode = pNode->NextBranch();
    }
    return TRUE;
}
#endif
