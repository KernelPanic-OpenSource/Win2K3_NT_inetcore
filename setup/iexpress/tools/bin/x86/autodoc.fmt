[extension]

; Filename extension types
; .ext=<extension_text>, c|asm|bas

.ext=c,c
.ext=cpp,c
.ext=cxx,c
.ext=inl,c
.ext=d,c
.ext=h,c
.ext=hpp,c
.ext=hxx,c
.ext=asm,asm
.ext=bas,bas   
.ext=mst,bas    
.ext=frm,bas
.ext=inc,bas

[constant]

; String constants
; .output=doc|help|both
; .define=<constant_name>, <constant_text>

.output=both
.define=reset,\pard\plain 
.define=title,Help
.define=doc_header,Autodoc Output
;
; Help constants
;
.output=help
.define=header,\s243\li-1800\sl210\tqr\tx6960 \b\f2\fs19\lang1033 
.define=heading_4,\s251\sb60\sa40\sl280 \b\f2\lang1033 
.define=heading_3,\s252\li240\sb80\sa40\sl340 \b\f2\lang1033 
.define=heading_2,\s253\li240\sb140\sa60\sl380 \b\f0\fs28\lang1033 
.define=heading_1,\s254\li240\sb200\sa80\sl440 \b\f0\fs36\lang1033 
.define=normal,\li240\sa160\sl240 \f2\fs20\lang1033 
.define=table_text,\f2\fs20\lang1033 
.define=ex,\s28\li240\sl220\tx732\tx1224\tx1716\tx2208\tx2700\tx3192\tx3684\tx4176\tx4668\tx5160\tx5652\tx6144\tx6636\tx7128\tx7620 \f17\fs20\lang1033 
.define=header_rule,\s44\li-1770\ri30\sb50\sl-80\brdrt\brdrs\brdrw15\brdrcf2 \fs12\lang1033 
.define=rh1,\s45\li240\sl440\keep\keepn \b\f2\fs34\lang1033 
.define=rmh,\s46\li240\sb20\sl220 \b\f2\fs21\lang1033 
.define=term1,\s50\li240\sl240 \f2\fs20\lang1033 
.define=term2,\s53\li480\sl240 \f2\fs20\lang1033 
.define=term3,\s53\li720\sl240 \f2\fs20\lang1033 
.define=def1,\s54\li480\sa80\sl240 \f2\fs20\lang1033 
.define=def2,\s55\li720\sa80\sl240 \f2\fs20\lang1033 
.define=def3,\s55\li960\sa80\sl240 \f2\fs20\lang1033 
.define=def4,\fi-2880\li2880\sa160 \tx2880\tx6930 \fs21\lang1033
.define=rule,\s57\li-1770\ri30\sb280\sa160\sl120\brdrb\brdrs\brdrw15 \fs8\cf8\lang1033 
.define=indexlink,\s93\li240\sl240 \f2\fs20\lang1033 
;
; Doc constants
;
.output=doc
.define=header,\s243\li-1800\sl-210\tqr\tx6960 \b\f2\fs19\lang1033 
.define=heading_4,\s251\sb60\sa40\sl-280\keepn \b\f2\lang1033 
.define=heading_3,\s252\sb80\sa40\sl-340\keepn \b\f2\fs30\lang1033 
.define=heading_2,\s253\li-1800\sb140\sa60\sl-380\keepn \b\f0\fs34\lang1033 
.define=heading_1,\s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 
.define=normal,\sa160\sl240 \fs21\lang1033 
.define=ex,\s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 
.define=header_rule,\s44\li-1770\ri30\sb50\sl-80\brdrt\brdrs\brdrw15\brdrcf2 \fs12\lang1033 
.define=rh1,\s45\li-1800\sa180\sl-440\keepn\tx0 \b\f2\fs40\up8\lang1033 
.define=rmh,\s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 
.define=term1,\s50\sl-240\keepn \f0\fs21\lang1033 
.define=term2,\s53\li280\sl-240\keepn \f0\fs21\lang1033 
.define=def1,\s54\li280\sa80\sl-240 \f0\fs21\lang1033 
.define=def2,\s55\li560\sa80\sl-240 \f0\fs21\lang1033 
.define=rule,\s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 
.define=rmh,\s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 
.define=Table_Text,\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 
;
[file]
; ********************************************
; Help file headers
; ********************************************
.output=help
.pre={\rtf1\ansi \deff0\deflang1033

{\fonttbl
{\f0\froman Times New Roman;}
{\f1\froman Symbol;}
{\f2\fswiss Arial;}
{\f3\froman Times Roman;}
{\f4\fnil Univers;}
{\f5\fnil Univers Medium Condensed;}
{\f6\fnil Univers Condensed;}
{\f7\fswiss LetterGothic;}
{\f8\fdecor ZapfDingbats;}
{\f9\fnil Lucida Stars;}
{\f10\fswiss Helvetica-Narrow;}
{\f11\fswiss CB Univers 67 CondensedBold;}
{\f12\froman Times;}
{\f13\fmodern Letter Gothic MS;}
{\f14\fswiss C Univers 57 Condensed;}
{\f15\fnil MSIcons;}
{\f16\fswiss Arial Narrow;}
{\f17\fmodern Courier;}
{\f18\fnil Wingdings;}
}

{\colortbl;
\red0\green0\blue0;
\red0\green0\blue255;
\red0\green255\blue255;
\red0\green255\blue0;
\red255\green0\blue255;
\red255\green0\blue0;
\red255\green255\blue0;
\red255\green255\blue255;
\red0\green0\blue127;
\red0\green127\blue127;
\red0\green127\blue0;
\red127\green0\blue127;
\red127\green0\blue0;
\red127\green127\blue0;
\red127\green127\blue127;
\red192\green192\blue192;
}

{\stylesheet
{$(header)header;}
{$(heading_4)heading 4;}
{$(heading_3)heading 3;}
{$(heading_2)heading 2;}
{$(heading_1)heading 1;}
{$(normal)Normal;}
{$(ex)Ex;}
{$(header_rule)header rule;}
{$(rh1)Rh1;}
{$(rmh)Rmh;}
{$(term1)Term1;}
{$(term2)Term2;}
{$(def1)Def1;}
{$(def2)Def2;}
{$(rule)Rule;}
{$(indexlink)Index Link;}
{$(table_text)Table Text;}
}

$(reset)$(heading_1)
$${\footnote $$ Contents}
+{\footnote + contents:0000} 
$(title) Contents\par 

$(reset)$(normal)To display a list of topics by category, click any 
of the contents entries below. To display an alphabetical list of 
topics, choose the Index button.\par 

$(reset)$(heading_3)COM Elements\par 
$(reset)$(indexlink){\uldb Objects and Interfaces}{\v ctx_comobj}\par 
$(reset)$(indexlink){\uldb Object Methods}{\v ctx_commeth}\par 
$(reset)$(indexlink){\uldb Object Properties}{\v ctx_comprop}\par 
$(reset)\sl-240 \fs21\lang1033 \par 

$(reset)$(heading_3)C/C++ Elements\par 
$(reset)$(indexlink){\uldb Classes and Class Members}{\v ctx_classes}\par 
$(reset)$(indexlink){\uldb Functions}{\v ctx_functions}\par 
$(reset)$(indexlink){\uldb Messages}{\v ctx_messages}\par 
$(reset)$(indexlink){\uldb Structures and Enums}{\v ctx_types}\par 
$(reset)\sl-240 \fs21\lang1033 \par 

$(reset)$(heading_3)Other\par 
$(reset)$(indexlink){\uldb Overviews}{\v ctx_overviews}\par 
$(reset)$(indexlink){\uldb Modules}{\v ctx_modules}\par 
$(reset)$(indexlink){\uldb Constants}{\v ctx_constants}\par 
$(reset)\sl-240 \fs21\lang1033 \par 
$(reset)\sl-240 \fs21\lang1033 \par 
$(reset)$(normal)Help file built: $!d\par
$(reset)\sl-240 \fs21\lang1033 \par 
$(reset)$(normal)\fs16{\ul About Autodoc}{\v aboutautodoc}\par 
\par 

\page 

$(reset)$(heading_3)
#{\footnote \pard\plain \f2\fs20 # aboutautodoc}
$${\footnote \pard\plain \f2\fs20 $$ About Autodoc} About Autodoc
\par \trowd \trgaph108\trleft-108 
\cellx5580 \pard\plain \li144\ri144\sa160\sl240\slmult0\intbl \f2\fs20 
The sources for this Help file were generated by Autodoc, the source 
code documentation tool that generates Print or Help files from tagged 
comments in C, C++, Assembly, and Basic source files.\par 

For more information, contact Eric Artzt (erica@microsoft.com).\cell \row 

\page 

$(reset)$(heading_1)
#{\footnote # ctx_comobj}
$${\footnote $$ Contents: Objects and Interfaces}
+{\footnote + contents:0000} 
Objects and Interfaces\par 

$[index:object,interface]

\page 

$(reset)$(heading_1)
#{\footnote # ctx_commeth}
$${\footnote $$ Contents: Object Methods}
+{\footnote + contents:0000} 
Object Methods\par 

$[index:method]

\page 

$(reset)$(heading_1)
#{\footnote # ctx_comprop}
$${\footnote $$ Contents: Object Properties}
+{\footnote + contents:0000} 
Object Properties\par 

$[index:property]

\page 

$(reset)$(heading_1)
#{\footnote # ctx_comevent}
$${\footnote $$ Contents: Object Events}
+{\footnote + contents:0000} 
Object Events\par 

$[index:event]
\page 

$(reset)$(heading_1)
#{\footnote # ctx_Classes}
$${\footnote $$ Contents: Classes and Class Members}
+{\footnote + contents:0000} 
Classes and Class Members\par 

$[index:class,mfunc,mdata]

\page 

$(reset)$(heading_1)
#{\footnote # ctx_Functions}
$${\footnote $$ Contents: Functions}
+{\footnote + contents:0000} 
Functions\par 

$[index:func,cb]

\page 

$(reset)$(heading_1)
#{\footnote # ctx_Messages}
$${\footnote $$ Contents: Messages}
+{\footnote + contents:0000} 
Messages\par 

$[index:msg]

\par \page 

$(reset)$(heading_1)
#{\footnote # ctx_Types}
$${\footnote $$ Contents: Structures and Enums}
+{\footnote + contents:0000} 
Structures and Enums\par 

$[index:struct,enum]

\page 

$(reset)$(heading_1)
#{\footnote # ctx_overviews}
$${\footnote $$ Contents: Overviews}
+{\footnote + contents:0000} 
Overviews\par 

$[index:topic]

\page 

$(reset)$(heading_1)
#{\footnote # ctx_modules}
$${\footnote $$ Contents: Modules}
+{\footnote + contents:0000} 
Modules\par 

$[index:module]

\page 

$(reset)$(heading_1)
#{\footnote # ctx_constants}
$${\footnote $$ Contents: Constants}
+{\footnote + contents:0000} 
Constants\par 

$[index:const]

.post=}

; ********************************************
; Doc file headers
; ********************************************
.output=doc
.pre={\rtf1\ansi \deff0\deflang1033

{\fonttbl
{\f0\froman Times New Roman;}
{\f2\fswiss Arial;}
{\f19\fmodern\fcharset0\fprq1 Courier New;}
}

{\colortbl;
\red0\green0\blue0;
\red0\green0\blue255;
\red0\green255\blue255;
\red0\green255\blue0;
\red255\green0\blue255;
\red255\green0\blue0;
\red255\green255\blue0;
\red255\green255\blue255;
\red0\green0\blue127;
\red0\green127\blue127;
\red0\green127\blue0;
\red127\green0\blue127;
\red127\green0\blue0;
\red127\green127\blue0;
\red127\green127\blue127;
\red192\green192\blue192;
}


{\stylesheet
{$(header)header;}
{$(heading_4)heading 4;}
{$(heading_3)heading 3;}
{$(heading_2)heading 2;}
{$(heading_1)heading 1;}
{\*\cs10 \additive Default Paragraph Font;}
{$(normal)Normal;}
{$(ex)Ex;}
{$(header_rule)header rule;}
{$(rh1)Rh1;}
{$(rmh)Rmh;}
{$(term1)Term1;}
{$(term2)Term2;}
{$(def1)Def1;}
{$(def2)Def2;}
{$(rule)Rule;}
{$(table_text)Table Text;}
}

\paperw12240\paperh15840\margl3330\margr1530\margt-2540\margb-2220\gutter420 
\facingp\deftab280\widowctrl\ftnbj 

\sectd \binfsxn1\binsxn1\linex0\headery1990\footery360\endnhere\titlepg 

{\headerl $(reset)$(header)
{\field\flddirty{\*\fldinst PAGE}{\fldrslt 4}}{\expnd50  }$(doc_header) - $!d\par 
$(reset)$(header_rule)\par }

{\headerr $(reset)$(header)
\tab $(doc_header) - $!d{\expnd50   }
{\field\flddirty{\*\fldinst PAGE}{\fldrslt 3}}
\par $(reset)$(header_rule)
\par }

.post=}

[topic]
;
; ***********************************************************
; C Language topics
; ***********************************************************

; Functions

.tag=func, doc, 3, 20, $2
.order=syntax rdesc parm parmvar comm ex
.parsesource=function
.pre=$(reset)$(rule)\par 
$(reset)$(heading_1)$2\par 
$[function]
$(reset)$(normal)$3\par 
$(reset)$(normal)Defined in: $!p\par 

.tag=func, help, 3, 20, $2
.order=syntax rdesc parm parmvar comm ex
.parsesource=function
.pre=\page 
$(reset)$(heading_1)
##{\footnote ## #2}
$${\footnote $$ $2}
K{\footnote K functions; $2}
+{\footnote + functions:0000} 
$2\par 
$[function]
$(reset)$(normal)$3\par 
$(reset)$(normal)Defined in: $!p\par 

; Functions

.tag=cb, doc, 3, 20, $2
.order=syntax rdesc parm parmvar comm ex
.parsesource=function
.pre=$(reset)$(rule)\par 
$(reset)$(heading_1)$2\par 
$[function]
$(reset)$(normal)$3\par 
$(reset)$(normal)Defined in: $!p\par 

.tag=cb, help, 3, 20, $2
.order=syntax rdesc parm parmvar comm ex
.parsesource=function
.pre=\page 
$(reset)$(heading_1)
##{\footnote ## #2}
$${\footnote $$ $2}
K{\footnote K callback functions; functions; $2 callback function}
+{\footnote + functions:0000} 
$2\par 
$[function]
$(reset)$(normal)$3\par 
$(reset)$(normal)Defined in: $!p\par 

; Messages

.tag=msg, doc, 2, 30, $1
.order=rdesc parm comm ex
.pre=$(reset)$(rule)\par 
$(reset)$(heading_1)$1\par 
$(reset)$(normal)$2\par 
$(reset)$(normal)Defined in: $!p\par 

.tag=msg, help, 2, 30, $1
.order=rdesc parm comm ex
.pre=\page $(reset)$(heading_1)
##{\footnote ## #1}
$${\footnote $$ $1}
K{\footnote K messages; $1}
+{\footnote + messages:0000} 
$1\par 
$(reset)$(normal)$2\par 
$(reset)$(normal)Defined in: $!p\par 

; Constants

.tag=const, doc, 3, 30, $2
.parsesource=constant
.pre=$(reset)$(rule)\par 
$(reset)$(heading_1)$2 constant\par 
$(reset)$(normal){\b const $1 $2;}\par 
$(reset)$(normal)Defined in: $!p\par 
$(reset)$(normal)$3\par 

.tag=const, help, 3, 30, $2
.parsesource=constant
.pre=\page $(reset)$(heading_1)
##{\footnote ## #2}
$${\footnote $$ $2}
K{\footnote K constants; $2 constant}
+{\footnote + constants:0000} 
$2 constant\par 
$(reset)$(normal){\b const $1 $2;}\par 
$(reset)$(normal)Defined in: $!p\par 
$(reset)$(normal)$3\par 

; Data types (typedefs, etc.)

.tag=type, doc, 2, 50, $1
.order=field comm ex
.pre=$(reset)$(rule)\par 
$(reset)$(heading_1)$1\par 
$(reset)$(normal)$2\par 
$(reset)$(normal)Defined in: $!p\par 

.tag=type, help, 2, 50, $1
.order=field comm ex
.pre=\page 
$(reset)$(heading_1)
##{\footnote ## #1}
$${\footnote $$ $1}
K{\footnote K types; typedefs; $1}
+{\footnote + struct:0000} 
$1\par 
$(reset)$(normal)$2\par 
$(reset)$(normal)Defined in: $!p\par 

; Structures

.tag=struct, doc, 2, 50, $1
.order=field comm ex
.pre=$(reset)$(rule)\par 
$(reset)$(heading_1)$1 Structure\par 
$[structure]
$(reset)$(normal)$2\par 
$(reset)$(normal)Defined in: $!p\par 

.tag=struct, help, 2, 50, $1
.order=field comm ex
.pre=\page 
$(reset)$(heading_1)
##{\footnote ## #1}
$${\footnote $$ $1}
K{\footnote K types; structures; $1}
+{\footnote + struct:0000} 
$1 Structure\par 
$[structure]
$(reset)$(normal)$2\par 
$(reset)$(normal)Defined in: $!p\par 

; Modules

.tag=module, doc, 2, 10, $1
.pre=$(reset)$(rule)\par 
$(reset)$(heading_1)Module $1\par 
$(reset)$(normal)Filename: $!p\par 
$(reset)$(rmh)Description\par 
$(reset)$(normal)$2\par 

.tag=module, help, 2, 10, $1
.pre=\page 
$(reset)$(heading_1)
##{\footnote ## #1}
$${\footnote $$ $1}
K{\footnote K modules; $1}
+{\footnote + overviews:0000} 
Module $1\par 
$(reset)$(normal)Filename: $!p\par 
$(reset)$(rmh)Description\par 
$(reset)$(normal)$2\par 

; Enumeration Types

.tag=enum, doc, 2, 50, $1
.parsesource=enum
.pre=$(reset)$(rule)\par 
$(reset)$(heading_1)$1\par 
$[enum]
$(reset)$(normal)$2\par
$(reset)$(normal)Defined in: $!p\par 

.tag=enum, help, 2, 50, $1
.parsesource=enum
.pre=\page $(reset)$(heading_1)
##{\footnote ## #1}
$${\footnote $$ $1}
K{\footnote K types; enumeration types; $1}
+{\footnote + types:0000} 
$(reset)$(heading_1)$1\par
$[enum]
$(reset)$(normal)$2\par
$(reset)$(normal)Defined in: $!p\par 
;
; ***********************************************************
; C++ Language topics
; ***********************************************************

; Classes

.tag=class, doc, 2, 20, $1
.parsesource=class
.pre=$(reset)$(rule)\par 
$(reset)$(heading_1)$1 Class\par 
$[class]
$(reset)$(normal)$2\par 
$(reset)$(normal)Defined in: $!p\par 

.tag=class, help, 2, 20, $1
.parsesource=class
.pre=\page
$(reset)$(heading_1)
##{\footnote ## #1}
$${\footnote $$ $1}
K{\footnote K classes; $1}
+{\footnote + classes:0000} 
$1 Class\par 
$[class]
$(reset)$(normal)$2\par 
$(reset)$(normal)Defined in: $!p\par 

; Member functions

.tag=mfunc, doc, 4, 20, $2::$3
.order=syntax rdesc parm comm ex
.parsesource=memberfunction
.pre=$(reset)$(rule)\par 
$(reset)$(heading_1)$2::$3\par 
$[mfunction]
$(reset)$(normal)$4\par 
$(reset)$(normal)Defined in: $!p\par 

.tag=mfunc, help, 4, 20, $2::$3
.order=syntax rdesc parm comm ex
.parsesource=memberfunction
.pre=\page 
$(reset)$(heading_1)
##{\footnote ## #2__#3}
$${\footnote $$ $2::$3}
K{\footnote K functions; member functions; class member functions; $2::$3}
+{\footnote + functions:0000} 
$2::$3\par 
$[mfunction]
$(reset)$(normal)$4\par 
$(reset)$(normal)Defined in: $!p\par 

; Member data

.tag=mdata, doc, 4, 20, $2::$3
.pre=$(reset)$(rule)\par 
$(reset)$(heading_1)$2::$3\par 
$[mdata]
$(reset)$(normal)$4\par 

.tag=mdata, help, 4, 20, $2::$3
.pre=\page 
$(reset)$(heading_1)
##{\footnote ## #2__#3}
$${\footnote $$ $2::$3}
K{\footnote K member data; class member data; $2::$3}
+{\footnote + functions:0000} 
$2::$3\par 
$[mdata]
$(reset)$(normal)$4\par 
;
; ***********************************************************
; OLE topics
; ***********************************************************

; Objects
; @object	Point2D | Represents a two-dimensional coordinate.

.tag=object, doc, 2, 20, $1
.pre=$(reset)$(rule)\par 
$(reset)$(heading_1)$1 Object\par
$(reset)$(rmh)Description\par 
$(reset)$(normal)$2\par 
$(reset)$(normal)Defined in: $!p\par 

.tag=object, help, 2, 20, $1
.pre=\page 
##{\footnote ## #1}
$${\footnote $$ $1 object}
K{\footnote K OLE objects; objects; $1 object}
+{\footnote + OLE:0000} 
$(reset)$(heading_1)$1 Object\par
$(reset)$(normal)$2\par 
$(reset)$(normal)Defined in: $!p\par 

; Abstract objects

.tag=abstract, doc, 2, 20, $1
.pre=$(reset)$(rule)\par 
$(reset)$(heading_1)$1 Abstract Object\par
$(reset)$(rmh)Description\par 
$(reset)$(normal)$2\par 

.tag=abstract, help, 2, 20, $1
.pre=\page 
##{\footnote ## #1}
$${\footnote $$ $1 abstract object}
K{\footnote K abstract objects; $1 abstract object}
+{\footnote + OLE:0000} 
$(reset)$(heading_1)$1 Abstract Object\par
$(reset)$(normal)$2\par 
$(reset)$(normal)Defined in: $!p\par 

; Interfaces

.tag=interface, doc, 2, 20, $1
.context=$1_int
.pre=$(reset)$(rule)\par 
$(reset)$(heading_1)$1 Interface\par
$(reset)$(normal)$2\par 
$(reset)$(normal)Defined in: $!p\par 

.tag=interface, help, 2, 20, $1
.context=$1_int
.pre=\page 
##{\footnote ## #1_int}
$${\footnote $$ $1 interface}
K{\footnote K OLE interfaces; interfaces; $1 interface}
+{\footnote + OLE:0000} 
$(reset)$(heading_1)$1 Interface\par
$(reset)$(normal)$2\par 
$(reset)$(normal)Defined in: $!p\par 

; Object methods

.tag=method, doc, 4, 20, $2::$3
.context=$2::$3_meth
.pre=$(reset)$(rule)\par 
$(reset)$(heading_1)$2::$3 Method\par 
$[method]
$(reset)$(normal)$4\par 
$(reset)$(normal)Defined in: $!p\par 

.tag=method, help, 4, 20, $2::$3
.context=$2::$3_meth
.order=parm rvalue comm ex
.pre=\page 
##{\footnote ## #2__#3_meth}
$${\footnote $$ $2::$3 Method}
K{\footnote K OLE interfaces; interface methods; methods; $3 method; $2 interface}
+{\footnote + OLE:0000} 
$(reset)$(heading_1)$2::$3 Method\par 
$[method]
$(reset)$(normal)$4\par 
$(reset)$(normal)Defined in: $!p\par 

; Object properties

.tag=property, doc, 4, 20, $2::$3
.context=$2::$3_prop
.pre=$(reset)$(rule)\par 
$(reset)$(heading_1)$2::$3 Property\par
$(reset)$(rmh)Data Type\par 
$(reset)$(normal){\b $1}\par 
$(reset)$(rmh)Description\par 
$(reset)$(normal)$4\par 
$(reset)$(normal)Defined in: $!p\par 

.tag=property, help, 4, 20, $2::$3
.context=$2::$3_prop
.pre=\page 
##{\footnote ## #2__#3_prop}
$${\footnote $$ $2::$3 Property}
K{\footnote K OLE object properties; object properties; properties; $2 interface; $3 property}
+{\footnote + OLE:0000} 
$(reset)$(heading_1)$2::$3 Property\par 
$(reset)$(rmh)Data Type\par 
$(reset)$(normal){\b $1}\par 
$(reset)$(rmh)Description\par 
$(reset)$(normal)$4\par 
$(reset)$(normal)Defined in: $!p\par 

; Object events

.tag=event, doc, 3, 20, $1::$2
.context=$1::$2_event
.pre=$(reset)$(rule)\par 
$(reset)$(heading_1)$1::$2 Event\par
$[event]
$(reset)$(rmh)Description\par 
$(reset)$(normal)$3\par 
$(reset)$(normal)Defined in: $!p\par 

.tag=event, help, 3, 20, $1::$2
.context=$1::$2_event
.pre=\page 
##{\footnote ## #1__#2_event}
$${\footnote $$ $1::$2 Event}
K{\footnote K OLE object properties; object properties; properties; $1 interface; $2 Event}
+{\footnote + OLE:0000} 
$(reset)$(heading_1)$1::$2 Event\par 
$[event]
$(reset)$(rmh)Description\par 
$(reset)$(normal)$3\par 
$(reset)$(normal)Defined in: $!p\par 
;
; ***********************************************************
; Undocumented Tags
; ***********************************************************

.tag=topic, doc, 2, 5, $1
.pre=\pard\plain $(heading_1)$1\par 
\pard\plain $(normal)$2\par 

.tag=topic, help, 2, 5, $1
.pre=\page \pard\plain $(heading_1)
##{\footnote ## #1}
$${\footnote $$ $1}
K{\footnote K $1}
+{\footnote + overviews:0000} 
$1\par 
\pard\plain $(normal)$2\par 

[paragraph]
;
; ***********************************************************
; C Tags
; ***********************************************************

; Parameters
.tag=parm, both, 3, 1
.parsesource=parameter
.pre=$(reset)$(rmh)Parameters\par 
.format=$(reset)$(term1){\i $2}\par 
$(reset)$(def1)$3\par 


; Variable length parameter list
.tag=parmvar, both, 1, 1
.pre=$(reset)$(rmh)Parameters\par 
.format=$(reset)$(term1){\b ...}\par 
$(reset)$(def1)$1\par 

; Class template arguments 
.tag=tcarg, both, 3, 1
.parsesource=parameter
.pre=$(reset)$(rmh)Class Template Arguments\par 
.format=$(reset)$(term1){\i $2}\par 
$(reset)$(def1)$3\par 

; Function template arguments 
.tag=tfarg, both, 3, 1
.parsesource=parameter
.pre=$(reset)$(rmh)Function Template Arguments\par 
.format=$(reset)$(term1){\i $2}\par 
$(reset)$(def1)$3\par 

.tag=field, both, 3, 1
.parsesource=parameter
.pre=$(reset)$(rmh)Members\par 
.format=$(reset)$(term1){\b $2}\par 
$(reset)$(def1)$3\par 

.tag=flag, both, 2, 2
.format=$(reset)$(term2)$1\par 
$(reset)$(def2)$2\par 

.tag=rdesc, both, 1, 1
.pre=$(reset)$(rmh)Return Value\par 
.format=$(reset)$(normal)$1\par 

.tag=emem, both, 2, 1
.parsesource=emem
.pre=\pard\plain $(rmh)Members\par 
.format=\pard\plain $(term1){\b $1}\par 
\pard\plain $(def1)$2\par 

.tag=field, both, 3, 1
.parsesource=parameter
.pre=$(reset)$(rmh)Members\par 
.format=$(reset)$(term1){\b $2}\par 
$(reset)$(def1)$3\par 

; Global variables
.tag=globalv, help, 3, 1
.parsesource=parameter
.pre=$(reset)$(rmh)Global Variables\par 
.format=$(reset)$(term1){\uldb $1}{\v $1} {\b $2}\par 
$(reset)$(def1)$3\par 
.if=exists($1)

.tag=globalv, both, 3, 1
.parsesource=parameter
.pre=$(reset)$(rmh)Global Variables\par 
.format=$(reset)$(term1){\b $1 $2}\par 
$(reset)$(def1)$3\par 
;
; ***********************************************************
; Misc Tags
; ***********************************************************

.tag=comm, both, 1, 1
.pre=$(reset)$(rmh)Comments\par 
.format=$(reset)$(normal)$1\par 

.tag=xref, both, 1, 1
.pre=$(reset)$(rmh)See Also\par 
.format=$(reset)$(normal)$1\par 

.tag=ex, both, 2, 1, 1
.pre=$(reset)$(rmh)Example\par 
.format=$(reset)$(normal)$1\par 
$(reset)$(ex)$2\par 
$(reset)$(ex)\par 

.tag=iex, both, 1, 8, 1
.format=$(reset)$(ex)$1\par 
$(reset)$(ex)\par 

.tag=devnote, both, 1, 1
.pre=$(reset)$(rmh)\cf6 Developer Notes\par 
.format=$(reset)$(normal)\cf6 $1\par 

.tag=todo, both, 1, 1
.pre=$(reset)$(rmh)\cf6 To Do\par 
.format=$(reset)$(normal)\cf6 $1\par 

.tag=syntax, both, 1, 1
.pre=\pard\plain $(rmh)Syntax\par 
.format=\pard\plain $(normal)$1\par 

;
; ***********************************************************
; C++ Tags
; ***********************************************************

.tag=access, both, 1, 1
.pre=$(reset)$(rmh)Class Members\par 
.format=$(reset)$(normal){\b $1}\par 

; ** @CMEMBER
; Replacement for @member - uses automatic parsing, 4 fields

; link name and type - data member

.tag=cmember, help, 4, 2
.pre=$[classhdr]
.format=$(reset)$(term1){\uldb $1}{\v #1} {\uldb $2}{\v #class.1__#2}\par 
$(reset)$(def1)$4\par 

.if=exists($class.1::$<2),fieldempty(3),exists($1)
.parsesource=classmember

; link name and type - function member

.tag=cmember, help, 4, 2
.pre=$[classhdr]
.format=$(reset)$(term1){\uldb $1}{\v #1} {\uldb $2}{\v #class.1__#2}{\b $3}\par 
$(reset)$(def1)$4\par 

.if=exists($class.1::$<2),exists($1)
.parsesource=classmember

; link name - data member

.tag=cmember, help, 4, 2
.pre=$[classhdr]
.format=$(reset)$(term1){\b $1} {\uldb $2}{\v #class.1__#2}\par 
$(reset)$(def1)$4\par 

.if=exists($class.1::$<2),fieldempty(3)
.parsesource=classmember

; link name - function member, no return value

.tag=cmember, help, 4, 2
.pre=$[classhdr]
.format=$(reset)$(term1){\uldb $2}{\v #class.1__#2}{\b $3}\par 
$(reset)$(def1)$4\par 

.if=exists($class.1::$<2),fieldempty(1)
.parsesource=classmember

; link name - function member

.tag=cmember, help, 4, 2
.pre=$[classhdr]
.format=$(reset)$(term1){\b $1} {\uldb $2}{\v #class.1__#2}{\b $3}\par 
$(reset)$(def1)$4\par 

.if=exists($class.1::$<2)
.parsesource=classmember

; no links or doc - data member

.tag=cmember, both, 4, 2
.pre=$[classhdr]
.format=$(reset)$(term1){\b $1 $2}\par 
$(reset)$(def1)$4\par 

.parsesource=classmember
.if=fieldempty(3)

; no links or doc - function member, no return value

.tag=cmember, both, 4, 2
.pre=$[classhdr]
.format=$(reset)$(term1){\b $2$3}\par 
$(reset)$(def1)$4\par 

.parsesource=classmember
.if=fieldempty(1)

; no links or doc - function member

.tag=cmember, both, 4, 2
.pre=$[classhdr]
.format=$(reset)$(term1){\b $1 $2$3}\par 
$(reset)$(def1)$4\par 

.parsesource=classmember

; ** @MEMBER
; Old @member tag

.tag=member, help, 2, 2
.format=$(reset)$(term1){\uldb $1}{\v #class.1__#1}\par 
$(reset)$(def1)$2\par 
.if=exists($class.1::$1)

.tag=member, both, 2, 2
.format=$(reset)$(term1){\b $1}\par 
$(reset)$(def1)$2\par 

; used to specify base classes for a C++ class
;
; in an "@interface" topic we actually show the base class.
; in an "@class" topic the base class shows up in the diagram.

.tag=base, help, 2, 1
.pre=$(reset)$(rmh)Based On\par 
.format=$(reset)$(normal){\uldb $2}{\v $2_int}\par 
.if=exists($2_int), tagexists(interface)

.tag=base, both, 2, 1
.pre=$(reset)$(rmh)Based On\par 
.format=$(reset)$(normal){\b $2}\par 
.if=tagexists(interface)

.tag=base, both, 2, 1
.format=

; used to add "const" keyword to end of member function diagram

.tag=this, both, 1, 1
.format=

;
; ***********************************************************
; OLE Tags
; ***********************************************************

; *** Methods ***

;link type and name

.tag=meth, help, 3, 1
.pre=$(reset)$(rmh)Methods\par 
.format=$(reset)$(term1){\uldb $1}{\v #1} {\uldb $2}{\v I#interface.1__#2_meth}\par 
$(reset)$(def1)$3\par 
.if=exists($1),exists($interface.1::$2_meth)

; link name

.tag=meth, help, 3, 1
.pre=$(reset)$(rmh)Methods\par 
.format=$(reset)$(term1){\b $1} {\uldb $2}{\v #interface.1__#2_meth}\par 
$(reset)$(def1)$3\par 
.if=exists($interface.1::$2_meth)

; link type only

.tag=meth, help, 3, 1
.pre=$(reset)$(rmh)Methods\par 
.format=$(reset)$(term1){\uldb $1}{\v #1} {\b $2}\par 
$(reset)$(def1)$3\par 
.if=exists($1)

; no links or doc

.tag=meth, both, 3, 1
.pre=$(reset)$(rmh)Methods\par 
.format=$(reset)$(term1){\b $1 $2}\par 
$(reset)$(def1)$3\par 

; *** Properties ***

;link type and name

.tag=prop, help, 3, 1
.pre=$(reset)$(rmh)Properties\par 
.format=$(reset)$(term1){\uldb $1}{\v #1} {\uldb $2}{\v #interface.1__#2_prop}\par 
$(reset)$(def1)$3\par 
.if=exists($1),exists($interface.1::$2_prop)

;link name only

.tag=prop, help, 3, 1
.pre=$(reset)$(rmh)Properties\par 
.format=$(reset)$(term1){\b $1} {\uldb $2}{\v #interface.1__#2_prop}\par 
$(reset)$(def1)$3\par 
.if=exists($interface.1::$2_prop)

; link type only

.tag=prop, help, 3, 1
.pre=$(reset)$(rmh)Properties\par 
.format=$(reset)$(term1){\uldb $1}{\v #1} {\b $2}\par 
$(reset)$(def1)$3\par 
.if=exists($1)

; link neither, or doc

.tag=prop, both, 3, 1
.pre=$(reset)$(rmh)Properties\par 
.format=$(reset)$(term1){\b $1 $2}\par 
$(reset)$(def1)$3\par 

; *** Events *** 

;link name

.tag=eve, help, 2, 1
.pre=$(reset)$(rmh)Events\par 
.format=$(reset)$(term1){\uldb $1}{\v #interface.1__#1_event}\par 
$(reset)$(def1)$2\par 
.if= exists($interface.1::$1_event)

; no link, or doc

.tag=eve, both, 2, 1
.pre=$(reset)$(rmh)Events\par 
.format=$(reset)$(term1){\b $1}\par 
$(reset)$(def1)$2\par 

.tag=rvalue, doc, 2, 1
.pre=$(reset)$(rmh)Return Codes\par
\trowd \trgaph72\trleft-72 \cellx3078\cellx7038 
.format=$(reset)\intbl$(table_text){\fs18 $1\cell $2\cell }\pard \intbl \row 
.post=$(reset)\li240\sa0\sl240 \f2\fs20\lang1033 \par 

.tag=rvalue, help, 2, 1
.pre=$(reset)$(rmh)Return Codes\par
\trowd \trgaph108\trleft162 \cellx2430\cellx8748 
.format=$(reset)\intbl $(table_text){\fs16 $1}\cell $2\cell \pard \intbl \row 
.post=$(reset)$(normal)\par 

; link interface name

.tag=supint, help, 2, 1
.pre=$(reset)$(rmh)Supported Interfaces\par 
.format=$(reset)$(term1){\uldb $1}{\v #1_int}\par 
$(reset)$(def1)$2\par 
.if=exists($1_int)

; no link, or doc

.tag=supint, both, 2, 1
.pre=$(reset)$(rmh)Supported Interfaces\par 
.format=$(reset)$(term1){\b $1}\par 
$(reset)$(def1)$2\par 

; link interface name

.tag=reqint, help, 2, 1
.pre=$(reset)$(rmh)Required Interfaces\par 
.format=$(reset)$(term1){\uldb $1}{\v #1_int}\par 
$(reset)$(def1)$2\par 
.if=exists($1_int)

; no link, or doc

.tag=reqint, both, 2, 1
.pre=$(reset)$(rmh)Required Interfaces\par 
.format=$(reset)$(term1){\b $1}\par 
$(reset)$(def1)$2\par 

; link interface name

.tag=optint, help, 2, 1
.pre=$(reset)$(rmh)Optional Interfaces\par 
.format=$(reset)$(term1){\uldb $1}{\v #1_int}\par 
$(reset)$(def1)$2\par 
.if=exists($1_int)

; no link, or doc

.tag=optint, both, 2, 1
.pre=$(reset)$(rmh)Optional Interfaces\par 
.format=$(reset)$(term1){\b $1}\par 
$(reset)$(def1)$2\par 

; Interfaces/objects that support a property or method

.tag=supby, both, 1, 1
.pre=$(reset)$(rmh)Supported By\par 
.format=$(reset)$(normal){\b $1}\par 

; Interfaces that an object expects to consume

.tag=consumes, both, 1, 1
.pre=$(reset)$(rmh)Consumes\par 
.format=$(reset)$(normal){\b $1}\par 

; Abstract object types to which an abstract object type belongs

.tag=is, both, 1, 1
.pre=$(reset)$(rmh)Is A\par 
.format=$(reset)$(normal){\b $1}\par 

; Aggregates

; link interface name

.tag=aggregates, help, 2, 1
.pre=$(reset)$(rmh)Aggregated Objects\par 
.format=$(reset)$(term1){\uldb $1}{\v #1}\par 
$(reset)$(def1)$2\par 
.if=exists($1)

; no link, or doc

.tag=aggregates, both, 2, 1
.pre=$(reset)$(rmh)Aggregated Objects\par 
.format=$(reset)$(term1){\b $1}\par 
$(reset)$(def1)$2\par 

; ******************************************
; Undocumented tags
; ******************************************

.tag=head1, both, 2, 1
.format=\pard\plain $(heading_1)$1\par 
\pard\plain $(normal)$2\par 

.tag=head2, both, 2, 1
.format=\pard\plain $(heading_1)$1\par 
\pard\plain $(normal)$2\par 

.tag=head3, both, 2, 1
.format=\pard\plain $(heading_3)$1\par 
\pard\plain $(normal)$2\par 

.tag=iex2, both, 2, 8, 1
.format=$(reset)$(ex)$2\par 
$(reset)$(ex)\par 

.tag=group, both, 1, 8
.format=\pard\plain $(heading_3)$1\par 

.tag=end, both, 0, 8
.format=

[text]

; ******************************************
; Symbols
; ******************************************

.tag=cp, both, 0
.format=\'a9 
.tag=tm, both, 0
.format=\'99 
.tag=rtm, both, 0
.format=\'ae 
.tag=en-, doc, 0
.format=\endash 
.tag=en-, help, 0
.format=\'97 
.tag=em-, doc, 0
.format=\emdash 
.tag=em-, help, 0
.format=\'96 
.tag=lq, doc, 0
.format=\ldblquote 
.tag=lq, help, 0
.format=\'91 
.tag=rq, doc, 0
.format=\rdblquote 
.tag=rq, help, 0
.format=\'92 
.tag=gt, both, 0
.format=>
.tag=lt, both, 0
.format=<
.tag=tab, both, 0
.format=\tab 
.tag=nl, both, 0
.format=\line 
.tag=cmt, both, 0
.format=//
;
; ******************************************
; Graphics
; ******************************************
.tag=bmp, help, 1
.format=\{bmc $1\}
.tag=bmp, doc, 1
.format={\field{\*\fldinst  INCLUDEPICTURE $1 \\* MERGEFORMAT }}}
;
; ******************************************
; Functions
; ******************************************

.tag=f, help, 1
.format={\b $1}
.if=$1=$func.2

.tag=f, help, 1
.format={\uldb $1}{\v #1}
.if=exists($1)

.tag=f, both, 1
.format={\b $1}
;
; ******************************************
; Messages
; ******************************************

.tag=m, help, 1
.format=$1
.if=$1=$msg.1

.tag=m, help, 1
.format={\uldb $1}{\v #1}
.if=exists($1)

.tag=m, both, 1
.format=$1
;
; ******************************************
; Structures
; ******************************************

.tag=t, help, 1
.format={\b $1}
.if=$1=$struct.1

.tag=t, help, 1
.format={\b $1}
.if=$1=$enum.1

.tag=t, help, 1
.format={\uldb $1}{\v #1}
.if=exists($1)

.tag=t, both, 1
.format={\b $1}
;
; ******************************************
; Parameters
; ******************************************

.tag=p, both, 1
.format={\i $1}
;
; ******************************************
; Structure and Enumeration Elements
; ******************************************

.tag=e, help, 2
.format={\b $2}
.if=$1=$struct.1
.tag=e, help, 2
.format={\b $2}
.if=$1=$enum.1
.tag=e, help, 2
.format={\uldb $2}{\v #1}
.if=exists($1)
.tag=e, both, 2
.format={\b $2}

;
; ******************************************
; Classes
; ******************************************

.tag=c, help, 1
.format={\b $1}
.if=$1=$class.1
.tag=c, help, 1
.format={\uldb $1}{\v #1}
.if=exists($1)
.tag=c, both, 1
.format={\b $1}
;
; ******************************************
; Member Functions
; ******************************************

; circular reference, make bold
;
.tag=mf, help, 2
.format={\b $2}
.if=fieldempty(1),$2=$mfunc.3
.if=$1=$mfunc.2,$2=$mfunc.3

; same class, different function, link target exists: omit class name & link
;
.tag=mf, help, 2
.format={\uldb $2}{\v #class.1#mfunc.2#mdata.2__#2}
.if=fieldempty(1),exists($class.1$mfunc.2$mdata.2::$2)
.if=exists($1::$2),$1=$class.1$mfunc.2$mdata.2

; different class, link target exists: output class::function & link
;
.tag=mf, help, 2
.format={\uldb $1::$2}{\v #1__#2}
.if=exists($1::$2)

; same class, no link target: omit class name & bold
;
.tag=mf, both, 2
.format={\b $2}
.if=fieldempty(1)
.if=$1=$class.1$mfunc.2$mdata.2

; nothing to link to, within different class
;
.tag=mf, both, 2
.format={\b $1::$2}
;
; ******************************************
; Member data
; ******************************************

; circular reference, make bold
;
.tag=md, help, 2
.format={\b $2}
.if=fieldempty(1),$2=$mdata.3
.if=$1=$mfunc.2,$2=$mdata.3

; same class, different function, link target exists: omit class name & link
;
.tag=md, help, 2
.format={\uldb $2}{\v #class.1#mfunc.2#mdata.2__#2}
.if=fieldempty(1),exists($class.1$mfunc.2$mdata.2::$2)
.if=exists($1::$2),$1=$class.1$mfunc.2$mdata.2

; different class, link target exists: output class::function & link
;
.tag=md, help, 2
.format={\uldb $1::$2}{\v #1__#2}
.if=exists($1::$2)

; same class, no link target: omit class name & bold
;
.tag=md, both, 2
.format={\b $2}
.if=fieldempty(1)
.if=$1=$class.1$mfunc.2$mdata.2

; nothing to link to, within different class
;
.tag=md, both, 2
.format={\b $1::$2}

;
; ******************************************
; OLE Objects
; ******************************************

.tag=o, help, 1
.format={\b $1}
.if=$1=$abstract.1$object.1
.tag=o, help, 1
.format={\uldb $1}{\v #1}
.if=exists($1)
.tag=o, both, 1
.format={\b $1}
;
; ******************************************
; OLE Interfaces
; ******************************************

.tag=i, help, 1
.format={\b $1}
.if=$1=$interface.1
.tag=i, help, 1
.format={\uldb $1}{\v #1_int}
.if=exists($1_int)
.tag=i, both, 1
.format={\b $1}
;
; ******************************************
; OLE Methods
; ******************************************

; circular reference, make bold
; example: <om .Bar> appearing in @method ret|IFoo|Bar

.tag=om, help, 2
.format={\b $2}
.if=tagexists(method),fieldempty(1),$2=$method.3
.if=$1=$method.2,$2=$method.3

; @abstract or @object tag, empty field, link 
; example: <om .Bar> appearing in @abstract Foo or @object Foo

.tag=om, help, 2
.format={\uldb $2}{\v I#abstract.1#object.1__#2_meth}
.if=tagexists(object),fieldempty(1),exists(I$object.1::$2_meth)
.if=tagexists(abstract),fieldempty(1),exists(I$abstract.1::$2_meth)

; @method, @interface, @property, @event, empty field, link
; example: <om .Bar> appearing in @interface IFoo

.tag=om, help, 2
.format={\uldb $2}{\v #method.2#property.2#interface.1#event.1__#2_meth}
.if=fieldempty(1),exists($method.2$property.2$interface.1$event.1::$2_meth)

; @object, @abstract, same object, link
; example: <om IFoo.Bar> appearing in @object Foo

.tag=om, help, 2
.format={\uldb $2}{\v I#object.1#abstract.1__#2_meth}
.if=tagexists(object),$1=I$object.1,exists(I$object.1::$2_meth)
.if=tagexists(abstract),$1=I$abstract.1,exists(I$abstract.1::$2_meth)

; @method, @interface, @property, @event, same interface, link
; example: <om IFoo.Bar> appearing in @method ret|IFoo|Bar

.tag=om, help, 2
.format={\uldb $2}{\v #method.2#property.2#interface.1#event.1__#2_meth}
.if=$1=$method.2$property.2$interface.1$event.1,exists($method.2$property.2$interface.1$event.1::$2_meth)

; different interface, link
; example: <om IFoo.Bar> appearing in @method ret|IBar|Foo

.tag=om, help, 2
.format={\uldb $1::$2}{\v #1__#2_meth}
.if=exists($1::$2_meth)

; same interface, no link
; example: <om IFoo.Bar> appearing in @method ret|IBar|Foo but no
;               IFoo::Bar defined

.tag=om, both, 2
.format={\b $2}
.if=tagexists(object),$1=I$object.1
.if=tagexists(abstract),$1=I$abstract.1
.if=$1=$method.2$property.2$interface.1$event.1
.if=fieldempty(1)

; default: both fields, 
; example: <om IFoo.Bar> output with "IFoo.Bar" in bold
.tag=om, both, 2
.format={\b $1::$2}

;
; ******************************************
; OLE Properties
; ******************************************

; circular reference, make bold
; example: <op .Bar> appearing in @property type|IFoo|Bar

.tag=op, help, 2
.format={\b $2}
.if=tagexists(property),fieldempty(1),$2=$property.3
.if=$1=$property.2,$2=$property.3

; @abstract or @object tag, empty field, link 
; example: <op .Bar> appearing in @abstract Foo or @object Foo

.tag=op, help, 2
.format={\uldb $2}{\v I#abstract.1#object.1__#2_prop}
.if=tagexists(object),fieldempty(1),exists(I$object.1::$2_prop)
.if=tagexists(abstract),fieldempty(1),exists(I$abstract.1::$2_prop)

; @method, @interface, @property, @event, empty field, link
; example: <op .Bar> appearing in @interface IFoo

.tag=op, help, 2
.format={\uldb $2}{\v #method.2#property.2#interface.1#event.1__#2_prop}
.if=fieldempty(1),exists($method.2$property.2$interface.1$event.1::$2_prop)

; @object, @abstract, same object, link
; example: <op IFoo.Bar> appearing in @object Foo

.tag=op, help, 2
.format={\uldb $2}{\v I#object.1#abstract.1__#2_prop}
.if=tagexists(object),$1=I$object.1,exists(I$object.1::$2_prop)
.if=tagexists(abstract),$1=I$abstract.1,exists(I$abstract.1::$2_prop)

; @method, @interface, @property, @event, same interface, link
; example: <op IFoo.Bar> appearing in @method ret|IFoo|Bar

.tag=op, help, 2
.format={\uldb $2}{\v #method.2#property.2#interface.1#event.1__#2_prop}
.if=$1=$method.2$property.2$interface.1$event.1,exists($method.2$property.2$interface.1$event.1::$2_prop)

; different interface, link
; example: <op IFoo.Bar> appearing in @method ret|IBar|Foo

.tag=op, help, 2
.format={\uldb $1::$2}{\v #1__#2_prop}
.if=exists($1::$2_prop)

; same interface, no link
; example: <op IFoo.Bar> appearing in @method ret|IBar|Foo but no
;               IFoo::Bar defined

.tag=op, both, 2
.format={\b $2}
.if=tagexists(object),$1=I$object.1
.if=tagexists(abstract),$1=I$abstract.1
.if=$1=$method.2$property.2$interface.1$event.1
.if=fieldempty(1)

; default: both fields, 
; example: <op IFoo.Bar> output with "IFoo.Bar" in bold
.tag=op, both, 2
.format={\b $1::$2}

; ******************************************
; OLE Events
; ******************************************
; See "OLE Methods" for descriptions/examples of each block

; circular reference

.tag=oe, help, 2
.format={\b $2}
.if=fieldempty(1),$2=$event.1
.if=$1=$event.1,$2=$event.2

; link, ref. same interface within @object, @abstract, 
; omit interface prefix

.tag=oe, help, 2
.format={\uldb $2}{\v I#abstract.1#object.1__#2_event}
.if=tagexists(object),fieldempty(1),exists(I$object.1::$2_event)
.if=tagexists(abstract),fieldempty(1),exists(I$abstract.1::$2_event)
.if=tagexists(object),$1=I$object.1,exists(I$object.1::$2_event)
.if=tagexists(abstract),$1=I$abstract.1,exists(I$abstract.1::$2_event)

; link, ref. same interface within @method, @property, @interface, @event
; omit interface prefix

.tag=oe, help, 2
.format={\uldb $2}{\v #event.1#method.2#property.2#interface.1__#2_event}
.if=fieldempty(1),exists($event.1$method.2$property.2$interface.1::$2_event)
.if=$1=$event.1$method.2$property.2$interface.1,exists($1::$2_event)

; no link, ref. same interface
; omit interface prefix

.tag=oe, both, 2
.format={\b $2}
.if=fieldempty(1)
.if=$1=I$object.1$abstract.1
.if=$1=$method.2$property.2$interface.1$event.1

; link
.tag=oe, help, 2
.format={\uldb $1::$2}{\v #1__#2_event}
.if=exists($1::$2_event)

;
; default
.tag=oe, both, 2
.format={\b $1::$2}

; ******************************************
; Misc weirdness
; ******************************************
.tag=y, both, 1
.format={\i $1}

.tag=l, doc, 2
.format=$1
;
.tag=l, help, 2
.format={\uldb $1}{\v #2}

[diagram]

; *** Function diagram ******
;
; No return value, parameters

.tag=function, both, parm
.cancelifpresent=syntax
.pre=\pard \plain $(normal)$[ftemplate]{\b $1} {\b $2$(}
.post=$[vararg]{\b ) $this.1}\par
.formatfirst={\b $1} {\i $2}
.format={\b , $1} {\i $2}
.if=fieldempty(1), tagexists(parm)

; No return value, no parameters

.tag=function, both, parm
.cancelifpresent=syntax
.pre=\pard \plain $(normal)$[ftemplate]{\b $2(void}
.post=$[vararg]{\b ) $this.1}\par
.format=
.if=fieldempty(1)

; Return value, parameters
;
.tag=function, both, parm
.cancelifpresent=syntax
.pre=\pard \plain $(normal)$[ftemplate]{\b $1} {\b $2(}
.post=$[vararg]{\b ) $this.1}\par
.formatfirst={\b $1} {\i $2}
.format={\b , $1} {\i $2}
.if=tagexists(parm)

; Return value, no parameters
;
.tag=function, both, parm
.cancelifpresent=syntax
.pre=\pard \plain $(normal)$[ftemplate]{\b $1} {\b $2(void}
.post=$[vararg]{\b ) $this.1}\par
.format=
;

; *** Member Functions ******

; No return value, parameters

.tag=mfunction, both, parm
.cancelifpresent=syntax
.pre=\pard \plain $(normal)$[template]{\b $2}$[tcarg]{\b ::$3$[tfarg](}
.post={\b ) $this.1}\par
.formatfirst={\b $1} {\i $2}
.format={\b , $1} {\i $2}
.if=fieldempty(1), tagexists(parm)

; No return value, no parameters

.tag=mfunction, both, parm
.cancelifpresent=syntax
.pre=\pard \plain $(normal)$[template]{\b $2}$[tcarg]{\b ::$3$[tfarg](void}
.post={\b ) $this.1}\par
.format=
.if=fieldempty(1)

; Return value, parameters
;
.tag=mfunction, both, parm
.cancelifpresent=syntax
.pre=\pard \plain $(normal)$[template]{\b $1} {\b $2}$[tcarg]{\b ::$3$[tfarg](}
.post={\b ) $this.1}\par
.formatfirst={\b $1} {\i $2}
.format={\b , $1} {\i $2}
.if=tagexists(parm)

; Return value, no parameters
;
.tag=mfunction, both, parm
.cancelifpresent=syntax
.pre=\pard \plain $(normal)$[template]{\b $1} {\b $2}$[tcarg]{\b ::$3$[tfarg](void}
.post={\b ) $this.1}\par
.format=
;

; **** OLE2 Method ********

.tag=method, both, parm
.pre=\pard \plain $(normal){\b $1 $3(}
.post={\b )}\par
.formatfirst={\b $1} {\i $2}
.format={\b , $1} {\i $2}

; **** OLE2 Event ********

.tag=event, both, parm
.cancelifpresent=syntax
.pre=\pard \plain $(normal){\b $1(}
.post={\b )}\par
.formatfirst={\b $1} {\i $2}
.format={\b , $1} {\i $2}

; **** Structure ********

.tag=structure, both, field
.pre=$(reset)$(ex)typedef struct \{\par 
.format=$(reset)$(ex)\tab $1 $2;\par 
.post=$(reset)$(ex)\} $1;\par 
$(reset)$(ex)\par 

; **** Enumeration ********

.tag=enum, both, emem
.pre=$(reset)$(ex)enum $1 \{\par ^n
.formatfirst=$(reset)$(ex)\tab $1
.format=,\par 
$(reset)$(ex)\tab $1
.post=\par 
$(reset)$(ex)\};\par 
$(reset)$(ex)\par 

; **** Class *****************

.tag=class, both, base
.pre=$(reset)$(normal)$[template]{\b class $1}
.formatfirst={\b : $1 $2}
.format={\b , $1 $2}
.post=\par 

; **** Template specification for classes or member functions

.tag=template, both, tcarg
.pre={\b template <}
.formatfirst={\b $1 }{\i $2}
.format=, {\b $1 }{\i $2}
.post={\b >}\line 
.if=tagexists(tcarg)

.tag=template, both, tcarg
.format=

; **** Template specification for functions

.tag=ftemplate, both, tfarg
.pre={\b template <}
.formatfirst={\b $1 }{\i $2}
.format=, {\b $1 }{\i $2}
.post={\b >}\line 
.if=tagexists(tfarg)

.tag=ftemplate, both, tfarg
.format=

; **** member function args list

.tag=tcarg, both, tcarg
.pre={\b <}
.formatfirst={\i $2}
.format={\b , }{\i $2}
.post={\b >}
.if=tagexists(tcarg)

.tag=tcarg, both, targ
.format=

; **** function args list

.tag=tfarg, both, tfarg
.pre={\b <}
.formatfirst={\b $1} {\i $2}
.format={\b , }{\b $1} {\i $2}
.post={\b >}
.if=tagexists(tfarg)

.tag=tfarg, both, tfarg
.format=

; ****** function variable args
.tag=vararg, both, parmvar
.format={\b , ...}
.if=tagexists(parmvar)

; ****** function variable args
.tag=vararg, both, parmvar
.format=

; ****** Member data diagram

.tag=mdata, help, parm
.cancelifpresent=syntax
.pre=$(reset)$(normal){\uldb $1}{\v $1} {\uldb $2}{\v $2}{\b ::$3}
.post=\par
.format=
.if=exists($1),exists($2)

.tag=mdata, help, parm
.cancelifpresent=syntax
.pre=$(reset)$(normal){\b $1} {\uldb $2}{\v $2}{\b ::$3}
.post=\par
.format=
.if=exists($2)

.tag=mdata, help, parm
.cancelifpresent=syntax
.pre=$(reset)$(normal){\uldb $1}{\v $1} {\b $2}{\b ::$3}
.post=\par
.format=
.if=exists($1)

.tag=mdata, both, parm
.cancelifpresent=syntax
.pre=$(reset)$(normal){\b $1 $2::$3}
.post=\par
.format=

.tag=classhdr, both, parm
.cancelifpresent=access
.pre=$(reset)$(rmh)Class Members\par 
.format=

[index]
.output=help
.prename=$(reset)$(indexlink){\uldb 
.precontext=}{\v 
.postcontext=}\par

